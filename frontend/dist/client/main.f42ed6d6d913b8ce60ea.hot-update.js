webpackHotUpdate("main",{

/***/ "./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stripBasename = exports.resolveTo = exports.resolvePath = exports.redirectDocument = exports.redirect = exports.parsePath = exports.normalizePathname = exports.matchRoutes = exports.matchPath = exports.json = exports.joinPaths = exports.isRouteErrorResponse = exports.isDeferredData = exports.getToPathname = exports.getStaticContextFromError = exports.generatePath = exports.defer = exports.createStaticHandler = exports.createRouter = exports.createPath = exports.createMemoryHistory = exports.createHashHistory = exports.createBrowserHistory = exports.UNSAFE_warning = exports.UNSAFE_invariant = exports.UNSAFE_getResolveToMatches = exports.UNSAFE_convertRoutesToDataRoutes = exports.UNSAFE_convertRouteMatchToUiMatch = exports.UNSAFE_ErrorResponseImpl = exports.UNSAFE_DeferredData = exports.UNSAFE_DEFERRED_SYMBOL = exports.IDLE_NAVIGATION = exports.IDLE_FETCHER = exports.IDLE_BLOCKER = exports.Action = exports.AbortedDeferredError = void 0;\n/**\n * @remix-run/router v1.14.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\nexports.Action = Action;\n(function (Action) {\n    /**\n     * A POP indicates a change to an arbitrary index in the history stack, such\n     * as a back or forward navigation. It does not describe the direction of the\n     * navigation, only that the current index changed.\n     *\n     * Note: This is the default action for newly created history objects.\n     */\n    Action[\"Pop\"] = \"POP\";\n    /**\n     * A PUSH indicates a new entry being added to the history stack, such as when\n     * a link is clicked and a new page loads. When this happens, all subsequent\n     * entries in the stack are lost.\n     */\n    Action[\"Push\"] = \"PUSH\";\n    /**\n     * A REPLACE indicates the entry at the current index in the history stack\n     * being replaced by a new one.\n     */\n    Action[\"Replace\"] = \"REPLACE\";\n})(Action || (exports.Action = Action = {}));\nvar PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.initialEntries, initialEntries = _a === void 0 ? [\"/\"] : _a, initialIndex = options.initialIndex, _b = options.v5Compat, v5Compat = _b === void 0 ? false : _b;\n    var entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map(function (entry, index) { return createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined); });\n    var index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    var action = Action.Pop;\n    var listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        var location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    var history = {\n        get index() {\n            return index;\n        },\n        get action() {\n            return action;\n        },\n        get location() {\n            return getCurrentLocation();\n        },\n        createHref: createHref,\n        createURL: function (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation: function (to) {\n            var path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push: function (to, state) {\n            action = Action.Push;\n            var nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action: action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace: function (to, state) {\n            action = Action.Replace;\n            var nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action: action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go: function (delta) {\n            action = Action.Pop;\n            var nextIndex = clampIndex(index + delta);\n            var nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action: action,\n                    location: nextLocation,\n                    delta: delta\n                });\n            }\n        },\n        listen: function (fn) {\n            listener = fn;\n            return function () {\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\nexports.createMemoryHistory = createMemoryHistory;\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window, globalHistory) {\n        var _a = window.location, pathname = _a.pathname, search = _a.search, hash = _a.hash;\n        return createLocation(\"\", {\n            pathname: pathname,\n            search: search,\n            hash: hash\n        }, \n        // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nexports.createBrowserHistory = createBrowserHistory;\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window, globalHistory) {\n        var _a = parsePath(window.location.hash.substr(1)), _b = _a.pathname, pathname = _b === void 0 ? \"/\" : _b, _c = _a.search, search = _c === void 0 ? \"\" : _c, _d = _a.hash, hash = _d === void 0 ? \"\" : _d;\n        // Hash URL should always have a leading / just like window.location.pathname\n        // does, so if an app ends up at a route like /#something then we add a\n        // leading slash so all of our path-matching behaves the same as if it would\n        // in a browser router.  This is particularly important when there exists a\n        // root splat route (<Route path=\"*\">) since that matches internally against\n        // \"/*\" and we'd expect /#something to 404 in a hash router app.\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname: pathname,\n            search: search,\n            hash: hash\n        }, \n        // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window, to) {\n        var base = window.document.querySelector(\"base\");\n        var href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            var url = window.location.href;\n            var hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nexports.createHashHistory = createHashHistory;\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nexports.UNSAFE_invariant = invariant;\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\")\n            console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience, so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n            // eslint-disable-next-line no-empty\n        }\n        catch (e) { }\n    }\n}\nexports.UNSAFE_warning = warning;\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    var location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state: state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n    var _a = _ref.pathname, pathname = _a === void 0 ? \"/\" : _a, _b = _ref.search, search = _b === void 0 ? \"\" : _b, _c = _ref.hash, hash = _c === void 0 ? \"\" : _c;\n    if (search && search !== \"?\")\n        pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\")\n        pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\nexports.createPath = createPath;\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n    var parsedPath = {};\n    if (path) {\n        var hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        var searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nexports.parsePath = parsePath;\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.window, window = _a === void 0 ? document.defaultView : _a, _b = options.v5Compat, v5Compat = _b === void 0 ? false : _b;\n    var globalHistory = window.history;\n    var action = Action.Pop;\n    var listener = null;\n    var index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState(_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        var state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = Action.Pop;\n        var nextIndex = getIndex();\n        var delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action: action,\n                location: history.location,\n                delta: delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        var location = createLocation(history.location, to, state);\n        if (validateLocation)\n            validateLocation(location, to);\n        index = getIndex() + 1;\n        var historyState = getHistoryState(location, index);\n        var url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        }\n        catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action: action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        var location = createLocation(history.location, to, state);\n        if (validateLocation)\n            validateLocation(location, to);\n        index = getIndex();\n        var historyState = getHistoryState(location, index);\n        var url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action: action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        var base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n        var href = typeof to === \"string\" ? to : createPath(to);\n        invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    var history = {\n        get action() {\n            return action;\n        },\n        get location() {\n            return getLocation(window, globalHistory);\n        },\n        listen: function (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return function () {\n                window.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref: function (to) {\n            return createHref(window, to);\n        },\n        createURL: createURL,\n        encodeLocation: function (to) {\n            // Encode a Location the same way window.location would\n            var url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push: push,\n        replace: replace,\n        go: function (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar ResultType;\n(function (ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nvar immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (manifest === void 0) {\n        manifest = {};\n    }\n    return routes.map(function (route, index) {\n        var treePath = __spreadArray(__spreadArray([], parentPath, true), [index], false);\n        var id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n        if (isIndexRoute(route)) {\n            var indexRoute = _extends({}, route, mapRouteProperties(route), {\n                id: id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        }\n        else {\n            var pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n                id: id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\nexports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    var location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    var pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    var branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    var matches = null;\n    for (var i = 0; matches == null && i < branches.length; ++i) {\n        matches = matchRouteBranch(branches[i], \n        // Incoming pathnames are generally encoded from either window.location\n        // or from router.navigate, but we want to match against the unencoded\n        // paths in the route definitions.  Memory router locations won't be\n        // encoded here but there also shouldn't be anything to decode so this\n        // should be a safe operation.  This avoids needing matchRoutes to be\n        // history-aware.\n        safelyDecodeURI(pathname));\n    }\n    return matches;\n}\nexports.matchRoutes = matchRoutes;\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    var route = match.route, pathname = match.pathname, params = match.params;\n    return {\n        id: route.id,\n        pathname: pathname,\n        params: params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nexports.UNSAFE_convertRouteMatchToUiMatch = convertRouteMatchToUiMatch;\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    var flattenRoute = function (route, index, relativePath) {\n        var meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route: route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        var path = joinPaths([parentPath, meta.relativePath]);\n        var routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array, so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(\n            // Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path: path,\n            score: computeScore(path, route.index),\n            routesMeta: routesMeta\n        });\n    };\n    routes.forEach(function (route, index) {\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n            flattenRoute(route, index);\n        }\n        else {\n            for (var _i = 0, _a = explodeOptionalSegments(route.path); _i < _a.length; _i++) {\n                var exploded = _a[_i];\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n    var segments = path.split(\"/\");\n    if (segments.length === 0)\n        return [];\n    var first = segments[0], rest = segments.slice(1);\n    // Optional path segments are denoted by a trailing `?`\n    var isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    var required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        // Intepret empty string as omitting an optional segment\n        // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n        return isOptional ? [required, \"\"] : [required];\n    }\n    var restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    var result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children, so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explode _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push.apply(result, restExploded.map(function (subpath) { return subpath === \"\" ? required : [required, subpath].join(\"/\"); }));\n    // Then, if this is an optional value, add all child versions without\n    if (isOptional) {\n        result.push.apply(result, restExploded);\n    }\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map(function (exploded) { return path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded; });\n}\nfunction rankRouteBranches(branches) {\n    branches.sort(function (a, b) { return a.score !== b.score ? b.score - a.score // Higher score first\n        : compareIndexes(a.routesMeta.map(function (meta) { return meta.childrenIndex; }), b.routesMeta.map(function (meta) { return meta.childrenIndex; })); });\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = function (s) { return s === \"*\"; };\nfunction computeScore(path, index) {\n    var segments = path.split(\"/\");\n    var initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter(function (s) { return !isSplat(s); }).reduce(function (score, segment) { return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue); }, initialScore);\n}\nfunction compareIndexes(a, b) {\n    var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) { return n === b[i]; });\n    return siblings ?\n        // If two routes are siblings, we should try to match the earlier sibling\n        // first. This allows people to have fine-grained control over the matching\n        // behavior by simply putting routes with identical paths in the order they\n        // want them tried.\n        a[a.length - 1] - b[b.length - 1] :\n        // Otherwise, it doesn't really make sense to rank non-siblings by index,\n        // so they sort equally.\n        0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    var routesMeta = branch.routesMeta;\n    var matchedParams = {};\n    var matchedPathname = \"/\";\n    var matches = [];\n    for (var i = 0; i < routesMeta.length; ++i) {\n        var meta = routesMeta[i];\n        var end = i === routesMeta.length - 1;\n        var remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        var match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end: end\n        }, remainingPathname);\n        if (!match)\n            return null;\n        Object.assign(matchedParams, match.params);\n        var route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([matchedPathname, match.pathname]),\n            pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n            route: route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    var path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    var prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    var stringify = function (p) { return p == null ? \"\" : typeof p === \"string\" ? p : String(p); };\n    var segments = path.split(/\\/+/).map(function (segment, index, array) {\n        var isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            var star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        var keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            var key = keyMatch[1], optional = keyMatch[2];\n            var param = params[key];\n            invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })\n        // Remove empty segments\n        .filter(function (segment) { return !!segment; });\n    return prefix + segments.join(\"/\");\n}\nexports.generatePath = generatePath;\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    var _a = compilePath(pattern.path, pattern.caseSensitive, pattern.end), matcher = _a[0], compiledParams = _a[1];\n    var match = pathname.match(matcher);\n    if (!match)\n        return null;\n    var matchedPathname = match[0];\n    var pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    var captureGroups = match.slice(1);\n    var params = compiledParams.reduce(function (memo, _ref, index) {\n        var paramName = _ref.paramName, isOptional = _ref.isOptional;\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            var splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        var value = captureGroups[index];\n        if (isOptional && !value) {\n            memo[paramName] = undefined;\n        }\n        else {\n            memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n        }\n        return memo;\n    }, {});\n    return {\n        params: params,\n        pathname: matchedPathname,\n        pathnameBase: pathnameBase,\n        pattern: pattern\n    };\n}\nexports.matchPath = matchPath;\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    var params = [];\n    var regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n        .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n        .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n        .replace(/\\/:([\\w-]+)(\\?)?/g, function (_, paramName, isOptional) {\n        params.push({\n            paramName: paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n            : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    }\n    else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    }\n    else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex, so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    }\n    else\n        ;\n    var matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n    try {\n        return decodeURI(value);\n    }\n    catch (error) {\n        warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    }\n    catch (error) {\n        warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n    if (basename === \"/\")\n        return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    var startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    var nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\nexports.stripBasename = stripBasename;\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    var _a = typeof to === \"string\" ? parsePath(to) : to, toPathname = _a.pathname, _b = _a.search, search = _b === void 0 ? \"\" : _b, _c = _a.hash, hash = _c === void 0 ? \"\" : _c;\n    var pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname: pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nexports.resolvePath = resolvePath;\nfunction resolvePathname(relativePath, fromPathname) {\n    var segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    var relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach(function (segment) {\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1)\n                segments.pop();\n        }\n        else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n    return matches.filter(function (match, index) { return index === 0 || match.route.path && match.route.path.length > 0; });\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n    var pathMatches = getPathContributingMatches(matches);\n    // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n    // match so we include splat values for \".\" links.  See:\n    // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n    if (v7_relativeSplatPath) {\n        return pathMatches.map(function (match, idx) { return idx === matches.length - 1 ? match.pathname : match.pathnameBase; });\n    }\n    return pathMatches.map(function (match) { return match.pathnameBase; });\n}\nexports.UNSAFE_getResolveToMatches = getResolveToMatches;\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    var to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    }\n    else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    var isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    var toPathname = isEmptyPath ? \"/\" : to.pathname;\n    var from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (toPathname == null) {\n        from = locationPathname;\n    }\n    else {\n        var routePathnameIndex = routePathnames.length - 1;\n        // With relative=\"route\" (the default), each leading .. segment means\n        // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n        // difference from how <a href> works and a major reason we call this a\n        // \"to\" value instead of a \"href\".\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            var toSegments = toPathname.split(\"/\");\n            while (toSegments[0] === \"..\") {\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    var path = resolvePath(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    var hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    var hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\nexports.resolveTo = resolveTo;\n/**\n * @private\n */\nfunction getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\nexports.getToPathname = getToPathname;\n/**\n * @private\n */\nvar joinPaths = function (paths) { return paths.join(\"/\").replace(/\\/\\/+/g, \"/\"); };\nexports.joinPaths = joinPaths;\n/**\n * @private\n */\nvar normalizePathname = function (pathname) { return pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\"); };\nexports.normalizePathname = normalizePathname;\n/**\n * @private\n */\nvar normalizeSearch = function (search) { return !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search; };\n/**\n * @private\n */\nvar normalizeHash = function (hash) { return !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash; };\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nvar json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    var responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    var headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers: headers\n    }));\n};\nexports.json = json;\nvar AbortedDeferredError = /** @class */ (function (_super) {\n    __extends(AbortedDeferredError, _super);\n    function AbortedDeferredError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return AbortedDeferredError;\n}(Error));\nexports.AbortedDeferredError = AbortedDeferredError;\nvar DeferredData = /** @class */ (function () {\n    function DeferredData(data, responseInit) {\n        var _this = this;\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        var reject;\n        this.abortPromise = new Promise(function (_, r) { return reject = r; });\n        this.controller = new AbortController();\n        var onAbort = function () { return reject(new AbortedDeferredError(\"Deferred data aborted\")); };\n        this.unlistenAbortSignal = function () { return _this.controller.signal.removeEventListener(\"abort\", onAbort); };\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce(function (acc, _ref2) {\n            var _a;\n            var key = _ref2[0], value = _ref2[1];\n            return Object.assign(acc, (_a = {},\n                _a[key] = _this.trackPromise(key, value),\n                _a));\n        }, {});\n        if (this.done) {\n            // All incoming values were resolved\n            this.unlistenAbortSignal();\n        }\n        this.init = responseInit;\n    }\n    DeferredData.prototype.trackPromise = function (key, value) {\n        var _this = this;\n        if (!(value instanceof Promise)) {\n            return value;\n        }\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        var promise = Promise.race([value, this.abortPromise]).then(function (data) { return _this.onSettle(promise, key, undefined, data); }, function (error) { return _this.onSettle(promise, key, error); });\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(function () { });\n        Object.defineProperty(promise, \"_tracked\", {\n            get: function () { return true; }\n        });\n        return promise;\n    };\n    DeferredData.prototype.onSettle = function (promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: function () { return error; }\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) {\n            // Nothing left to abort!\n            this.unlistenAbortSignal();\n        }\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            var undefinedError_1 = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: function () { return undefinedError_1; }\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError_1);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: function () { return error; }\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: function () { return data; }\n        });\n        this.emit(false, key);\n        return data;\n    };\n    DeferredData.prototype.emit = function (aborted, settledKey) {\n        this.subscribers.forEach(function (subscriber) { return subscriber(aborted, settledKey); });\n    };\n    DeferredData.prototype.subscribe = function (fn) {\n        var _this = this;\n        this.subscribers.add(fn);\n        return function () { return _this.subscribers.delete(fn); };\n    };\n    DeferredData.prototype.cancel = function () {\n        var _this = this;\n        this.controller.abort();\n        this.pendingKeysSet.forEach(function (v, k) { return _this.pendingKeysSet.delete(k); });\n        this.emit(true);\n    };\n    DeferredData.prototype.resolveData = function (signal) {\n        return __awaiter(this, void 0, void 0, function () {\n            var aborted, onAbort_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        aborted = false;\n                        if (!!this.done) return [3 /*break*/, 2];\n                        onAbort_1 = function () { return _this.cancel(); };\n                        signal.addEventListener(\"abort\", onAbort_1);\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                _this.subscribe(function (aborted) {\n                                    signal.removeEventListener(\"abort\", onAbort_1);\n                                    if (aborted || _this.done) {\n                                        resolve(aborted);\n                                    }\n                                });\n                            })];\n                    case 1:\n                        aborted = _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, aborted];\n                }\n            });\n        });\n    };\n    Object.defineProperty(DeferredData.prototype, \"done\", {\n        get: function () {\n            return this.pendingKeysSet.size === 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DeferredData.prototype, \"unwrappedData\", {\n        get: function () {\n            invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n            return Object.entries(this.data).reduce(function (acc, _ref3) {\n                var _a;\n                var key = _ref3[0], value = _ref3[1];\n                return Object.assign(acc, (_a = {},\n                    _a[key] = unwrapTrackedPromise(value),\n                    _a));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DeferredData.prototype, \"pendingKeys\", {\n        get: function () {\n            return Array.from(this.pendingKeysSet);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return DeferredData;\n}());\nexports.UNSAFE_DeferredData = DeferredData;\nfunction isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nvar defer = function defer(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    var responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new DeferredData(data, responseInit);\n};\nexports.defer = defer;\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nvar redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    var responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    }\n    else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    var headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers: headers\n    }));\n};\nexports.redirect = redirect;\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nvar redirectDocument = function (url, init) {\n    var response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\nexports.redirectDocument = redirectDocument;\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nvar ErrorResponseImpl = /** @class */ (function () {\n    function ErrorResponseImpl(status, statusText, data, internal) {\n        if (internal === void 0) {\n            internal = false;\n        }\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        }\n        else {\n            this.data = data;\n        }\n    }\n    return ErrorResponseImpl;\n}());\nexports.UNSAFE_ErrorResponseImpl = ErrorResponseImpl;\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nexports.isRouteErrorResponse = isRouteErrorResponse;\nvar validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = __spreadArray([\"get\"], validMutationMethodsArr, true);\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nexports.IDLE_NAVIGATION = IDLE_NAVIGATION;\nvar IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nexports.IDLE_FETCHER = IDLE_FETCHER;\nvar IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nexports.IDLE_BLOCKER = IDLE_BLOCKER;\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = function (route) { return ({\n    hasErrorBoundary: Boolean(route.hasErrorBoundary)\n}); };\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n    var _a;\n    var routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n    var isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    var isServer = !isBrowser;\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    var mapRouteProperties;\n    if (init.mapRouteProperties) {\n        mapRouteProperties = init.mapRouteProperties;\n    }\n    else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        var detectErrorBoundary_1 = init.detectErrorBoundary;\n        mapRouteProperties = function (route) { return ({\n            hasErrorBoundary: detectErrorBoundary_1(route)\n        }); };\n    }\n    else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Routes keyed by ID\n    var manifest = {};\n    // Routes in tree format for matching\n    var dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n    var inFlightDataRoutes;\n    var basename = init.basename || \"/\";\n    // Config driven behavior flags\n    var future = _extends({\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: false,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: false\n    }, init.future);\n    // Cleanup function for history\n    var unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    var subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    var savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    var getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    var getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    var initialScrollRestored = init.hydrationData != null;\n    var initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    var initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        var error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        var _b = getShortCircuitMatches(dataRoutes), matches = _b.matches, route = _b.route;\n        initialMatches = matches;\n        initialErrors = (_a = {},\n            _a[route.id] = error,\n            _a);\n    }\n    var initialized;\n    var hasLazyRoutes = initialMatches.some(function (m) { return m.route.lazy; });\n    var hasLoaders = initialMatches.some(function (m) { return m.route.loader; });\n    if (hasLazyRoutes) {\n        // All initialMatches need to be loaded before we're ready.  If we have lazy\n        // functions around still then we'll need to run them in initialize()\n        initialized = false;\n    }\n    else if (!hasLoaders) {\n        // If we've got no loaders to run, then we're good to go\n        initialized = true;\n    }\n    else if (future.v7_partialHydration) {\n        // If partial hydration is enabled, we're initialized so long as we were\n        // provided with hydrationData for every route with a loader, and no loaders\n        // were marked for explicit hydration\n        var loaderData_1 = init.hydrationData ? init.hydrationData.loaderData : null;\n        var errors_1 = init.hydrationData ? init.hydrationData.errors : null;\n        initialized = initialMatches.every(function (m) { return m.route.loader && m.route.loader.hydrate !== true && (loaderData_1 && loaderData_1[m.route.id] !== undefined || errors_1 && errors_1[m.route.id] !== undefined); });\n    }\n    else {\n        // Without partial hydration - we're initialized if we were provided any\n        // hydrationData - which is expected to be complete\n        initialized = init.hydrationData != null;\n    }\n    var router;\n    var state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized: initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    var pendingAction = Action.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    var pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    var pendingNavigationController;\n    // Should the current navigation enable document.startViewTransition?\n    var pendingViewTransitionEnabled = false;\n    // Store applied view transitions so we can apply them on POP\n    var appliedViewTransitions = new Map();\n    // Cleanup function for persisting applied transitions to sessionStorage\n    var removePageHideEventListener = null;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    var isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    var isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    var cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    var cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    var fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    var incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    var pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    var fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    var fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    var fetchLoadMatches = new Map();\n    // Ref-count mounted fetchers so we know when it's ok to clean them up\n    var activeFetchers = new Map();\n    // Fetchers that have requested a delete when using v7_fetcherPersist,\n    // they'll be officially removed after they return to idle\n    var deletedFetchers = new Set();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    var activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    var blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    var ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen(function (_ref) {\n            var historyAction = _ref.action, location = _ref.location, delta = _ref.delta;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n            var blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction: historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location: location,\n                    proceed: function () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location: location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset: function () {\n                        var blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers: blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser) {\n            // FIXME: This feels gross.  How can we cleanup the lines between\n            // scrollRestoration/appliedTransitions persistance?\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            var _saveAppliedTransitions_1 = function () { return persistAppliedTransitions(routerWindow, appliedViewTransitions); };\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions_1);\n            removePageHideEventListener = function () { return routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions_1); };\n        }\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach(function (_, key) { return deleteFetcher(key); });\n        state.blockers.forEach(function (_, key) { return deleteBlocker(key); });\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return function () { return subscribers.delete(fn); };\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state = _extends({}, state, newState);\n        // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n        // can be removed\n        var completedFetchers = [];\n        var deletedFetchersKeys = [];\n        if (future.v7_fetcherPersist) {\n            state.fetchers.forEach(function (fetcher, key) {\n                if (fetcher.state === \"idle\") {\n                    if (deletedFetchers.has(key)) {\n                        // Unmounted from the UI and can be totally removed\n                        deletedFetchersKeys.push(key);\n                    }\n                    else {\n                        // Returned to idle but still mounted in the UI, so semi-remains for\n                        // revalidations and such\n                        completedFetchers.push(key);\n                    }\n                }\n            });\n        }\n        // Iterate over a local copy so that if flushSync is used and we end up\n        // removing and adding a new subscriber due to the useCallback dependencies,\n        // we don't get ourselves into a loop calling the new subscriber immediately\n        __spreadArray([], subscribers, true).forEach(function (subscriber) { return subscriber(state, {\n            deletedFetchers: deletedFetchersKeys,\n            unstable_viewTransitionOpts: opts.viewTransitionOpts,\n            unstable_flushSync: opts.flushSync === true\n        }); });\n        // Remove idle fetchers from state since we only care about in-flight fetchers.\n        if (future.v7_fetcherPersist) {\n            completedFetchers.forEach(function (key) { return state.fetchers.delete(key); });\n            deletedFetchersKeys.forEach(function (key) { return deleteFetcher(key); });\n        }\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState, _temp) {\n        var _location$state, _location$state2;\n        var flushSync = (_temp === void 0 ? {} : _temp).flushSync;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        var isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        var actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            }\n            else {\n                // Empty actionData -> clear prior actionData due to an action error\n                actionData = null;\n            }\n        }\n        else if (isActionReload) {\n            // Keep the current data if we're wrapping up the action reload\n            actionData = state.actionData;\n        }\n        else {\n            // Clear actionData on any other completed navigations\n            actionData = null;\n        }\n        // Always preserve any existing loaderData from re-used routes\n        var loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        var blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach(function (_, k) { return blockers.set(k, IDLE_BLOCKER); });\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        var preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation)\n            ;\n        else if (pendingAction === Action.Pop)\n            ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        }\n        else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        }\n        var viewTransitionOpts;\n        // On POP, enable transitions if they were enabled on the original navigation\n        if (pendingAction === Action.Pop) {\n            // Forward takes precedence so they behave like the original navigation\n            var priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            }\n            else if (appliedViewTransitions.has(location.pathname)) {\n                // If we don't have a previous forward nav, assume we're popping back to\n                // the new location and enable if that location previously enabled\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        }\n        else if (pendingViewTransitionEnabled) {\n            // Store the applied transition on PUSH/REPLACE\n            var toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            }\n            else {\n                toPaths = new Set([location.pathname]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState(_extends({}, newState, {\n            actionData: actionData,\n            loaderData: loaderData,\n            historyAction: pendingAction,\n            location: location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset: preventScrollReset,\n            blockers: blockers\n        }), {\n            viewTransitionOpts: viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    function navigate(to, opts) {\n        return __awaiter(this, void 0, void 0, function () {\n            var normalizedPath, _a, path, submission, error, currentLocation, nextLocation, userReplace, historyAction, preventScrollReset, flushSync, blockerKey;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (typeof to === \"number\") {\n                            init.history.go(to);\n                            return [2 /*return*/];\n                        }\n                        normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n                        _a = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts), path = _a.path, submission = _a.submission, error = _a.error;\n                        currentLocation = state.location;\n                        nextLocation = createLocation(state.location, path, opts && opts.state);\n                        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n                        // URL from window.location, so we need to encode it here so the behavior\n                        // remains the same as POP and non-data-router usages.  new URL() does all\n                        // the same encoding we'd get from a history.pushState/window.location read\n                        // without having to touch history\n                        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n                        userReplace = opts && opts.replace != null ? opts.replace : undefined;\n                        historyAction = Action.Push;\n                        if (userReplace === true) {\n                            historyAction = Action.Replace;\n                        }\n                        else if (userReplace === false)\n                            ;\n                        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n                            // By default on submissions to the current location we REPLACE so that\n                            // users don't have to double-click the back button to get to the prior\n                            // location.  If the user redirects to a different location from the\n                            // action/loader this will be ignored and the redirect will be a PUSH\n                            historyAction = Action.Replace;\n                        }\n                        preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n                        flushSync = (opts && opts.unstable_flushSync) === true;\n                        blockerKey = shouldBlockNavigation({\n                            currentLocation: currentLocation,\n                            nextLocation: nextLocation,\n                            historyAction: historyAction\n                        });\n                        if (blockerKey) {\n                            // Put the blocker into a blocked state\n                            updateBlocker(blockerKey, {\n                                state: \"blocked\",\n                                location: nextLocation,\n                                proceed: function () {\n                                    updateBlocker(blockerKey, {\n                                        state: \"proceeding\",\n                                        proceed: undefined,\n                                        reset: undefined,\n                                        location: nextLocation\n                                    });\n                                    // Send the same navigation through\n                                    navigate(to, opts);\n                                },\n                                reset: function () {\n                                    var blockers = new Map(state.blockers);\n                                    blockers.set(blockerKey, IDLE_BLOCKER);\n                                    updateState({\n                                        blockers: blockers\n                                    });\n                                }\n                            });\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, startNavigation(historyAction, nextLocation, {\n                                submission: submission,\n                                // Send through the formData serialization error if we have one so we can\n                                // render at the right error boundary after we match routes\n                                pendingError: error,\n                                preventScrollReset: preventScrollReset,\n                                replace: opts && opts.replace,\n                                enableViewTransition: opts && opts.unstable_viewTransition,\n                                flushSync: flushSync\n                            })];\n                    case 1: return [2 /*return*/, _b.sent()];\n                }\n            });\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        }\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    function startNavigation(historyAction, location, opts) {\n        return __awaiter(this, void 0, void 0, function () {\n            var routesToUse, loadingNavigation, matches, flushSync, error, _a, notFoundMatches, route, request, pendingActionData, pendingError, actionOutput, _b, shortCircuited, loaderData, errors;\n            var _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        // Abort any in-progress navigations and start a new one. Unset any ongoing\n                        // uninterrupted revalidations unless told otherwise, since we want this\n                        // new navigation to update history normally\n                        pendingNavigationController && pendingNavigationController.abort();\n                        pendingNavigationController = null;\n                        pendingAction = historyAction;\n                        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n                        // Save the current scroll position every time we start a new navigation,\n                        // and track whether we should reset scroll on completion\n                        saveScrollPosition(state.location, state.matches);\n                        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n                        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n                        routesToUse = inFlightDataRoutes || dataRoutes;\n                        loadingNavigation = opts && opts.overrideNavigation;\n                        matches = matchRoutes(routesToUse, location, basename);\n                        flushSync = (opts && opts.flushSync) === true;\n                        // Short circuit with a 404 on the root error boundary if we match nothing\n                        if (!matches) {\n                            error = getInternalRouterError(404, {\n                                pathname: location.pathname\n                            });\n                            _a = getShortCircuitMatches(routesToUse), notFoundMatches = _a.matches, route = _a.route;\n                            // Cancel all pending deferred on 404s since we don't keep any routes\n                            cancelActiveDeferreds();\n                            completeNavigation(location, {\n                                matches: notFoundMatches,\n                                loaderData: {},\n                                errors: (_c = {},\n                                    _c[route.id] = error,\n                                    _c)\n                            }, {\n                                flushSync: flushSync\n                            });\n                            return [2 /*return*/];\n                        }\n                        // Short circuit if it's only a hash change and not a revalidation or\n                        // mutation submission.\n                        //\n                        // Ignore on initial page loads because since the initial load will always\n                        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n                        // which will default to a navigation to /page\n                        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n                            completeNavigation(location, {\n                                matches: matches\n                            }, {\n                                flushSync: flushSync\n                            });\n                            return [2 /*return*/];\n                        }\n                        // Create a controller/Request for this navigation\n                        pendingNavigationController = new AbortController();\n                        request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n                        if (!(opts && opts.pendingError)) return [3 /*break*/, 1];\n                        // If we have a pendingError, it means the user attempted a GET submission\n                        // with binary FormData so assign here and skip to handleLoaders.  That\n                        // way we handle calling loaders above the boundary etc.  It's not really\n                        // different from an actionError in that sense.\n                        pendingError = (_d = {},\n                            _d[findNearestBoundary(matches).route.id] = opts.pendingError,\n                            _d);\n                        return [3 /*break*/, 3];\n                    case 1:\n                        if (!(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) return [3 /*break*/, 3];\n                        return [4 /*yield*/, handleAction(request, location, opts.submission, matches, {\n                                replace: opts.replace,\n                                flushSync: flushSync\n                            })];\n                    case 2:\n                        actionOutput = _e.sent();\n                        if (actionOutput.shortCircuited) {\n                            return [2 /*return*/];\n                        }\n                        pendingActionData = actionOutput.pendingActionData;\n                        pendingError = actionOutput.pendingActionError;\n                        loadingNavigation = getLoadingNavigation(location, opts.submission);\n                        flushSync = false;\n                        // Create a GET request for the loaders\n                        request = new Request(request.url, {\n                            signal: request.signal\n                        });\n                        _e.label = 3;\n                    case 3: return [4 /*yield*/, handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError)];\n                    case 4:\n                        _b = _e.sent(), shortCircuited = _b.shortCircuited, loaderData = _b.loaderData, errors = _b.errors;\n                        if (shortCircuited) {\n                            return [2 /*return*/];\n                        }\n                        // Clean up now that the action/loaders have completed.  Don't clean up if\n                        // we short circuited because pendingNavigationController will have already\n                        // been assigned to a new controller for the next navigation\n                        pendingNavigationController = null;\n                        completeNavigation(location, _extends({\n                            matches: matches\n                        }, pendingActionData ? {\n                            actionData: pendingActionData\n                        } : {}, {\n                            loaderData: loaderData,\n                            errors: errors\n                        }));\n                        return [2 /*return*/];\n                }\n            });\n        });\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    function handleAction(request, location, submission, matches, opts) {\n        return __awaiter(this, void 0, void 0, function () {\n            var navigation, result, actionMatch, replace, boundaryMatch;\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (opts === void 0) {\n                            opts = {};\n                        }\n                        interruptActiveLoads();\n                        navigation = getSubmittingNavigation(location, submission);\n                        updateState({\n                            navigation: navigation\n                        }, {\n                            flushSync: opts.flushSync === true\n                        });\n                        actionMatch = getTargetMatch(matches, location);\n                        if (!(!actionMatch.route.action && !actionMatch.route.lazy)) return [3 /*break*/, 1];\n                        result = {\n                            type: ResultType.error,\n                            error: getInternalRouterError(405, {\n                                method: request.method,\n                                pathname: location.pathname,\n                                routeId: actionMatch.route.id\n                            })\n                        };\n                        return [3 /*break*/, 3];\n                    case 1: return [4 /*yield*/, callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)];\n                    case 2:\n                        result = _c.sent();\n                        if (request.signal.aborted) {\n                            return [2 /*return*/, {\n                                    shortCircuited: true\n                                }];\n                        }\n                        _c.label = 3;\n                    case 3:\n                        if (!isRedirectResult(result)) return [3 /*break*/, 5];\n                        replace = void 0;\n                        if (opts && opts.replace != null) {\n                            replace = opts.replace;\n                        }\n                        else {\n                            // If the user didn't explicity indicate replace behavior, replace if\n                            // we redirected to the exact same location we're currently at to avoid\n                            // double back-buttons\n                            replace = result.location === state.location.pathname + state.location.search;\n                        }\n                        return [4 /*yield*/, startRedirectNavigation(state, result, {\n                                submission: submission,\n                                replace: replace\n                            })];\n                    case 4:\n                        _c.sent();\n                        return [2 /*return*/, {\n                                shortCircuited: true\n                            }];\n                    case 5:\n                        if (isErrorResult(result)) {\n                            boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n                            // By default, all submissions are REPLACE navigations, but if the\n                            // action threw an error that'll be rendered in an errorElement, we fall\n                            // back to PUSH so that the user can use the back button to get back to\n                            // the pre-submission form location to try again\n                            if ((opts && opts.replace) !== true) {\n                                pendingAction = Action.Push;\n                            }\n                            return [2 /*return*/, {\n                                    // Send back an empty object we can use to clear out any prior actionData\n                                    pendingActionData: {},\n                                    pendingActionError: (_a = {},\n                                        _a[boundaryMatch.route.id] = result.error,\n                                        _a)\n                                }];\n                        }\n                        if (isDeferredResult(result)) {\n                            throw getInternalRouterError(400, {\n                                type: \"defer-action\"\n                            });\n                        }\n                        return [2 /*return*/, {\n                                pendingActionData: (_b = {},\n                                    _b[actionMatch.route.id] = result.data,\n                                    _b)\n                            }];\n                }\n            });\n        });\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n        return __awaiter(this, void 0, void 0, function () {\n            var loadingNavigation, activeSubmission, routesToUse, _a, matchesToLoad, revalidatingFetchers, updatedFetchers_1, actionData, abortPendingFetchRevalidations, _b, results, loaderResults, fetcherResults, redirect, fetcherKey, _c, loaderData, errors, updatedFetchers, didAbortFetchLoads, shouldUpdateFetchers;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n                        activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n                        routesToUse = inFlightDataRoutes || dataRoutes;\n                        _a = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError), matchesToLoad = _a[0], revalidatingFetchers = _a[1];\n                        // Cancel pending deferreds for no-longer-matched routes or routes we're\n                        // about to reload.  Note that if this is an action reload we would have\n                        // already cancelled all pending deferreds so this would be a no-op\n                        cancelActiveDeferreds(function (routeId) { return !(matches && matches.some(function (m) { return m.route.id === routeId; })) || matchesToLoad && matchesToLoad.some(function (m) { return m.route.id === routeId; }); });\n                        pendingNavigationLoadId = ++incrementingLoadId;\n                        // Short circuit if we have no loaders to run\n                        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n                            updatedFetchers_1 = markFetchRedirectsDone();\n                            completeNavigation(location, _extends({\n                                matches: matches,\n                                loaderData: {},\n                                // Commit pending error if we're short circuiting\n                                errors: pendingError || null\n                            }, pendingActionData ? {\n                                actionData: pendingActionData\n                            } : {}, updatedFetchers_1 ? {\n                                fetchers: new Map(state.fetchers)\n                            } : {}), {\n                                flushSync: flushSync\n                            });\n                            return [2 /*return*/, {\n                                    shortCircuited: true\n                                }];\n                        }\n                        // If this is an uninterrupted revalidation, we remain in our current idle\n                        // state.  If not, we need to switch to our loading state and load data,\n                        // preserving any new action data or existing action data (in the case of\n                        // a revalidation interrupting an actionReload)\n                        // If we have partialHydration enabled, then don't update the state for the\n                        // initial data load since iot's not a \"navigation\"\n                        if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n                            revalidatingFetchers.forEach(function (rf) {\n                                var fetcher = state.fetchers.get(rf.key);\n                                var revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                                state.fetchers.set(rf.key, revalidatingFetcher);\n                            });\n                            actionData = pendingActionData || state.actionData;\n                            updateState(_extends({\n                                navigation: loadingNavigation\n                            }, actionData ? Object.keys(actionData).length === 0 ? {\n                                actionData: null\n                            } : {\n                                actionData: actionData\n                            } : {}, revalidatingFetchers.length > 0 ? {\n                                fetchers: new Map(state.fetchers)\n                            } : {}), {\n                                flushSync: flushSync\n                            });\n                        }\n                        revalidatingFetchers.forEach(function (rf) {\n                            if (fetchControllers.has(rf.key)) {\n                                abortFetcher(rf.key);\n                            }\n                            if (rf.controller) {\n                                // Fetchers use an independent AbortController so that aborting a fetcher\n                                // (via deleteFetcher) does not abort the triggering navigation that\n                                // triggered the revalidation\n                                fetchControllers.set(rf.key, rf.controller);\n                            }\n                        });\n                        abortPendingFetchRevalidations = function () { return revalidatingFetchers.forEach(function (f) { return abortFetcher(f.key); }); };\n                        if (pendingNavigationController) {\n                            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n                        }\n                        return [4 /*yield*/, callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request)];\n                    case 1:\n                        _b = _d.sent(), results = _b.results, loaderResults = _b.loaderResults, fetcherResults = _b.fetcherResults;\n                        if (request.signal.aborted) {\n                            return [2 /*return*/, {\n                                    shortCircuited: true\n                                }];\n                        }\n                        // Clean up _after_ loaders have completed.  Don't clean up if we short\n                        // circuited because fetchControllers would have been aborted and\n                        // reassigned to new controllers for the next navigation\n                        if (pendingNavigationController) {\n                            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n                        }\n                        revalidatingFetchers.forEach(function (rf) { return fetchControllers.delete(rf.key); });\n                        redirect = findRedirect(results);\n                        if (!redirect) return [3 /*break*/, 3];\n                        if (redirect.idx >= matchesToLoad.length) {\n                            fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                            fetchRedirectIds.add(fetcherKey);\n                        }\n                        return [4 /*yield*/, startRedirectNavigation(state, redirect.result, {\n                                replace: replace\n                            })];\n                    case 2:\n                        _d.sent();\n                        return [2 /*return*/, {\n                                shortCircuited: true\n                            }];\n                    case 3:\n                        _c = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds), loaderData = _c.loaderData, errors = _c.errors;\n                        // Wire up subscribers to update loaderData as promises settle\n                        activeDeferreds.forEach(function (deferredData, routeId) {\n                            deferredData.subscribe(function (aborted) {\n                                // Note: No need to updateState here since the TrackedPromise on\n                                // loaderData is stable across resolve/reject\n                                // Remove this instance if we were aborted or if promises have settled\n                                if (aborted || deferredData.done) {\n                                    activeDeferreds.delete(routeId);\n                                }\n                            });\n                        });\n                        updatedFetchers = markFetchRedirectsDone();\n                        didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n                        shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n                        return [2 /*return*/, _extends({\n                                loaderData: loaderData,\n                                errors: errors\n                            }, shouldUpdateFetchers ? {\n                                fetchers: new Map(state.fetchers)\n                            } : {})];\n                }\n            });\n        });\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key))\n            abortFetcher(key);\n        var flushSync = (opts && opts.unstable_flushSync) === true;\n        var routesToUse = inFlightDataRoutes || dataRoutes;\n        var normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n        var matches = matchRoutes(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync: flushSync\n            });\n            return;\n        }\n        var _a = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts), path = _a.path, submission = _a.submission, error = _a.error;\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync: flushSync\n            });\n            return;\n        }\n        var match = getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId: routeId,\n            path: path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error, existingFetcher, abortController, fetchRequest, originatingLoadId, actionResult, nextLocation, revalidationRequest, routesToUse, matches, loadId, loadFetcher, _a, matchesToLoad, revalidatingFetchers, abortPendingFetchRevalidations, _b, results, loaderResults, fetcherResults, redirect, fetcherKey, _c, loaderData, errors, doneFetcher;\n            var _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        interruptActiveLoads();\n                        fetchLoadMatches.delete(key);\n                        if (!match.route.action && !match.route.lazy) {\n                            error = getInternalRouterError(405, {\n                                method: submission.formMethod,\n                                pathname: path,\n                                routeId: routeId\n                            });\n                            setFetcherError(key, routeId, error, {\n                                flushSync: flushSync\n                            });\n                            return [2 /*return*/];\n                        }\n                        existingFetcher = state.fetchers.get(key);\n                        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n                            flushSync: flushSync\n                        });\n                        abortController = new AbortController();\n                        fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n                        fetchControllers.set(key, abortController);\n                        originatingLoadId = incrementingLoadId;\n                        return [4 /*yield*/, callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)];\n                    case 1:\n                        actionResult = _e.sent();\n                        if (fetchRequest.signal.aborted) {\n                            // We can delete this so long as we weren't aborted by our own fetcher\n                            // re-submit which would have put _new_ controller is in fetchControllers\n                            if (fetchControllers.get(key) === abortController) {\n                                fetchControllers.delete(key);\n                            }\n                            return [2 /*return*/];\n                        }\n                        // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n                        // or redirects processed for unmounted fetchers so we just revert them to\n                        // idle\n                        if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n                            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                                updateFetcherState(key, getDoneFetcher(undefined));\n                                return [2 /*return*/];\n                            }\n                            // Let SuccessResult's fall through for revalidation\n                        }\n                        else {\n                            if (isRedirectResult(actionResult)) {\n                                fetchControllers.delete(key);\n                                if (pendingNavigationLoadId > originatingLoadId) {\n                                    // A new navigation was kicked off after our action started, so that\n                                    // should take precedence over this redirect navigation.  We already\n                                    // set isRevalidationRequired so all loaders for the new route should\n                                    // fire unless opted out via shouldRevalidate\n                                    updateFetcherState(key, getDoneFetcher(undefined));\n                                    return [2 /*return*/];\n                                }\n                                else {\n                                    fetchRedirectIds.add(key);\n                                    updateFetcherState(key, getLoadingFetcher(submission));\n                                    return [2 /*return*/, startRedirectNavigation(state, actionResult, {\n                                            fetcherSubmission: submission\n                                        })];\n                                }\n                            }\n                            // Process any non-redirect errors thrown\n                            if (isErrorResult(actionResult)) {\n                                setFetcherError(key, routeId, actionResult.error);\n                                return [2 /*return*/];\n                            }\n                        }\n                        if (isDeferredResult(actionResult)) {\n                            throw getInternalRouterError(400, {\n                                type: \"defer-action\"\n                            });\n                        }\n                        nextLocation = state.navigation.location || state.location;\n                        revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n                        routesToUse = inFlightDataRoutes || dataRoutes;\n                        matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n                        invariant(matches, \"Didn't find any matches after fetcher action\");\n                        loadId = ++incrementingLoadId;\n                        fetchReloadIds.set(key, loadId);\n                        loadFetcher = getLoadingFetcher(submission, actionResult.data);\n                        state.fetchers.set(key, loadFetcher);\n                        _a = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, (_d = {},\n                            _d[match.route.id] = actionResult.data,\n                            _d), undefined // No need to send through errors since we short circuit above\n                        ), matchesToLoad = _a[0], revalidatingFetchers = _a[1];\n                        // Put all revalidating fetchers into the loading state, except for the\n                        // current fetcher which we want to keep in it's current loading state which\n                        // contains it's action submission info + action data\n                        revalidatingFetchers.filter(function (rf) { return rf.key !== key; }).forEach(function (rf) {\n                            var staleKey = rf.key;\n                            var existingFetcher = state.fetchers.get(staleKey);\n                            var revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n                            state.fetchers.set(staleKey, revalidatingFetcher);\n                            if (fetchControllers.has(staleKey)) {\n                                abortFetcher(staleKey);\n                            }\n                            if (rf.controller) {\n                                fetchControllers.set(staleKey, rf.controller);\n                            }\n                        });\n                        updateState({\n                            fetchers: new Map(state.fetchers)\n                        });\n                        abortPendingFetchRevalidations = function () { return revalidatingFetchers.forEach(function (rf) { return abortFetcher(rf.key); }); };\n                        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n                        return [4 /*yield*/, callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest)];\n                    case 2:\n                        _b = _e.sent(), results = _b.results, loaderResults = _b.loaderResults, fetcherResults = _b.fetcherResults;\n                        if (abortController.signal.aborted) {\n                            return [2 /*return*/];\n                        }\n                        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n                        fetchReloadIds.delete(key);\n                        fetchControllers.delete(key);\n                        revalidatingFetchers.forEach(function (r) { return fetchControllers.delete(r.key); });\n                        redirect = findRedirect(results);\n                        if (redirect) {\n                            if (redirect.idx >= matchesToLoad.length) {\n                                fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                                fetchRedirectIds.add(fetcherKey);\n                            }\n                            return [2 /*return*/, startRedirectNavigation(state, redirect.result)];\n                        }\n                        _c = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds), loaderData = _c.loaderData, errors = _c.errors;\n                        // Since we let revalidations complete even if the submitting fetcher was\n                        // deleted, only put it back to idle if it hasn't been deleted\n                        if (state.fetchers.has(key)) {\n                            doneFetcher = getDoneFetcher(actionResult.data);\n                            state.fetchers.set(key, doneFetcher);\n                        }\n                        abortStaleFetchLoads(loadId);\n                        // If we are currently in a navigation loading state and this fetcher is\n                        // more recent than the navigation, we want the newer data so abort the\n                        // navigation and complete it with the fetcher data\n                        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n                            invariant(pendingAction, \"Expected pending action\");\n                            pendingNavigationController && pendingNavigationController.abort();\n                            completeNavigation(state.navigation.location, {\n                                matches: matches,\n                                loaderData: loaderData,\n                                errors: errors,\n                                fetchers: new Map(state.fetchers)\n                            });\n                        }\n                        else {\n                            // otherwise just update with the fetcher data, preserving any existing\n                            // loaderData for loaders that did not need to reload.  We have to\n                            // manually merge here since we aren't going through completeNavigation\n                            updateState({\n                                errors: errors,\n                                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                                fetchers: new Map(state.fetchers)\n                            });\n                            isRevalidationRequired = false;\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n        return __awaiter(this, void 0, void 0, function () {\n            var existingFetcher, abortController, fetchRequest, originatingLoadId, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        existingFetcher = state.fetchers.get(key);\n                        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n                            flushSync: flushSync\n                        });\n                        abortController = new AbortController();\n                        fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n                        fetchControllers.set(key, abortController);\n                        originatingLoadId = incrementingLoadId;\n                        return [4 /*yield*/, callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)];\n                    case 1:\n                        result = _a.sent();\n                        if (!isDeferredResult(result)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, resolveDeferredData(result, fetchRequest.signal, true)];\n                    case 2:\n                        result = (_a.sent()) || result;\n                        _a.label = 3;\n                    case 3:\n                        // We can delete this so long as we weren't aborted by our our own fetcher\n                        // re-load which would have put _new_ controller is in fetchControllers\n                        if (fetchControllers.get(key) === abortController) {\n                            fetchControllers.delete(key);\n                        }\n                        if (fetchRequest.signal.aborted) {\n                            return [2 /*return*/];\n                        }\n                        // We don't want errors bubbling up or redirects followed for unmounted\n                        // fetchers, so short circuit here if it was removed from the UI\n                        if (deletedFetchers.has(key)) {\n                            updateFetcherState(key, getDoneFetcher(undefined));\n                            return [2 /*return*/];\n                        }\n                        if (!isRedirectResult(result)) return [3 /*break*/, 6];\n                        if (!(pendingNavigationLoadId > originatingLoadId)) return [3 /*break*/, 4];\n                        // A new navigation was kicked off after our loader started, so that\n                        // should take precedence over this redirect navigation\n                        updateFetcherState(key, getDoneFetcher(undefined));\n                        return [2 /*return*/];\n                    case 4:\n                        fetchRedirectIds.add(key);\n                        return [4 /*yield*/, startRedirectNavigation(state, result)];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/];\n                    case 6:\n                        // Process any non-redirect errors thrown\n                        if (isErrorResult(result)) {\n                            setFetcherError(key, routeId, result.error);\n                            return [2 /*return*/];\n                        }\n                        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n                        // Put the fetcher back into an idle state\n                        updateFetcherState(key, getDoneFetcher(result.data));\n                        return [2 /*return*/];\n                }\n            });\n        });\n    }\n    /**\n     * Utility function to handle redirects returned from an action or loader.\n     * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n     * example:\n     *\n     *  - user is on /a\n     *  - user clicks a link to /b\n     *  - loader for /b redirects to /c\n     *\n     * In a non-JS app the browser would track the in-flight navigation to /b and\n     * then replace it with /c when it encountered the redirect response.  In\n     * the end it would only ever update the URL bar with /c.\n     *\n     * In client-side routing using pushState/replaceState, we aim to emulate\n     * this behavior and we also do not update history until the end of the\n     * navigation (including processed redirects).  This means that we never\n     * actually touch history until we've processed redirects, so we just use\n     * the history action from the original navigation (PUSH or REPLACE).\n     */\n    function startRedirectNavigation(state, redirect, _temp2) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, submission, fetcherSubmission, replace, redirectLocation, isDocumentReload, url, redirectHistoryAction, _b, formMethod, formAction, formEncType, activeSubmission, overrideNavigation;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = _temp2 === void 0 ? {} : _temp2, submission = _a.submission, fetcherSubmission = _a.fetcherSubmission, replace = _a.replace;\n                        if (redirect.revalidate) {\n                            isRevalidationRequired = true;\n                        }\n                        redirectLocation = createLocation(state.location, redirect.location, {\n                            _isRedirect: true\n                        });\n                        invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n                        if (isBrowser) {\n                            isDocumentReload = false;\n                            if (redirect.reloadDocument) {\n                                // Hard reload if the response contained X-Remix-Reload-Document\n                                isDocumentReload = true;\n                            }\n                            else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n                                url = init.history.createURL(redirect.location);\n                                isDocumentReload =\n                                    // Hard reload if it's an absolute URL to a new origin\n                                    url.origin !== routerWindow.location.origin ||\n                                        // Hard reload if it's an absolute URL that does not match our basename\n                                        stripBasename(url.pathname, basename) == null;\n                            }\n                            if (isDocumentReload) {\n                                if (replace) {\n                                    routerWindow.location.replace(redirect.location);\n                                }\n                                else {\n                                    routerWindow.location.assign(redirect.location);\n                                }\n                                return [2 /*return*/];\n                            }\n                        }\n                        // There's no need to abort on redirects, since we don't detect the\n                        // redirect until the action/loaders have settled\n                        pendingNavigationController = null;\n                        redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n                        _b = state.navigation, formMethod = _b.formMethod, formAction = _b.formAction, formEncType = _b.formEncType;\n                        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n                            submission = getSubmissionFromNavigation(state.navigation);\n                        }\n                        activeSubmission = submission || fetcherSubmission;\n                        if (!(redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, startNavigation(redirectHistoryAction, redirectLocation, {\n                                submission: _extends({}, activeSubmission, {\n                                    formAction: redirect.location\n                                }),\n                                // Preserve this flag across redirects\n                                preventScrollReset: pendingPreventScrollReset\n                            })];\n                    case 1:\n                        _c.sent();\n                        return [3 /*break*/, 4];\n                    case 2:\n                        overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n                        return [4 /*yield*/, startNavigation(redirectHistoryAction, redirectLocation, {\n                                overrideNavigation: overrideNavigation,\n                                // Send fetcher submissions through for shouldRevalidate\n                                fetcherSubmission: fetcherSubmission,\n                                // Preserve this flag across redirects\n                                preventScrollReset: pendingPreventScrollReset\n                            })];\n                    case 3:\n                        _c.sent();\n                        _c.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    }\n    function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        return __awaiter(this, void 0, void 0, function () {\n            var results, loaderResults, fetcherResults;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all(__spreadArray(__spreadArray([], matchesToLoad.map(function (match) { return callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath); }), true), fetchersToLoad.map(function (f) {\n                            if (f.matches && f.match && f.controller) {\n                                return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n                            }\n                            else {\n                                var error = {\n                                    type: ResultType.error,\n                                    error: getInternalRouterError(404, {\n                                        pathname: f.path\n                                    })\n                                };\n                                return error;\n                            }\n                        }), true))];\n                    case 1:\n                        results = _a.sent();\n                        loaderResults = results.slice(0, matchesToLoad.length);\n                        fetcherResults = results.slice(matchesToLoad.length);\n                        return [4 /*yield*/, Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(function () { return request.signal; }), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(function (f) { return f.match; }), fetcherResults, fetchersToLoad.map(function (f) { return f.controller ? f.controller.signal : null; }), true)])];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, {\n                                results: results,\n                                loaderResults: loaderResults,\n                                fetcherResults: fetcherResults\n                            }];\n                }\n            });\n        });\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push.apply(cancelledDeferredRoutes, cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach(function (_, key) {\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function updateFetcherState(key, fetcher, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts) {\n        var _a;\n        if (opts === void 0) {\n            opts = {};\n        }\n        var boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: (_a = {},\n                _a[boundaryMatch.route.id] = error,\n                _a),\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        if (future.v7_fetcherPersist) {\n            activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n            // If this fetcher was previously marked for deletion, unmark it since we\n            // have a new instance\n            if (deletedFetchers.has(key)) {\n                deletedFetchers.delete(key);\n            }\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        var fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        deletedFetchers.delete(key);\n        state.fetchers.delete(key);\n    }\n    function deleteFetcherAndUpdateState(key) {\n        if (future.v7_fetcherPersist) {\n            var count = (activeFetchers.get(key) || 0) - 1;\n            if (count <= 0) {\n                activeFetchers.delete(key);\n                deletedFetchers.add(key);\n            }\n            else {\n                activeFetchers.set(key, count);\n            }\n        }\n        else {\n            deleteFetcher(key);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        var controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            var fetcher = getFetcher(key);\n            var doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        var doneKeys = [];\n        var updatedFetchers = false;\n        for (var _i = 0, fetchRedirectIds_1 = fetchRedirectIds; _i < fetchRedirectIds_1.length; _i++) {\n            var key = fetchRedirectIds_1[_i];\n            var fetcher = state.fetchers.get(key);\n            invariant(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        var yeetedKeys = [];\n        for (var _i = 0, fetchReloadIds_1 = fetchReloadIds; _i < fetchReloadIds_1.length; _i++) {\n            var _a = fetchReloadIds_1[_i], key = _a[0], id = _a[1];\n            if (id < landedId) {\n                var fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        var blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        var blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        var blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers: blockers\n        });\n    }\n    function shouldBlockNavigation(_ref2) {\n        var currentLocation = _ref2.currentLocation, nextLocation = _ref2.nextLocation, historyAction = _ref2.historyAction;\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        var entries = Array.from(blockerFunctions.entries());\n        var _a = entries[entries.length - 1], blockerKey = _a[0], blockerFunction = _a[1];\n        var blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            // If the blocker is currently proceeding, we don't need to re-check\n            // it and can let this navigation continue\n            return;\n        }\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation: currentLocation,\n            nextLocation: nextLocation,\n            historyAction: historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function cancelActiveDeferreds(predicate) {\n        var cancelledRouteIds = [];\n        activeDeferreds.forEach(function (dfd, routeId) {\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            var y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return function () {\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            var key = getScrollRestorationKey(location, matches.map(function (m) { return convertRouteMatchToUiMatch(m, state.loaderData); }));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            var key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            var key = getScrollKey(location, matches);\n            var y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename() {\n            return basename;\n        },\n        get future() {\n            return future;\n        },\n        get state() {\n            return state;\n        },\n        get routes() {\n            return dataRoutes;\n        },\n        get window() {\n            return routerWindow;\n        },\n        initialize: initialize,\n        subscribe: subscribe,\n        enableScrollRestoration: enableScrollRestoration,\n        navigate: navigate,\n        fetch: fetch,\n        revalidate: revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: function (to) { return init.history.createHref(to); },\n        encodeLocation: function (to) { return init.history.encodeLocation(to); },\n        getFetcher: getFetcher,\n        deleteFetcher: deleteFetcherAndUpdateState,\n        dispose: dispose,\n        getBlocker: getBlocker,\n        deleteBlocker: deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes: _internalSetRoutes\n    };\n    return router;\n}\nexports.createRouter = createRouter;\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nvar UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nexports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    var manifest = {};\n    var basename = (opts ? opts.basename : null) || \"/\";\n    var mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) {\n        mapRouteProperties = opts.mapRouteProperties;\n    }\n    else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        var detectErrorBoundary_2 = opts.detectErrorBoundary;\n        mapRouteProperties = function (route) { return ({\n            hasErrorBoundary: detectErrorBoundary_2(route)\n        }); };\n    }\n    else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Config driven behavior flags\n    var future = _extends({\n        v7_relativeSplatPath: false\n    }, opts ? opts.future : null);\n    var dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n    /**\n     * The query() method is intended for document requests, in which we want to\n     * call an optional action and potentially multiple loaders for all nested\n     * routes.  It returns a StaticHandlerContext object, which is very similar\n     * to the router state (location, loaderData, actionData, errors, etc.) and\n     * also adds SSR-specific information such as the statusCode and headers\n     * from action/loaders Responses.\n     *\n     * It _should_ never throw and should report all errors through the\n     * returned context.errors object, properly associating errors to their error\n     * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n     * used to emulate React error boundaries during SSr by performing a second\n     * pass only down to the boundaryId.\n     *\n     * The one exception where we do not return a StaticHandlerContext is when a\n     * redirect response is returned or thrown from any action/loader.  We\n     * propagate that out and return the raw Response so the HTTP server can\n     * return it directly.\n     */\n    function query(request, _temp3) {\n        return __awaiter(this, void 0, void 0, function () {\n            var requestContext, url, method, location, matches, error, _a, methodNotAllowedMatches, route, error, _b, notFoundMatches, route, result;\n            var _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        requestContext = (_temp3 === void 0 ? {} : _temp3).requestContext;\n                        url = new URL(request.url);\n                        method = request.method;\n                        location = createLocation(\"\", createPath(url), null, \"default\");\n                        matches = matchRoutes(dataRoutes, location, basename);\n                        // SSR supports HEAD requests while SPA doesn't\n                        if (!isValidMethod(method) && method !== \"HEAD\") {\n                            error = getInternalRouterError(405, {\n                                method: method\n                            });\n                            _a = getShortCircuitMatches(dataRoutes), methodNotAllowedMatches = _a.matches, route = _a.route;\n                            return [2 /*return*/, {\n                                    basename: basename,\n                                    location: location,\n                                    matches: methodNotAllowedMatches,\n                                    loaderData: {},\n                                    actionData: null,\n                                    errors: (_c = {},\n                                        _c[route.id] = error,\n                                        _c),\n                                    statusCode: error.status,\n                                    loaderHeaders: {},\n                                    actionHeaders: {},\n                                    activeDeferreds: null\n                                }];\n                        }\n                        else if (!matches) {\n                            error = getInternalRouterError(404, {\n                                pathname: location.pathname\n                            });\n                            _b = getShortCircuitMatches(dataRoutes), notFoundMatches = _b.matches, route = _b.route;\n                            return [2 /*return*/, {\n                                    basename: basename,\n                                    location: location,\n                                    matches: notFoundMatches,\n                                    loaderData: {},\n                                    actionData: null,\n                                    errors: (_d = {},\n                                        _d[route.id] = error,\n                                        _d),\n                                    statusCode: error.status,\n                                    loaderHeaders: {},\n                                    actionHeaders: {},\n                                    activeDeferreds: null\n                                }];\n                        }\n                        return [4 /*yield*/, queryImpl(request, location, matches, requestContext)];\n                    case 1:\n                        result = _e.sent();\n                        if (isResponse(result)) {\n                            return [2 /*return*/, result];\n                        }\n                        // When returning StaticHandlerContext, we patch back in the location here\n                        // since we need it for React Context.  But this helps keep our submit and\n                        // loadRouteData operating on a Request instead of a Location\n                        return [2 /*return*/, _extends({\n                                location: location,\n                                basename: basename\n                            }, result)];\n                }\n            });\n        });\n    }\n    /**\n     * The queryRoute() method is intended for targeted route requests, either\n     * for fetch ?_data requests or resource route requests.  In this case, we\n     * are only ever calling a single action or loader, and we are returning the\n     * returned value directly.  In most cases, this will be a Response returned\n     * from the action/loader, but it may be a primitive or other value as well -\n     * and in such cases the calling context should handle that accordingly.\n     *\n     * We do respect the throw/return differentiation, so if an action/loader\n     * throws, then this method will throw the value.  This is important so we\n     * can do proper boundary identification in Remix where a thrown Response\n     * must go to the Catch Boundary but a returned Response is happy-path.\n     *\n     * One thing to note is that any Router-initiated Errors that make sense\n     * to associate with a status code will be thrown as an ErrorResponse\n     * instance which include the raw Error, such that the calling context can\n     * serialize the error as they see fit while including the proper response\n     * code.  Examples here are 404 and 405 errors that occur prior to reaching\n     * any user-defined loaders.\n     */\n    function queryRoute(request, _temp4) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, routeId, requestContext, url, method, location, matches, match, result, error, _result$activeDeferre, data;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = _temp4 === void 0 ? {} : _temp4, routeId = _a.routeId, requestContext = _a.requestContext;\n                        url = new URL(request.url);\n                        method = request.method;\n                        location = createLocation(\"\", createPath(url), null, \"default\");\n                        matches = matchRoutes(dataRoutes, location, basename);\n                        // SSR supports HEAD requests while SPA doesn't\n                        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n                            throw getInternalRouterError(405, {\n                                method: method\n                            });\n                        }\n                        else if (!matches) {\n                            throw getInternalRouterError(404, {\n                                pathname: location.pathname\n                            });\n                        }\n                        match = routeId ? matches.find(function (m) { return m.route.id === routeId; }) : getTargetMatch(matches, location);\n                        if (routeId && !match) {\n                            throw getInternalRouterError(403, {\n                                pathname: location.pathname,\n                                routeId: routeId\n                            });\n                        }\n                        else if (!match) {\n                            // This should never hit I don't think?\n                            throw getInternalRouterError(404, {\n                                pathname: location.pathname\n                            });\n                        }\n                        return [4 /*yield*/, queryImpl(request, location, matches, requestContext, match)];\n                    case 1:\n                        result = _b.sent();\n                        if (isResponse(result)) {\n                            return [2 /*return*/, result];\n                        }\n                        error = result.errors ? Object.values(result.errors)[0] : undefined;\n                        if (error !== undefined) {\n                            // If we got back result.errors, that means the loader/action threw\n                            // _something_ that wasn't a Response, but it's not guaranteed/required\n                            // to be an `instanceof Error` either, so we have to use throw here to\n                            // preserve the \"error\" state outside of queryImpl.\n                            throw error;\n                        }\n                        // Pick off the right state value to return\n                        if (result.actionData) {\n                            return [2 /*return*/, Object.values(result.actionData)[0]];\n                        }\n                        if (result.loaderData) {\n                            data = Object.values(result.loaderData)[0];\n                            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n                                data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n                            }\n                            return [2 /*return*/, data];\n                        }\n                        return [2 /*return*/, undefined];\n                }\n            });\n        });\n    }\n    function queryImpl(request, location, matches, requestContext, routeMatch) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result_1, result, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 5, , 6]);\n                        if (!isMutationMethod(request.method.toLowerCase())) return [3 /*break*/, 3];\n                        return [4 /*yield*/, submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null)];\n                    case 2:\n                        result_1 = _a.sent();\n                        return [2 /*return*/, result_1];\n                    case 3: return [4 /*yield*/, loadRouteData(request, matches, requestContext, routeMatch)];\n                    case 4:\n                        result = _a.sent();\n                        return [2 /*return*/, isResponse(result) ? result : _extends({}, result, {\n                                actionData: null,\n                                actionHeaders: {}\n                            })];\n                    case 5:\n                        e_1 = _a.sent();\n                        // If the user threw/returned a Response in callLoaderOrAction, we throw\n                        // it to bail out and then return or throw here based on whether the user\n                        // returned or threw\n                        if (isQueryRouteResponse(e_1)) {\n                            if (e_1.type === ResultType.error) {\n                                throw e_1.response;\n                            }\n                            return [2 /*return*/, e_1.response];\n                        }\n                        // Redirects are always returned since they don't propagate to catch\n                        // boundaries\n                        if (isRedirectResponse(e_1)) {\n                            return [2 /*return*/, e_1];\n                        }\n                        throw e_1;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    }\n    function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error, method, error, boundaryMatch, context_1, loaderRequest, context;\n            var _a, _b, _c, _d, _e;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        if (!(!actionMatch.route.action && !actionMatch.route.lazy)) return [3 /*break*/, 1];\n                        error = getInternalRouterError(405, {\n                            method: request.method,\n                            pathname: new URL(request.url).pathname,\n                            routeId: actionMatch.route.id\n                        });\n                        if (isRouteRequest) {\n                            throw error;\n                        }\n                        result = {\n                            type: ResultType.error,\n                            error: error\n                        };\n                        return [3 /*break*/, 3];\n                    case 1: return [4 /*yield*/, callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                            isStaticRequest: true,\n                            isRouteRequest: isRouteRequest,\n                            requestContext: requestContext\n                        })];\n                    case 2:\n                        result = _f.sent();\n                        if (request.signal.aborted) {\n                            method = isRouteRequest ? \"queryRoute\" : \"query\";\n                            throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n                        }\n                        _f.label = 3;\n                    case 3:\n                        if (isRedirectResult(result)) {\n                            // Uhhhh - this should never happen, we should always throw these from\n                            // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n                            // can get back on the \"throw all redirect responses\" train here should\n                            // this ever happen :/\n                            throw new Response(null, {\n                                status: result.status,\n                                headers: {\n                                    Location: result.location\n                                }\n                            });\n                        }\n                        if (isDeferredResult(result)) {\n                            error = getInternalRouterError(400, {\n                                type: \"defer-action\"\n                            });\n                            if (isRouteRequest) {\n                                throw error;\n                            }\n                            result = {\n                                type: ResultType.error,\n                                error: error\n                            };\n                        }\n                        if (isRouteRequest) {\n                            // Note: This should only be non-Response values if we get here, since\n                            // isRouteRequest should throw any Response received in callLoaderOrAction\n                            if (isErrorResult(result)) {\n                                throw result.error;\n                            }\n                            return [2 /*return*/, {\n                                    matches: [actionMatch],\n                                    loaderData: {},\n                                    actionData: (_a = {},\n                                        _a[actionMatch.route.id] = result.data,\n                                        _a),\n                                    errors: null,\n                                    // Note: statusCode + headers are unused here since queryRoute will\n                                    // return the raw Response or value\n                                    statusCode: 200,\n                                    loaderHeaders: {},\n                                    actionHeaders: {},\n                                    activeDeferreds: null\n                                }];\n                        }\n                        if (!isErrorResult(result)) return [3 /*break*/, 5];\n                        boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n                        return [4 /*yield*/, loadRouteData(request, matches, requestContext, undefined, (_b = {},\n                                _b[boundaryMatch.route.id] = result.error,\n                                _b))];\n                    case 4:\n                        context_1 = _f.sent();\n                        // action status codes take precedence over loader status codes\n                        return [2 /*return*/, _extends({}, context_1, {\n                                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                                actionData: null,\n                                actionHeaders: _extends({}, result.headers ? (_c = {},\n                                    _c[actionMatch.route.id] = result.headers,\n                                    _c) : {})\n                            })];\n                    case 5:\n                        loaderRequest = new Request(request.url, {\n                            headers: request.headers,\n                            redirect: request.redirect,\n                            signal: request.signal\n                        });\n                        return [4 /*yield*/, loadRouteData(loaderRequest, matches, requestContext)];\n                    case 6:\n                        context = _f.sent();\n                        return [2 /*return*/, _extends({}, context, result.statusCode ? {\n                                statusCode: result.statusCode\n                            } : {}, {\n                                actionData: (_d = {},\n                                    _d[actionMatch.route.id] = result.data,\n                                    _d),\n                                actionHeaders: _extends({}, result.headers ? (_e = {},\n                                    _e[actionMatch.route.id] = result.headers,\n                                    _e) : {})\n                            })];\n                }\n            });\n        });\n    }\n    function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        return __awaiter(this, void 0, void 0, function () {\n            var isRouteRequest, requestMatches, matchesToLoad, results, method, activeDeferreds, context, executedLoaders;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        isRouteRequest = routeMatch != null;\n                        // Short circuit if we have no loaders to run (queryRoute())\n                        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n                            throw getInternalRouterError(400, {\n                                method: request.method,\n                                pathname: new URL(request.url).pathname,\n                                routeId: routeMatch == null ? void 0 : routeMatch.route.id\n                            });\n                        }\n                        requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n                        matchesToLoad = requestMatches.filter(function (m) { return m.route.loader || m.route.lazy; });\n                        // Short circuit if we have no loaders to run (query())\n                        if (matchesToLoad.length === 0) {\n                            return [2 /*return*/, {\n                                    matches: matches,\n                                    // Add a null for all matched routes for proper revalidation on the client\n                                    loaderData: matches.reduce(function (acc, m) {\n                                        var _a;\n                                        return Object.assign(acc, (_a = {},\n                                            _a[m.route.id] = null,\n                                            _a));\n                                    }, {}),\n                                    errors: pendingActionError || null,\n                                    statusCode: 200,\n                                    loaderHeaders: {},\n                                    activeDeferreds: null\n                                }];\n                        }\n                        return [4 /*yield*/, Promise.all(__spreadArray([], matchesToLoad.map(function (match) { return callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                                isStaticRequest: true,\n                                isRouteRequest: isRouteRequest,\n                                requestContext: requestContext\n                            }); }), true))];\n                    case 1:\n                        results = _a.sent();\n                        if (request.signal.aborted) {\n                            method = isRouteRequest ? \"queryRoute\" : \"query\";\n                            throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n                        }\n                        activeDeferreds = new Map();\n                        context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n                        executedLoaders = new Set(matchesToLoad.map(function (match) { return match.route.id; }));\n                        matches.forEach(function (match) {\n                            if (!executedLoaders.has(match.route.id)) {\n                                context.loaderData[match.route.id] = null;\n                            }\n                        });\n                        return [2 /*return*/, _extends({}, context, {\n                                matches: matches,\n                                activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n                            })];\n                }\n            });\n        });\n    }\n    return {\n        dataRoutes: dataRoutes,\n        query: query,\n        queryRoute: queryRoute\n    };\n}\nexports.createStaticHandler = createStaticHandler;\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n    var _a;\n    var newContext = _extends({}, context, {\n        statusCode: 500,\n        errors: (_a = {},\n            _a[context._deepestRenderedBoundaryId || routes[0].id] = error,\n            _a)\n    });\n    return newContext;\n}\nexports.getStaticContextFromError = getStaticContextFromError;\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n    var contextualMatches;\n    var activeRouteMatch;\n    if (fromRouteId) {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route\n        contextualMatches = [];\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var match = matches_1[_i];\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    }\n    else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    var path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path: path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path: path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    var getInvalidBodyError = function () { return ({\n        path: path,\n        error: getInternalRouterError(400, {\n            type: \"invalid-body\"\n        })\n    }); };\n    // Create a Submission on non-GET navigations\n    var rawFormMethod = opts.formMethod || \"get\";\n    var formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    var formAction = stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            var text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n                // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n                Array.from(opts.body.entries()).reduce(function (acc, _ref3) {\n                    var name = _ref3[0], value = _ref3[1];\n                    return \"\" + acc + name + \"=\" + value + \"\\n\";\n                }, \"\") : String(opts.body);\n            return {\n                path: path,\n                submission: {\n                    formMethod: formMethod,\n                    formAction: formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text: text\n                }\n            };\n        }\n        else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                var json_1 = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path: path,\n                    submission: {\n                        formMethod: formMethod,\n                        formAction: formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json: json_1,\n                        text: undefined\n                    }\n                };\n            }\n            catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    var searchParams;\n    var formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    }\n    else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    }\n    else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    }\n    else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    }\n    else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        }\n        catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    var submission = {\n        formMethod: formMethod,\n        formAction: formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData: formData,\n        json: undefined,\n        text: undefined\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path: path,\n            submission: submission\n        };\n    }\n    // Flatten submission onto URLSearchParams for GET submissions\n    var parsedPath = parsePath(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: createPath(parsedPath),\n        submission: submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    var boundaryMatches = matches;\n    if (boundaryId) {\n        var index = matches.findIndex(function (m) { return m.route.id === boundaryId; });\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    var actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    var currentUrl = history.createURL(state.location);\n    var nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    var boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    var boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    var navigationMatches = boundaryMatches.filter(function (match, index) {\n        var route = match.route;\n        if (route.lazy) {\n            // We haven't loaded this route yet so we don't know if it's got a loader!\n            return true;\n        }\n        if (route.loader == null) {\n            return false;\n        }\n        if (isInitialLoad) {\n            if (route.loader.hydrate) {\n                return true;\n            }\n            return state.loaderData[route.id] === undefined && (\n            // Don't re-run if the loader ran and threw an error\n            !state.errors || state.errors[route.id] === undefined);\n        }\n        // Always call the loader on new route instances and pending defer cancellations\n        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(function (id) { return id === match.route.id; })) {\n            return true;\n        }\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        var currentRouteMatch = state.matches[index];\n        var nextRouteMatch = match;\n        return shouldRevalidateLoader(match, _extends({\n            currentUrl: currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl: nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult: actionResult,\n            defaultShouldRevalidate: \n            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired ||\n                // Clicked the same link, resubmitted a GET form\n                currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n                // Search params affect all loaders\n                currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    var revalidatingFetchers = [];\n    fetchLoadMatches.forEach(function (f, key) {\n        // Don't revalidate:\n        //  - on initial load (shouldn't be any fetchers then anyway)\n        //  - if fetcher won't be present in the subsequent render\n        //    - no longer matches the URL (v7_fetcherPersist=false)\n        //    - was unmounted but persisted due to v7_fetcherPersist=true\n        if (isInitialLoad || !matches.some(function (m) { return m.route.id === f.routeId; }) || deletedFetchers.has(key)) {\n            return;\n        }\n        var fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key: key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        var fetcher = state.fetchers.get(key);\n        var fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        var shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) {\n            // Never trigger a revalidation of an actively redirecting fetcher\n            shouldRevalidate = false;\n        }\n        else if (cancelledFetcherLoads.includes(key)) {\n            // Always revalidate if the fetcher was cancelled\n            shouldRevalidate = true;\n        }\n        else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n            // If the fetcher hasn't ever completed loading yet, then this isn't a\n            // revalidation, it would just be a brand new load if an explicit\n            // revalidation is required\n            shouldRevalidate = isRevalidationRequired;\n        }\n        else {\n            // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n            // to explicit revalidations only\n            shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n                currentUrl: currentUrl,\n                currentParams: state.matches[state.matches.length - 1].params,\n                nextUrl: nextUrl,\n                nextParams: matches[matches.length - 1].params\n            }, submission, {\n                actionResult: actionResult,\n                defaultShouldRevalidate: isRevalidationRequired\n            }));\n        }\n        if (shouldRevalidate) {\n            revalidatingFetchers.push({\n                key: key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherMatches,\n                match: fetcherMatch,\n                controller: new AbortController()\n            });\n        }\n    });\n    return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    var isNew = \n    // [a] -> [a, b]\n    !currentMatch ||\n        // [a, b] -> [a, c]\n        match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    var isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    var currentPath = currentMatch.route.path;\n    return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n        // splat param changed, which is not present in match.path\n        // e.g. /files/images/avatar.jpg -> files/finances.xls\n        currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        var routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nfunction loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    return __awaiter(this, void 0, void 0, function () {\n        var lazyRoute, routeToUpdate, routeUpdates, lazyRouteProperty, staticRouteValue, isPropertyStaticallyDefined;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!route.lazy) {\n                        return [2 /*return*/];\n                    }\n                    return [4 /*yield*/, route.lazy()];\n                case 1:\n                    lazyRoute = _a.sent();\n                    // If the lazy route function was executed and removed by another parallel\n                    // call then we can return - first lazy() to finish wins because the return\n                    // value of lazy is expected to be static\n                    if (!route.lazy) {\n                        return [2 /*return*/];\n                    }\n                    routeToUpdate = manifest[route.id];\n                    invariant(routeToUpdate, \"No route found in manifest\");\n                    routeUpdates = {};\n                    for (lazyRouteProperty in lazyRoute) {\n                        staticRouteValue = routeToUpdate[lazyRouteProperty];\n                        isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n                            // This property isn't static since it should always be updated based\n                            // on the route updates\n                            lazyRouteProperty !== \"hasErrorBoundary\";\n                        warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n                        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n                            routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n                        }\n                    }\n                    // Mutate the route with the provided updates.  Do this first so we pass\n                    // the updated version to mapRouteProperties\n                    Object.assign(routeToUpdate, routeUpdates);\n                    // Mutate the `hasErrorBoundary` property on the route based on the route\n                    // updates and remove the `lazy` function so we don't resolve the lazy\n                    // route again.\n                    Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n                        lazy: undefined\n                    }));\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, v7_relativeSplatPath, opts) {\n    return __awaiter(this, void 0, void 0, function () {\n        var resultType, result, onReject, runHandler, handler, handlerError_1, values, url, pathname, url, pathname, e_2, status_1, location_1, currentUrl, url, isSameBasename, queryRouteResponse, data, contentType, e_3, _result$init, _result$init2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (opts === void 0) {\n                        opts = {};\n                    }\n                    runHandler = function (handler) {\n                        // Setup a promise we can race against so that abort signals short circuit\n                        var reject;\n                        var abortPromise = new Promise(function (_, r) { return reject = r; });\n                        onReject = function () { return reject(); };\n                        request.signal.addEventListener(\"abort\", onReject);\n                        return Promise.race([handler({\n                                request: request,\n                                params: match.params,\n                                context: opts.requestContext\n                            }), abortPromise]);\n                    };\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 12, 13, 14]);\n                    handler = match.route[type];\n                    if (!match.route.lazy) return [3 /*break*/, 8];\n                    if (!handler) return [3 /*break*/, 3];\n                    return [4 /*yield*/, Promise.all([\n                            // If the handler throws, don't let it immediately bubble out,\n                            // since we need to let the lazy() execution finish so we know if this\n                            // route has a boundary that can handle the error\n                            runHandler(handler).catch(function (e) {\n                                handlerError_1 = e;\n                            }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                        ])];\n                case 2:\n                    values = _a.sent();\n                    if (handlerError_1) {\n                        throw handlerError_1;\n                    }\n                    result = values[0];\n                    return [3 /*break*/, 7];\n                case 3: \n                // Load lazy route module, then run any returned handler\n                return [4 /*yield*/, loadLazyRouteModule(match.route, mapRouteProperties, manifest)];\n                case 4:\n                    // Load lazy route module, then run any returned handler\n                    _a.sent();\n                    handler = match.route[type];\n                    if (!handler) return [3 /*break*/, 6];\n                    return [4 /*yield*/, runHandler(handler)];\n                case 5:\n                    // Handler still run even if we got interrupted to maintain consistency\n                    // with un-abortable behavior of handler execution on non-lazy or\n                    // previously-lazy-loaded routes\n                    result = _a.sent();\n                    return [3 /*break*/, 7];\n                case 6:\n                    if (type === \"action\") {\n                        url = new URL(request.url);\n                        pathname = url.pathname + url.search;\n                        throw getInternalRouterError(405, {\n                            method: request.method,\n                            pathname: pathname,\n                            routeId: match.route.id\n                        });\n                    }\n                    else {\n                        // lazy() route has no loader to run.  Short circuit here so we don't\n                        // hit the invariant below that errors on returning undefined.\n                        return [2 /*return*/, {\n                                type: ResultType.data,\n                                data: undefined\n                            }];\n                    }\n                    _a.label = 7;\n                case 7: return [3 /*break*/, 11];\n                case 8:\n                    if (!!handler) return [3 /*break*/, 9];\n                    url = new URL(request.url);\n                    pathname = url.pathname + url.search;\n                    throw getInternalRouterError(404, {\n                        pathname: pathname\n                    });\n                case 9: return [4 /*yield*/, runHandler(handler)];\n                case 10:\n                    result = _a.sent();\n                    _a.label = 11;\n                case 11:\n                    invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n                    return [3 /*break*/, 14];\n                case 12:\n                    e_2 = _a.sent();\n                    resultType = ResultType.error;\n                    result = e_2;\n                    return [3 /*break*/, 14];\n                case 13:\n                    if (onReject) {\n                        request.signal.removeEventListener(\"abort\", onReject);\n                    }\n                    return [7 /*endfinally*/];\n                case 14:\n                    if (!isResponse(result)) return [3 /*break*/, 24];\n                    status_1 = result.status;\n                    // Process redirects\n                    if (redirectStatusCodes.has(status_1)) {\n                        location_1 = result.headers.get(\"Location\");\n                        invariant(location_1, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n                        // Support relative routing in internal redirects\n                        if (!ABSOLUTE_URL_REGEX.test(location_1)) {\n                            location_1 = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location_1, v7_relativeSplatPath);\n                        }\n                        else if (!opts.isStaticRequest) {\n                            currentUrl = new URL(request.url);\n                            url = location_1.startsWith(\"//\") ? new URL(currentUrl.protocol + location_1) : new URL(location_1);\n                            isSameBasename = stripBasename(url.pathname, basename) != null;\n                            if (url.origin === currentUrl.origin && isSameBasename) {\n                                location_1 = url.pathname + url.search + url.hash;\n                            }\n                        }\n                        // Don't process redirects in the router during static requests requests.\n                        // Instead, throw the Response and let the server handle it with an HTTP\n                        // redirect.  We also update the Location header in place in this flow so\n                        // basename and relative routing is taken into account\n                        if (opts.isStaticRequest) {\n                            result.headers.set(\"Location\", location_1);\n                            throw result;\n                        }\n                        return [2 /*return*/, {\n                                type: ResultType.redirect,\n                                status: status_1,\n                                location: location_1,\n                                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n                                reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n                            }];\n                    }\n                    // For SSR single-route requests, we want to hand Responses back directly\n                    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n                    // interface so we can know whether it was returned or thrown\n                    if (opts.isRouteRequest) {\n                        queryRouteResponse = {\n                            type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n                            response: result\n                        };\n                        throw queryRouteResponse;\n                    }\n                    data = void 0;\n                    _a.label = 15;\n                case 15:\n                    _a.trys.push([15, 22, , 23]);\n                    contentType = result.headers.get(\"Content-Type\");\n                    if (!(contentType && /\\bapplication\\/json\\b/.test(contentType))) return [3 /*break*/, 19];\n                    if (!(result.body == null)) return [3 /*break*/, 16];\n                    data = null;\n                    return [3 /*break*/, 18];\n                case 16: return [4 /*yield*/, result.json()];\n                case 17:\n                    data = _a.sent();\n                    _a.label = 18;\n                case 18: return [3 /*break*/, 21];\n                case 19: return [4 /*yield*/, result.text()];\n                case 20:\n                    data = _a.sent();\n                    _a.label = 21;\n                case 21: return [3 /*break*/, 23];\n                case 22:\n                    e_3 = _a.sent();\n                    return [2 /*return*/, {\n                            type: ResultType.error,\n                            error: e_3\n                        }];\n                case 23:\n                    if (resultType === ResultType.error) {\n                        return [2 /*return*/, {\n                                type: resultType,\n                                error: new ErrorResponseImpl(status_1, result.statusText, data),\n                                headers: result.headers\n                            }];\n                    }\n                    return [2 /*return*/, {\n                            type: ResultType.data,\n                            data: data,\n                            statusCode: result.status,\n                            headers: result.headers\n                        }];\n                case 24:\n                    if (resultType === ResultType.error) {\n                        return [2 /*return*/, {\n                                type: resultType,\n                                error: result\n                            }];\n                    }\n                    if (isDeferredData(result)) {\n                        return [2 /*return*/, {\n                                type: ResultType.deferred,\n                                deferredData: result,\n                                statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n                                headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n                            }];\n                    }\n                    return [2 /*return*/, {\n                            type: ResultType.data,\n                            data: result\n                        }];\n            }\n        });\n    });\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n    var url = history.createURL(stripHashFromPath(location)).toString();\n    var init = {\n        signal: signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        var formMethod = submission.formMethod, formEncType = submission.formEncType;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        }\n        else if (formEncType === \"text/plain\") {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.text;\n        }\n        else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = convertFormDataToSearchParams(submission.formData);\n        }\n        else {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    var searchParams = new URLSearchParams();\n    for (var _i = 0, _a = formData.entries(); _i < _a.length; _i++) {\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    var formData = new FormData();\n    for (var _i = 0, _a = searchParams.entries(); _i < _a.length; _i++) {\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    var loaderData = {};\n    var errors = null;\n    var statusCode;\n    var foundError = false;\n    var loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach(function (result, index) {\n        var id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            var boundaryMatch = findNearestBoundary(matches, id);\n            var error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) {\n                errors[boundaryMatch.route.id] = error;\n            }\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n        else {\n            if (isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            }\n            else {\n                loaderData[id] = result.data;\n            }\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData: loaderData,\n        errors: errors,\n        statusCode: statusCode || 200,\n        loaderHeaders: loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    var _a;\n    var _b = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds), loaderData = _b.loaderData, errors = _b.errors;\n    // Process results from our revalidating fetchers\n    for (var index = 0; index < revalidatingFetchers.length; index++) {\n        var _c = revalidatingFetchers[index], key = _c.key, match = _c.match, controller = _c.controller;\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        var result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) {\n            // Nothing to do for aborted fetchers\n            continue;\n        }\n        else if (isErrorResult(result)) {\n            var boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, (_a = {},\n                    _a[boundaryMatch.route.id] = result.error,\n                    _a));\n            }\n            state.fetchers.delete(key);\n        }\n        else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        }\n        else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            invariant(false, \"Unhandled fetcher deferred data\");\n        }\n        else {\n            var doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData: loaderData,\n        errors: errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    var mergedLoaderData = _extends({}, newLoaderData);\n    for (var _i = 0, matches_2 = matches; _i < matches_2.length; _i++) {\n        var match = matches_2[_i];\n        var id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) {\n                mergedLoaderData[id] = newLoaderData[id];\n            }\n        }\n        else if (loaderData[id] !== undefined && match.route.loader) {\n            // Preserve existing keys not included in newLoaderData and where a loader\n            // wasn't removed by HMR\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            // Don't keep any loader data below the boundary\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    var eligibleMatches = routeId ? matches.slice(0, matches.findIndex(function (m) { return m.route.id === routeId; }) + 1) : __spreadArray([], matches, true);\n    return eligibleMatches.reverse().find(function (m) { return m.route.hasErrorBoundary === true; }) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    var route = routes.length === 1 ? routes[0] : routes.find(function (r) { return r.index || !r.path || r.path === \"/\"; }) || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [{\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route: route\n            }],\n        route: route\n    };\n}\nfunction getInternalRouterError(status, _temp5) {\n    var _a = _temp5 === void 0 ? {} : _temp5, pathname = _a.pathname, routeId = _a.routeId, method = _a.method, type = _a.type;\n    var statusText = \"Unknown Server Error\";\n    var errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n        }\n        else if (type === \"defer-action\") {\n            errorMessage = \"defer() is not supported in actions\";\n        }\n        else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    }\n    else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n    }\n    else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n    }\n    else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n        }\n        else if (method) {\n            errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for (var i = results.length - 1; i >= 0; i--) {\n        var result = results[i];\n        if (isRedirectResult(result)) {\n            return {\n                result: result,\n                idx: i\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    var parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath(_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        // /page -> /page#hash\n        return b.hash !== \"\";\n    }\n    else if (a.hash === b.hash) {\n        // /page#hash -> /page#hash\n        return true;\n    }\n    else if (b.hash !== \"\") {\n        // /page#hash -> /page#other\n        return true;\n    }\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n    var deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nexports.isDeferredData = isDeferredData;\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n    if (!isResponse(result)) {\n        return false;\n    }\n    var status = result.status;\n    var location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n    return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toLowerCase());\n}\nfunction resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _loop_1, index;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _loop_1 = function (index) {\n                        var result, match, currentMatch, isRevalidatingLoader, signal;\n                        return __generator(this, function (_b) {\n                            switch (_b.label) {\n                                case 0:\n                                    result = results[index];\n                                    match = matchesToLoad[index];\n                                    // If we don't have a match, then we can have a deferred result to do\n                                    // anything with.  This is for revalidating fetchers where the route was\n                                    // removed during HMR\n                                    if (!match) {\n                                        return [2 /*return*/, \"continue\"];\n                                    }\n                                    currentMatch = currentMatches.find(function (m) { return m.route.id === match.route.id; });\n                                    isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n                                    if (!(isDeferredResult(result) && (isFetcher || isRevalidatingLoader))) return [3 /*break*/, 2];\n                                    signal = signals[index];\n                                    invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n                                    return [4 /*yield*/, resolveDeferredData(result, signal, isFetcher).then(function (result) {\n                                            if (result) {\n                                                results[index] = result || results[index];\n                                            }\n                                        })];\n                                case 1:\n                                    _b.sent();\n                                    _b.label = 2;\n                                case 2: return [2 /*return*/];\n                            }\n                        });\n                    };\n                    index = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(index < results.length)) return [3 /*break*/, 4];\n                    return [5 /*yield**/, _loop_1(index)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    index++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction resolveDeferredData(result, signal, unwrap) {\n    return __awaiter(this, void 0, void 0, function () {\n        var aborted;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (unwrap === void 0) {\n                        unwrap = false;\n                    }\n                    return [4 /*yield*/, result.deferredData.resolveData(signal)];\n                case 1:\n                    aborted = _a.sent();\n                    if (aborted) {\n                        return [2 /*return*/];\n                    }\n                    if (unwrap) {\n                        try {\n                            return [2 /*return*/, {\n                                    type: ResultType.data,\n                                    data: result.deferredData.unwrappedData\n                                }];\n                        }\n                        catch (e) {\n                            // Handle any TrackedPromise._error values encountered while unwrapping\n                            return [2 /*return*/, {\n                                    type: ResultType.error,\n                                    error: e\n                                }];\n                        }\n                    }\n                    return [2 /*return*/, {\n                            type: ResultType.data,\n                            data: result.deferredData.data\n                        }];\n            }\n        });\n    });\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some(function (v) { return v === \"\"; });\n}\nfunction getTargetMatch(matches, location) {\n    var search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        // Return the leaf index route when index is present\n        return matches[matches.length - 1];\n    }\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    var pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    var formMethod = navigation.formMethod, formAction = navigation.formAction, formEncType = navigation.formEncType, text = navigation.text, formData = navigation.formData, json = navigation.json;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod: formMethod,\n            formAction: formAction,\n            formEncType: formEncType,\n            formData: undefined,\n            json: undefined,\n            text: text\n        };\n    }\n    else if (formData != null) {\n        return {\n            formMethod: formMethod,\n            formAction: formAction,\n            formEncType: formEncType,\n            formData: formData,\n            json: undefined,\n            text: undefined\n        };\n    }\n    else if (json !== undefined) {\n        return {\n            formMethod: formMethod,\n            formAction: formAction,\n            formEncType: formEncType,\n            formData: undefined,\n            json: json,\n            text: undefined\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        var navigation = {\n            state: \"loading\",\n            location: location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    }\n    else {\n        var navigation = {\n            state: \"loading\",\n            location: location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    var navigation = {\n        state: \"submitting\",\n        location: location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n    if (submission) {\n        var fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data: data\n        };\n        return fetcher;\n    }\n    else {\n        var fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data: data\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    var fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data) {\n    var fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data: data\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        var sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            var json_2 = JSON.parse(sessionPositions);\n            for (var _i = 0, _a = Object.entries(json_2 || {}); _i < _a.length; _i++) {\n                var _b = _a[_i], k = _b[0], v = _b[1];\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    }\n    catch (e) {\n        // no-op, use default empty object\n    }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        var json_3 = {};\n        for (var _i = 0, transitions_1 = transitions; _i < transitions_1.length; _i++) {\n            var _a = transitions_1[_i], k = _a[0], v = _a[1];\n            json_3[k] = __spreadArray([], v, true);\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json_3));\n        }\n        catch (error) {\n            warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/@remix-run/router/dist/router.js?");

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeConfig = exports.getAdapter = exports.formToJSON = exports.HttpStatusCode = exports.AxiosHeaders = exports.toFormData = exports.spread = exports.isAxiosError = exports.Cancel = exports.all = exports.VERSION = exports.CancelToken = exports.isCancel = exports.CanceledError = exports.AxiosError = exports.Axios = exports.default = void 0;\nvar axios_js_1 = __importDefault(__webpack_require__(/*! ./lib/axios.js */ \"./node_modules/axios/lib/axios.js\"));\nexports.default = axios_js_1.default;\n// This module is intended to unwrap Axios default export as named.\n// Keep top-level export same with static properties\n// so that it can keep same with es module or cjs\nvar Axios = axios_js_1.default.Axios, AxiosError = axios_js_1.default.AxiosError, CanceledError = axios_js_1.default.CanceledError, isCancel = axios_js_1.default.isCancel, CancelToken = axios_js_1.default.CancelToken, VERSION = axios_js_1.default.VERSION, all = axios_js_1.default.all, Cancel = axios_js_1.default.Cancel, isAxiosError = axios_js_1.default.isAxiosError, spread = axios_js_1.default.spread, toFormData = axios_js_1.default.toFormData, AxiosHeaders = axios_js_1.default.AxiosHeaders, HttpStatusCode = axios_js_1.default.HttpStatusCode, formToJSON = axios_js_1.default.formToJSON, getAdapter = axios_js_1.default.getAdapter, mergeConfig = axios_js_1.default.mergeConfig;\nexports.Axios = Axios;\nexports.AxiosError = AxiosError;\nexports.CanceledError = CanceledError;\nexports.isCancel = isCancel;\nexports.CancelToken = CancelToken;\nexports.VERSION = VERSION;\nexports.all = all;\nexports.Cancel = Cancel;\nexports.isAxiosError = isAxiosError;\nexports.spread = spread;\nexports.toFormData = toFormData;\nexports.AxiosHeaders = AxiosHeaders;\nexports.HttpStatusCode = HttpStatusCode;\nexports.formToJSON = formToJSON;\nexports.getAdapter = getAdapter;\nexports.mergeConfig = mergeConfig;\n\n\n//# sourceURL=webpack:///./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/adapters.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/adapters/adapters.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar http_js_1 = __importDefault(__webpack_require__(/*! ./http.js */ \"./node_modules/axios/lib/helpers/null.js\"));\nvar xhr_js_1 = __importDefault(__webpack_require__(/*! ./xhr.js */ \"./node_modules/axios/lib/adapters/xhr.js\"));\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\nvar knownAdapters = {\n    http: http_js_1.default,\n    xhr: xhr_js_1.default\n};\nutils_js_1.default.forEach(knownAdapters, function (fn, value) {\n    if (fn) {\n        try {\n            Object.defineProperty(fn, 'name', { value: value });\n        }\n        catch (e) {\n            // eslint-disable-next-line no-empty\n        }\n        Object.defineProperty(fn, 'adapterName', { value: value });\n    }\n});\nvar renderReason = function (reason) { return \"- \".concat(reason); };\nvar isResolvedHandle = function (adapter) { return utils_js_1.default.isFunction(adapter) || adapter === null || adapter === false; };\nexports.default = {\n    getAdapter: function (adapters) {\n        adapters = utils_js_1.default.isArray(adapters) ? adapters : [adapters];\n        var length = adapters.length;\n        var nameOrAdapter;\n        var adapter;\n        var rejectedReasons = {};\n        for (var i = 0; i < length; i++) {\n            nameOrAdapter = adapters[i];\n            var id = void 0;\n            adapter = nameOrAdapter;\n            if (!isResolvedHandle(nameOrAdapter)) {\n                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n                if (adapter === undefined) {\n                    throw new AxiosError_js_1.default(\"Unknown adapter '\".concat(id, \"'\"));\n                }\n            }\n            if (adapter) {\n                break;\n            }\n            rejectedReasons[id || '#' + i] = adapter;\n        }\n        if (!adapter) {\n            var reasons = Object.entries(rejectedReasons)\n                .map(function (_a) {\n                var id = _a[0], state = _a[1];\n                return \"adapter \".concat(id, \" \") +\n                    (state === false ? 'is not supported by the environment' : 'is not available in the build');\n            });\n            var s = length ?\n                (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n                'as no adapter specified';\n            throw new AxiosError_js_1.default(\"There is no suitable adapter to dispatch the request \" + s, 'ERR_NOT_SUPPORT');\n        }\n        return adapter;\n    },\n    adapters: knownAdapters\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/adapters.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar settle_js_1 = __importDefault(__webpack_require__(/*! ./../core/settle.js */ \"./node_modules/axios/lib/core/settle.js\"));\nvar cookies_js_1 = __importDefault(__webpack_require__(/*! ./../helpers/cookies.js */ \"./node_modules/axios/lib/helpers/cookies.js\"));\nvar buildURL_js_1 = __importDefault(__webpack_require__(/*! ./../helpers/buildURL.js */ \"./node_modules/axios/lib/helpers/buildURL.js\"));\nvar buildFullPath_js_1 = __importDefault(__webpack_require__(/*! ../core/buildFullPath.js */ \"./node_modules/axios/lib/core/buildFullPath.js\"));\nvar isURLSameOrigin_js_1 = __importDefault(__webpack_require__(/*! ./../helpers/isURLSameOrigin.js */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\"));\nvar transitional_js_1 = __importDefault(__webpack_require__(/*! ../defaults/transitional.js */ \"./node_modules/axios/lib/defaults/transitional.js\"));\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\nvar CanceledError_js_1 = __importDefault(__webpack_require__(/*! ../cancel/CanceledError.js */ \"./node_modules/axios/lib/cancel/CanceledError.js\"));\nvar parseProtocol_js_1 = __importDefault(__webpack_require__(/*! ../helpers/parseProtocol.js */ \"./node_modules/axios/lib/helpers/parseProtocol.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../platform/index.js */ \"./node_modules/axios/lib/platform/index.js\"));\nvar AxiosHeaders_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosHeaders.js */ \"./node_modules/axios/lib/core/AxiosHeaders.js\"));\nvar speedometer_js_1 = __importDefault(__webpack_require__(/*! ../helpers/speedometer.js */ \"./node_modules/axios/lib/helpers/speedometer.js\"));\nfunction progressEventReducer(listener, isDownloadStream) {\n    var bytesNotified = 0;\n    var _speedometer = (0, speedometer_js_1.default)(50, 250);\n    return function (e) {\n        var loaded = e.loaded;\n        var total = e.lengthComputable ? e.total : undefined;\n        var progressBytes = loaded - bytesNotified;\n        var rate = _speedometer(progressBytes);\n        var inRange = loaded <= total;\n        bytesNotified = loaded;\n        var data = {\n            loaded: loaded,\n            total: total,\n            progress: total ? (loaded / total) : undefined,\n            bytes: progressBytes,\n            rate: rate ? rate : undefined,\n            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n            event: e\n        };\n        data[isDownloadStream ? 'download' : 'upload'] = true;\n        listener(data);\n    };\n}\nvar isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\nexports.default = isXHRAdapterSupported && function (config) {\n    return new Promise(function dispatchXhrRequest(resolve, reject) {\n        var requestData = config.data;\n        var requestHeaders = AxiosHeaders_js_1.default.from(config.headers).normalize();\n        var responseType = config.responseType, withXSRFToken = config.withXSRFToken;\n        var onCanceled;\n        function done() {\n            if (config.cancelToken) {\n                config.cancelToken.unsubscribe(onCanceled);\n            }\n            if (config.signal) {\n                config.signal.removeEventListener('abort', onCanceled);\n            }\n        }\n        var contentType;\n        if (utils_js_1.default.isFormData(requestData)) {\n            if (index_js_1.default.hasStandardBrowserEnv || index_js_1.default.hasStandardBrowserWebWorkerEnv) {\n                requestHeaders.setContentType(false); // Let the browser set it\n            }\n            else if ((contentType = requestHeaders.getContentType()) !== false) {\n                // fix semicolon duplication issue for ReactNative FormData implementation\n                var _a = contentType ? contentType.split(';').map(function (token) { return token.trim(); }).filter(Boolean) : [], type = _a[0], tokens = _a.slice(1);\n                requestHeaders.setContentType(__spreadArray([type || 'multipart/form-data'], tokens, true).join('; '));\n            }\n        }\n        var request = new XMLHttpRequest();\n        // HTTP basic authentication\n        if (config.auth) {\n            var username = config.auth.username || '';\n            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n            requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));\n        }\n        var fullPath = (0, buildFullPath_js_1.default)(config.baseURL, config.url);\n        request.open(config.method.toUpperCase(), (0, buildURL_js_1.default)(fullPath, config.params, config.paramsSerializer), true);\n        // Set the request timeout in MS\n        request.timeout = config.timeout;\n        function onloadend() {\n            if (!request) {\n                return;\n            }\n            // Prepare the response\n            var responseHeaders = AxiosHeaders_js_1.default.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());\n            var responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n                request.responseText : request.response;\n            var response = {\n                data: responseData,\n                status: request.status,\n                statusText: request.statusText,\n                headers: responseHeaders,\n                config: config,\n                request: request\n            };\n            (0, settle_js_1.default)(function _resolve(value) {\n                resolve(value);\n                done();\n            }, function _reject(err) {\n                reject(err);\n                done();\n            }, response);\n            // Clean up request\n            request = null;\n        }\n        if ('onloadend' in request) {\n            // Use onloadend if available\n            request.onloadend = onloadend;\n        }\n        else {\n            // Listen for ready state to emulate onloadend\n            request.onreadystatechange = function handleLoad() {\n                if (!request || request.readyState !== 4) {\n                    return;\n                }\n                // The request errored out and we didn't get a response, this will be\n                // handled by onerror instead\n                // With one exception: request that using file: protocol, most browsers\n                // will return status as 0 even though it's a successful request\n                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n                    return;\n                }\n                // readystate handler is calling before onerror or ontimeout handlers,\n                // so we should call onloadend on the next 'tick'\n                setTimeout(onloadend);\n            };\n        }\n        // Handle browser request cancellation (as opposed to a manual cancellation)\n        request.onabort = function handleAbort() {\n            if (!request) {\n                return;\n            }\n            reject(new AxiosError_js_1.default('Request aborted', AxiosError_js_1.default.ECONNABORTED, config, request));\n            // Clean up request\n            request = null;\n        };\n        // Handle low level network errors\n        request.onerror = function handleError() {\n            // Real errors are hidden from us by the browser\n            // onerror should only fire if it's a network error\n            reject(new AxiosError_js_1.default('Network Error', AxiosError_js_1.default.ERR_NETWORK, config, request));\n            // Clean up request\n            request = null;\n        };\n        // Handle timeout\n        request.ontimeout = function handleTimeout() {\n            var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n            var transitional = config.transitional || transitional_js_1.default;\n            if (config.timeoutErrorMessage) {\n                timeoutErrorMessage = config.timeoutErrorMessage;\n            }\n            reject(new AxiosError_js_1.default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_js_1.default.ETIMEDOUT : AxiosError_js_1.default.ECONNABORTED, config, request));\n            // Clean up request\n            request = null;\n        };\n        // Add xsrf header\n        // This is only done if running in a standard browser environment.\n        // Specifically not if we're in a web worker, or react-native.\n        if (index_js_1.default.hasStandardBrowserEnv) {\n            withXSRFToken && utils_js_1.default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n            if (withXSRFToken || (withXSRFToken !== false && (0, isURLSameOrigin_js_1.default)(fullPath))) {\n                // Add xsrf header\n                var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_js_1.default.read(config.xsrfCookieName);\n                if (xsrfValue) {\n                    requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n                }\n            }\n        }\n        // Remove Content-Type if data is undefined\n        requestData === undefined && requestHeaders.setContentType(null);\n        // Add headers to the request\n        if ('setRequestHeader' in request) {\n            utils_js_1.default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n                request.setRequestHeader(key, val);\n            });\n        }\n        // Add withCredentials to request if needed\n        if (!utils_js_1.default.isUndefined(config.withCredentials)) {\n            request.withCredentials = !!config.withCredentials;\n        }\n        // Add responseType to request if needed\n        if (responseType && responseType !== 'json') {\n            request.responseType = config.responseType;\n        }\n        // Handle progress if needed\n        if (typeof config.onDownloadProgress === 'function') {\n            request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));\n        }\n        // Not all browsers support upload events\n        if (typeof config.onUploadProgress === 'function' && request.upload) {\n            request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));\n        }\n        if (config.cancelToken || config.signal) {\n            // Handle cancellation\n            // eslint-disable-next-line func-names\n            onCanceled = function (cancel) {\n                if (!request) {\n                    return;\n                }\n                reject(!cancel || cancel.type ? new CanceledError_js_1.default(null, config, request) : cancel);\n                request.abort();\n                request = null;\n            };\n            config.cancelToken && config.cancelToken.subscribe(onCanceled);\n            if (config.signal) {\n                config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n            }\n        }\n        var protocol = (0, parseProtocol_js_1.default)(fullPath);\n        if (protocol && index_js_1.default.protocols.indexOf(protocol) === -1) {\n            reject(new AxiosError_js_1.default('Unsupported protocol ' + protocol + ':', AxiosError_js_1.default.ERR_BAD_REQUEST, config));\n            return;\n        }\n        // Send the request\n        request.send(requestData || null);\n    });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar bind_js_1 = __importDefault(__webpack_require__(/*! ./helpers/bind.js */ \"./node_modules/axios/lib/helpers/bind.js\"));\nvar Axios_js_1 = __importDefault(__webpack_require__(/*! ./core/Axios.js */ \"./node_modules/axios/lib/core/Axios.js\"));\nvar mergeConfig_js_1 = __importDefault(__webpack_require__(/*! ./core/mergeConfig.js */ \"./node_modules/axios/lib/core/mergeConfig.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ./defaults/index.js */ \"./node_modules/axios/lib/defaults/index.js\"));\nvar formDataToJSON_js_1 = __importDefault(__webpack_require__(/*! ./helpers/formDataToJSON.js */ \"./node_modules/axios/lib/helpers/formDataToJSON.js\"));\nvar CanceledError_js_1 = __importDefault(__webpack_require__(/*! ./cancel/CanceledError.js */ \"./node_modules/axios/lib/cancel/CanceledError.js\"));\nvar CancelToken_js_1 = __importDefault(__webpack_require__(/*! ./cancel/CancelToken.js */ \"./node_modules/axios/lib/cancel/CancelToken.js\"));\nvar isCancel_js_1 = __importDefault(__webpack_require__(/*! ./cancel/isCancel.js */ \"./node_modules/axios/lib/cancel/isCancel.js\"));\nvar data_js_1 = __webpack_require__(/*! ./env/data.js */ \"./node_modules/axios/lib/env/data.js\");\nvar toFormData_js_1 = __importDefault(__webpack_require__(/*! ./helpers/toFormData.js */ \"./node_modules/axios/lib/helpers/toFormData.js\"));\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ./core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\nvar spread_js_1 = __importDefault(__webpack_require__(/*! ./helpers/spread.js */ \"./node_modules/axios/lib/helpers/spread.js\"));\nvar isAxiosError_js_1 = __importDefault(__webpack_require__(/*! ./helpers/isAxiosError.js */ \"./node_modules/axios/lib/helpers/isAxiosError.js\"));\nvar AxiosHeaders_js_1 = __importDefault(__webpack_require__(/*! ./core/AxiosHeaders.js */ \"./node_modules/axios/lib/core/AxiosHeaders.js\"));\nvar adapters_js_1 = __importDefault(__webpack_require__(/*! ./adapters/adapters.js */ \"./node_modules/axios/lib/adapters/adapters.js\"));\nvar HttpStatusCode_js_1 = __importDefault(__webpack_require__(/*! ./helpers/HttpStatusCode.js */ \"./node_modules/axios/lib/helpers/HttpStatusCode.js\"));\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n    var context = new Axios_js_1.default(defaultConfig);\n    var instance = (0, bind_js_1.default)(Axios_js_1.default.prototype.request, context);\n    // Copy axios.prototype to instance\n    utils_js_1.default.extend(instance, Axios_js_1.default.prototype, context, { allOwnKeys: true });\n    // Copy context to instance\n    utils_js_1.default.extend(instance, context, null, { allOwnKeys: true });\n    // Factory for creating new instances\n    instance.create = function create(instanceConfig) {\n        return createInstance((0, mergeConfig_js_1.default)(defaultConfig, instanceConfig));\n    };\n    return instance;\n}\n// Create the default instance to be exported\nvar axios = createInstance(index_js_1.default);\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios_js_1.default;\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError_js_1.default;\naxios.CancelToken = CancelToken_js_1.default;\naxios.isCancel = isCancel_js_1.default;\naxios.VERSION = data_js_1.VERSION;\naxios.toFormData = toFormData_js_1.default;\n// Expose AxiosError class\naxios.AxiosError = AxiosError_js_1.default;\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n// Expose all/spread\naxios.all = function all(promises) {\n    return Promise.all(promises);\n};\naxios.spread = spread_js_1.default;\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError_js_1.default;\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig_js_1.default;\naxios.AxiosHeaders = AxiosHeaders_js_1.default;\naxios.formToJSON = function (thing) { return (0, formDataToJSON_js_1.default)(utils_js_1.default.isHTMLForm(thing) ? new FormData(thing) : thing); };\naxios.getAdapter = adapters_js_1.default.getAdapter;\naxios.HttpStatusCode = HttpStatusCode_js_1.default;\naxios.default = axios;\n// this module should only have a default export\nexports.default = axios;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CanceledError_js_1 = __importDefault(__webpack_require__(/*! ./CanceledError.js */ \"./node_modules/axios/lib/cancel/CanceledError.js\"));\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nvar CancelToken = /** @class */ (function () {\n    function CancelToken(executor) {\n        if (typeof executor !== 'function') {\n            throw new TypeError('executor must be a function.');\n        }\n        var resolvePromise;\n        this.promise = new Promise(function promiseExecutor(resolve) {\n            resolvePromise = resolve;\n        });\n        var token = this;\n        // eslint-disable-next-line func-names\n        this.promise.then(function (cancel) {\n            if (!token._listeners)\n                return;\n            var i = token._listeners.length;\n            while (i-- > 0) {\n                token._listeners[i](cancel);\n            }\n            token._listeners = null;\n        });\n        // eslint-disable-next-line func-names\n        this.promise.then = function (onfulfilled) {\n            var _resolve;\n            // eslint-disable-next-line func-names\n            var promise = new Promise(function (resolve) {\n                token.subscribe(resolve);\n                _resolve = resolve;\n            }).then(onfulfilled);\n            promise.cancel = function reject() {\n                token.unsubscribe(_resolve);\n            };\n            return promise;\n        };\n        executor(function cancel(message, config, request) {\n            if (token.reason) {\n                // Cancellation has already been requested\n                return;\n            }\n            token.reason = new CanceledError_js_1.default(message, config, request);\n            resolvePromise(token.reason);\n        });\n    }\n    /**\n     * Throws a `CanceledError` if cancellation has been requested.\n     */\n    CancelToken.prototype.throwIfRequested = function () {\n        if (this.reason) {\n            throw this.reason;\n        }\n    };\n    /**\n     * Subscribe to the cancel signal\n     */\n    CancelToken.prototype.subscribe = function (listener) {\n        if (this.reason) {\n            listener(this.reason);\n            return;\n        }\n        if (this._listeners) {\n            this._listeners.push(listener);\n        }\n        else {\n            this._listeners = [listener];\n        }\n    };\n    /**\n     * Unsubscribe from the cancel signal\n     */\n    CancelToken.prototype.unsubscribe = function (listener) {\n        if (!this._listeners) {\n            return;\n        }\n        var index = this._listeners.indexOf(listener);\n        if (index !== -1) {\n            this._listeners.splice(index, 1);\n        }\n    };\n    /**\n     * Returns an object that contains a new `CancelToken` and a function that, when called,\n     * cancels the `CancelToken`.\n     */\n    CancelToken.source = function () {\n        var cancel;\n        var token = new CancelToken(function executor(c) {\n            cancel = c;\n        });\n        return {\n            token: token,\n            cancel: cancel\n        };\n    };\n    return CancelToken;\n}());\nexports.default = CancelToken;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    AxiosError_js_1.default.call(this, message == null ? 'canceled' : message, AxiosError_js_1.default.ERR_CANCELED, config, request);\n    this.name = 'CanceledError';\n}\nutils_js_1.default.inherits(CanceledError, AxiosError_js_1.default, {\n    __CANCEL__: true\n});\nexports.default = CanceledError;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CanceledError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isCancel(value) {\n    return !!(value && value.__CANCEL__);\n}\nexports.default = isCancel;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar buildURL_js_1 = __importDefault(__webpack_require__(/*! ../helpers/buildURL.js */ \"./node_modules/axios/lib/helpers/buildURL.js\"));\nvar InterceptorManager_js_1 = __importDefault(__webpack_require__(/*! ./InterceptorManager.js */ \"./node_modules/axios/lib/core/InterceptorManager.js\"));\nvar dispatchRequest_js_1 = __importDefault(__webpack_require__(/*! ./dispatchRequest.js */ \"./node_modules/axios/lib/core/dispatchRequest.js\"));\nvar mergeConfig_js_1 = __importDefault(__webpack_require__(/*! ./mergeConfig.js */ \"./node_modules/axios/lib/core/mergeConfig.js\"));\nvar buildFullPath_js_1 = __importDefault(__webpack_require__(/*! ./buildFullPath.js */ \"./node_modules/axios/lib/core/buildFullPath.js\"));\nvar validator_js_1 = __importDefault(__webpack_require__(/*! ../helpers/validator.js */ \"./node_modules/axios/lib/helpers/validator.js\"));\nvar AxiosHeaders_js_1 = __importDefault(__webpack_require__(/*! ./AxiosHeaders.js */ \"./node_modules/axios/lib/core/AxiosHeaders.js\"));\nvar validators = validator_js_1.default.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nvar Axios = /** @class */ (function () {\n    function Axios(instanceConfig) {\n        this.defaults = instanceConfig;\n        this.interceptors = {\n            request: new InterceptorManager_js_1.default(),\n            response: new InterceptorManager_js_1.default()\n        };\n    }\n    /**\n     * Dispatch a request\n     *\n     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n     * @param {?Object} config\n     *\n     * @returns {Promise} The Promise to be fulfilled\n     */\n    Axios.prototype.request = function (configOrUrl, config) {\n        /*eslint no-param-reassign:0*/\n        // Allow for axios('example/url'[, config]) a la fetch API\n        if (typeof configOrUrl === 'string') {\n            config = config || {};\n            config.url = configOrUrl;\n        }\n        else {\n            config = configOrUrl || {};\n        }\n        config = (0, mergeConfig_js_1.default)(this.defaults, config);\n        var transitional = config.transitional, paramsSerializer = config.paramsSerializer, headers = config.headers;\n        if (transitional !== undefined) {\n            validator_js_1.default.assertOptions(transitional, {\n                silentJSONParsing: validators.transitional(validators.boolean),\n                forcedJSONParsing: validators.transitional(validators.boolean),\n                clarifyTimeoutError: validators.transitional(validators.boolean)\n            }, false);\n        }\n        if (paramsSerializer != null) {\n            if (utils_js_1.default.isFunction(paramsSerializer)) {\n                config.paramsSerializer = {\n                    serialize: paramsSerializer\n                };\n            }\n            else {\n                validator_js_1.default.assertOptions(paramsSerializer, {\n                    encode: validators.function,\n                    serialize: validators.function\n                }, true);\n            }\n        }\n        // Set config.method\n        config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n        // Flatten headers\n        var contextHeaders = headers && utils_js_1.default.merge(headers.common, headers[config.method]);\n        headers && utils_js_1.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function (method) {\n            delete headers[method];\n        });\n        config.headers = AxiosHeaders_js_1.default.concat(contextHeaders, headers);\n        // filter out skipped interceptors\n        var requestInterceptorChain = [];\n        var synchronousRequestInterceptors = true;\n        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n            if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n                return;\n            }\n            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n        });\n        var responseInterceptorChain = [];\n        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n        });\n        var promise;\n        var i = 0;\n        var len;\n        if (!synchronousRequestInterceptors) {\n            var chain = [dispatchRequest_js_1.default.bind(this), undefined];\n            chain.unshift.apply(chain, requestInterceptorChain);\n            chain.push.apply(chain, responseInterceptorChain);\n            len = chain.length;\n            promise = Promise.resolve(config);\n            while (i < len) {\n                promise = promise.then(chain[i++], chain[i++]);\n            }\n            return promise;\n        }\n        len = requestInterceptorChain.length;\n        var newConfig = config;\n        i = 0;\n        while (i < len) {\n            var onFulfilled = requestInterceptorChain[i++];\n            var onRejected = requestInterceptorChain[i++];\n            try {\n                newConfig = onFulfilled(newConfig);\n            }\n            catch (error) {\n                onRejected.call(this, error);\n                break;\n            }\n        }\n        try {\n            promise = dispatchRequest_js_1.default.call(this, newConfig);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n        i = 0;\n        len = responseInterceptorChain.length;\n        while (i < len) {\n            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n        }\n        return promise;\n    };\n    Axios.prototype.getUri = function (config) {\n        config = (0, mergeConfig_js_1.default)(this.defaults, config);\n        var fullPath = (0, buildFullPath_js_1.default)(config.baseURL, config.url);\n        return (0, buildURL_js_1.default)(fullPath, config.params, config.paramsSerializer);\n    };\n    return Axios;\n}());\n// Provide aliases for supported request methods\nutils_js_1.default.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n    /*eslint func-names:0*/\n    Axios.prototype[method] = function (url, config) {\n        return this.request((0, mergeConfig_js_1.default)(config || {}, {\n            method: method,\n            url: url,\n            data: (config || {}).data\n        }));\n    };\n});\nutils_js_1.default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n    /*eslint func-names:0*/\n    function generateHTTPMethod(isForm) {\n        return function httpMethod(url, data, config) {\n            return this.request((0, mergeConfig_js_1.default)(config || {}, {\n                method: method,\n                headers: isForm ? {\n                    'Content-Type': 'multipart/form-data'\n                } : {},\n                url: url,\n                data: data\n            }));\n        };\n    }\n    Axios.prototype[method] = generateHTTPMethod();\n    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\nexports.default = Axios;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n    Error.call(this);\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n    else {\n        this.stack = (new Error()).stack;\n    }\n    this.message = message;\n    this.name = 'AxiosError';\n    code && (this.code = code);\n    config && (this.config = config);\n    request && (this.request = request);\n    response && (this.response = response);\n}\nutils_js_1.default.inherits(AxiosError, Error, {\n    toJSON: function toJSON() {\n        return {\n            // Standard\n            message: this.message,\n            name: this.name,\n            // Microsoft\n            description: this.description,\n            number: this.number,\n            // Mozilla\n            fileName: this.fileName,\n            lineNumber: this.lineNumber,\n            columnNumber: this.columnNumber,\n            stack: this.stack,\n            // Axios\n            config: utils_js_1.default.toJSONObject(this.config),\n            code: this.code,\n            status: this.response && this.response.status ? this.response.status : null\n        };\n    }\n});\nvar prototype = AxiosError.prototype;\nvar descriptors = {};\n[\n    'ERR_BAD_OPTION_VALUE',\n    'ERR_BAD_OPTION',\n    'ECONNABORTED',\n    'ETIMEDOUT',\n    'ERR_NETWORK',\n    'ERR_FR_TOO_MANY_REDIRECTS',\n    'ERR_DEPRECATED',\n    'ERR_BAD_RESPONSE',\n    'ERR_BAD_REQUEST',\n    'ERR_CANCELED',\n    'ERR_NOT_SUPPORT',\n    'ERR_INVALID_URL'\n    // eslint-disable-next-line func-names\n].forEach(function (code) {\n    descriptors[code] = { value: code };\n});\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', { value: true });\n// eslint-disable-next-line func-names\nAxiosError.from = function (error, code, config, request, response, customProps) {\n    var axiosError = Object.create(prototype);\n    utils_js_1.default.toFlatObject(error, axiosError, function filter(obj) {\n        return obj !== Error.prototype;\n    }, function (prop) {\n        return prop !== 'isAxiosError';\n    });\n    AxiosError.call(axiosError, error.message, code, config, request, response);\n    axiosError.cause = error;\n    axiosError.name = error.name;\n    customProps && Object.assign(axiosError, customProps);\n    return axiosError;\n};\nexports.default = AxiosError;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/AxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosHeaders.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar parseHeaders_js_1 = __importDefault(__webpack_require__(/*! ../helpers/parseHeaders.js */ \"./node_modules/axios/lib/helpers/parseHeaders.js\"));\nvar $internals = Symbol('internals');\nfunction normalizeHeader(header) {\n    return header && String(header).trim().toLowerCase();\n}\nfunction normalizeValue(value) {\n    if (value === false || value == null) {\n        return value;\n    }\n    return utils_js_1.default.isArray(value) ? value.map(normalizeValue) : String(value);\n}\nfunction parseTokens(str) {\n    var tokens = Object.create(null);\n    var tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n    var match;\n    while ((match = tokensRE.exec(str))) {\n        tokens[match[1]] = match[2];\n    }\n    return tokens;\n}\nvar isValidHeaderName = function (str) { return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim()); };\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n    if (utils_js_1.default.isFunction(filter)) {\n        return filter.call(this, value, header);\n    }\n    if (isHeaderNameFilter) {\n        value = header;\n    }\n    if (!utils_js_1.default.isString(value))\n        return;\n    if (utils_js_1.default.isString(filter)) {\n        return value.indexOf(filter) !== -1;\n    }\n    if (utils_js_1.default.isRegExp(filter)) {\n        return filter.test(value);\n    }\n}\nfunction formatHeader(header) {\n    return header.trim()\n        .toLowerCase().replace(/([a-z\\d])(\\w*)/g, function (w, char, str) {\n        return char.toUpperCase() + str;\n    });\n}\nfunction buildAccessors(obj, header) {\n    var accessorName = utils_js_1.default.toCamelCase(' ' + header);\n    ['get', 'set', 'has'].forEach(function (methodName) {\n        Object.defineProperty(obj, methodName + accessorName, {\n            value: function (arg1, arg2, arg3) {\n                return this[methodName].call(this, header, arg1, arg2, arg3);\n            },\n            configurable: true\n        });\n    });\n}\nvar AxiosHeaders = /** @class */ (function () {\n    function AxiosHeaders(headers) {\n        headers && this.set(headers);\n    }\n    AxiosHeaders.prototype.set = function (header, valueOrRewrite, rewrite) {\n        var self = this;\n        function setHeader(_value, _header, _rewrite) {\n            var lHeader = normalizeHeader(_header);\n            if (!lHeader) {\n                throw new Error('header name must be a non-empty string');\n            }\n            var key = utils_js_1.default.findKey(self, lHeader);\n            if (!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n                self[key || _header] = normalizeValue(_value);\n            }\n        }\n        var setHeaders = function (headers, _rewrite) {\n            return utils_js_1.default.forEach(headers, function (_value, _header) { return setHeader(_value, _header, _rewrite); });\n        };\n        if (utils_js_1.default.isPlainObject(header) || header instanceof this.constructor) {\n            setHeaders(header, valueOrRewrite);\n        }\n        else if (utils_js_1.default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n            setHeaders((0, parseHeaders_js_1.default)(header), valueOrRewrite);\n        }\n        else {\n            header != null && setHeader(valueOrRewrite, header, rewrite);\n        }\n        return this;\n    };\n    AxiosHeaders.prototype.get = function (header, parser) {\n        header = normalizeHeader(header);\n        if (header) {\n            var key = utils_js_1.default.findKey(this, header);\n            if (key) {\n                var value = this[key];\n                if (!parser) {\n                    return value;\n                }\n                if (parser === true) {\n                    return parseTokens(value);\n                }\n                if (utils_js_1.default.isFunction(parser)) {\n                    return parser.call(this, value, key);\n                }\n                if (utils_js_1.default.isRegExp(parser)) {\n                    return parser.exec(value);\n                }\n                throw new TypeError('parser must be boolean|regexp|function');\n            }\n        }\n    };\n    AxiosHeaders.prototype.has = function (header, matcher) {\n        header = normalizeHeader(header);\n        if (header) {\n            var key = utils_js_1.default.findKey(this, header);\n            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n        }\n        return false;\n    };\n    AxiosHeaders.prototype.delete = function (header, matcher) {\n        var self = this;\n        var deleted = false;\n        function deleteHeader(_header) {\n            _header = normalizeHeader(_header);\n            if (_header) {\n                var key = utils_js_1.default.findKey(self, _header);\n                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n                    delete self[key];\n                    deleted = true;\n                }\n            }\n        }\n        if (utils_js_1.default.isArray(header)) {\n            header.forEach(deleteHeader);\n        }\n        else {\n            deleteHeader(header);\n        }\n        return deleted;\n    };\n    AxiosHeaders.prototype.clear = function (matcher) {\n        var keys = Object.keys(this);\n        var i = keys.length;\n        var deleted = false;\n        while (i--) {\n            var key = keys[i];\n            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n                delete this[key];\n                deleted = true;\n            }\n        }\n        return deleted;\n    };\n    AxiosHeaders.prototype.normalize = function (format) {\n        var self = this;\n        var headers = {};\n        utils_js_1.default.forEach(this, function (value, header) {\n            var key = utils_js_1.default.findKey(headers, header);\n            if (key) {\n                self[key] = normalizeValue(value);\n                delete self[header];\n                return;\n            }\n            var normalized = format ? formatHeader(header) : String(header).trim();\n            if (normalized !== header) {\n                delete self[header];\n            }\n            self[normalized] = normalizeValue(value);\n            headers[normalized] = true;\n        });\n        return this;\n    };\n    AxiosHeaders.prototype.concat = function () {\n        var _a;\n        var targets = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            targets[_i] = arguments[_i];\n        }\n        return (_a = this.constructor).concat.apply(_a, __spreadArray([this], targets, false));\n    };\n    AxiosHeaders.prototype.toJSON = function (asStrings) {\n        var obj = Object.create(null);\n        utils_js_1.default.forEach(this, function (value, header) {\n            value != null && value !== false && (obj[header] = asStrings && utils_js_1.default.isArray(value) ? value.join(', ') : value);\n        });\n        return obj;\n    };\n    AxiosHeaders.prototype[Symbol.iterator] = function () {\n        return Object.entries(this.toJSON())[Symbol.iterator]();\n    };\n    AxiosHeaders.prototype.toString = function () {\n        return Object.entries(this.toJSON()).map(function (_a) {\n            var header = _a[0], value = _a[1];\n            return header + ': ' + value;\n        }).join('\\n');\n    };\n    Object.defineProperty(AxiosHeaders.prototype, Symbol.toStringTag, {\n        get: function () {\n            return 'AxiosHeaders';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    AxiosHeaders.from = function (thing) {\n        return thing instanceof this ? thing : new this(thing);\n    };\n    AxiosHeaders.concat = function (first) {\n        var targets = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            targets[_i - 1] = arguments[_i];\n        }\n        var computed = new this(first);\n        targets.forEach(function (target) { return computed.set(target); });\n        return computed;\n    };\n    AxiosHeaders.accessor = function (header) {\n        var internals = this[$internals] = (this[$internals] = {\n            accessors: {}\n        });\n        var accessors = internals.accessors;\n        var prototype = this.prototype;\n        function defineAccessor(_header) {\n            var lHeader = normalizeHeader(_header);\n            if (!accessors[lHeader]) {\n                buildAccessors(prototype, _header);\n                accessors[lHeader] = true;\n            }\n        }\n        utils_js_1.default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n        return this;\n    };\n    return AxiosHeaders;\n}());\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n// reserved names hotfix\nutils_js_1.default.reduceDescriptors(AxiosHeaders.prototype, function (_a, key) {\n    var value = _a.value;\n    var mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n    return {\n        get: function () { return value; },\n        set: function (headerValue) {\n            this[mapped] = headerValue;\n        }\n    };\n});\nutils_js_1.default.freezeMethods(AxiosHeaders);\nexports.default = AxiosHeaders;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/AxiosHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar InterceptorManager = /** @class */ (function () {\n    function InterceptorManager() {\n        this.handlers = [];\n    }\n    /**\n     * Add a new interceptor to the stack\n     *\n     * @param {Function} fulfilled The function to handle `then` for a `Promise`\n     * @param {Function} rejected The function to handle `reject` for a `Promise`\n     *\n     * @return {Number} An ID used to remove interceptor later\n     */\n    InterceptorManager.prototype.use = function (fulfilled, rejected, options) {\n        this.handlers.push({\n            fulfilled: fulfilled,\n            rejected: rejected,\n            synchronous: options ? options.synchronous : false,\n            runWhen: options ? options.runWhen : null\n        });\n        return this.handlers.length - 1;\n    };\n    /**\n     * Remove an interceptor from the stack\n     *\n     * @param {Number} id The ID that was returned by `use`\n     *\n     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n     */\n    InterceptorManager.prototype.eject = function (id) {\n        if (this.handlers[id]) {\n            this.handlers[id] = null;\n        }\n    };\n    /**\n     * Clear all interceptors from the stack\n     *\n     * @returns {void}\n     */\n    InterceptorManager.prototype.clear = function () {\n        if (this.handlers) {\n            this.handlers = [];\n        }\n    };\n    /**\n     * Iterate over all the registered interceptors\n     *\n     * This method is particularly useful for skipping over any\n     * interceptors that may have become `null` calling `eject`.\n     *\n     * @param {Function} fn The function to call for each interceptor\n     *\n     * @returns {void}\n     */\n    InterceptorManager.prototype.forEach = function (fn) {\n        utils_js_1.default.forEach(this.handlers, function forEachHandler(h) {\n            if (h !== null) {\n                fn(h);\n            }\n        });\n    };\n    return InterceptorManager;\n}());\nexports.default = InterceptorManager;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isAbsoluteURL_js_1 = __importDefault(__webpack_require__(/*! ../helpers/isAbsoluteURL.js */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\"));\nvar combineURLs_js_1 = __importDefault(__webpack_require__(/*! ../helpers/combineURLs.js */ \"./node_modules/axios/lib/helpers/combineURLs.js\"));\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n    if (baseURL && !(0, isAbsoluteURL_js_1.default)(requestedURL)) {\n        return (0, combineURLs_js_1.default)(baseURL, requestedURL);\n    }\n    return requestedURL;\n}\nexports.default = buildFullPath;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar transformData_js_1 = __importDefault(__webpack_require__(/*! ./transformData.js */ \"./node_modules/axios/lib/core/transformData.js\"));\nvar isCancel_js_1 = __importDefault(__webpack_require__(/*! ../cancel/isCancel.js */ \"./node_modules/axios/lib/cancel/isCancel.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../defaults/index.js */ \"./node_modules/axios/lib/defaults/index.js\"));\nvar CanceledError_js_1 = __importDefault(__webpack_require__(/*! ../cancel/CanceledError.js */ \"./node_modules/axios/lib/cancel/CanceledError.js\"));\nvar AxiosHeaders_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosHeaders.js */ \"./node_modules/axios/lib/core/AxiosHeaders.js\"));\nvar adapters_js_1 = __importDefault(__webpack_require__(/*! ../adapters/adapters.js */ \"./node_modules/axios/lib/adapters/adapters.js\"));\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n    if (config.cancelToken) {\n        config.cancelToken.throwIfRequested();\n    }\n    if (config.signal && config.signal.aborted) {\n        throw new CanceledError_js_1.default(null, config);\n    }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n    throwIfCancellationRequested(config);\n    config.headers = AxiosHeaders_js_1.default.from(config.headers);\n    // Transform request data\n    config.data = transformData_js_1.default.call(config, config.transformRequest);\n    if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n        config.headers.setContentType('application/x-www-form-urlencoded', false);\n    }\n    var adapter = adapters_js_1.default.getAdapter(config.adapter || index_js_1.default.adapter);\n    return adapter(config).then(function onAdapterResolution(response) {\n        throwIfCancellationRequested(config);\n        // Transform response data\n        response.data = transformData_js_1.default.call(config, config.transformResponse, response);\n        response.headers = AxiosHeaders_js_1.default.from(response.headers);\n        return response;\n    }, function onAdapterRejection(reason) {\n        if (!(0, isCancel_js_1.default)(reason)) {\n            throwIfCancellationRequested(config);\n            // Transform response data\n            if (reason && reason.response) {\n                reason.response.data = transformData_js_1.default.call(config, config.transformResponse, reason.response);\n                reason.response.headers = AxiosHeaders_js_1.default.from(reason.response.headers);\n            }\n        }\n        return Promise.reject(reason);\n    });\n}\nexports.default = dispatchRequest;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar AxiosHeaders_js_1 = __importDefault(__webpack_require__(/*! ./AxiosHeaders.js */ \"./node_modules/axios/lib/core/AxiosHeaders.js\"));\nvar headersToObject = function (thing) { return thing instanceof AxiosHeaders_js_1.default ? thing.toJSON() : thing; };\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n    // eslint-disable-next-line no-param-reassign\n    config2 = config2 || {};\n    var config = {};\n    function getMergedValue(target, source, caseless) {\n        if (utils_js_1.default.isPlainObject(target) && utils_js_1.default.isPlainObject(source)) {\n            return utils_js_1.default.merge.call({ caseless: caseless }, target, source);\n        }\n        else if (utils_js_1.default.isPlainObject(source)) {\n            return utils_js_1.default.merge({}, source);\n        }\n        else if (utils_js_1.default.isArray(source)) {\n            return source.slice();\n        }\n        return source;\n    }\n    // eslint-disable-next-line consistent-return\n    function mergeDeepProperties(a, b, caseless) {\n        if (!utils_js_1.default.isUndefined(b)) {\n            return getMergedValue(a, b, caseless);\n        }\n        else if (!utils_js_1.default.isUndefined(a)) {\n            return getMergedValue(undefined, a, caseless);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    function valueFromConfig2(a, b) {\n        if (!utils_js_1.default.isUndefined(b)) {\n            return getMergedValue(undefined, b);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    function defaultToConfig2(a, b) {\n        if (!utils_js_1.default.isUndefined(b)) {\n            return getMergedValue(undefined, b);\n        }\n        else if (!utils_js_1.default.isUndefined(a)) {\n            return getMergedValue(undefined, a);\n        }\n    }\n    // eslint-disable-next-line consistent-return\n    function mergeDirectKeys(a, b, prop) {\n        if (prop in config2) {\n            return getMergedValue(a, b);\n        }\n        else if (prop in config1) {\n            return getMergedValue(undefined, a);\n        }\n    }\n    var mergeMap = {\n        url: valueFromConfig2,\n        method: valueFromConfig2,\n        data: valueFromConfig2,\n        baseURL: defaultToConfig2,\n        transformRequest: defaultToConfig2,\n        transformResponse: defaultToConfig2,\n        paramsSerializer: defaultToConfig2,\n        timeout: defaultToConfig2,\n        timeoutMessage: defaultToConfig2,\n        withCredentials: defaultToConfig2,\n        withXSRFToken: defaultToConfig2,\n        adapter: defaultToConfig2,\n        responseType: defaultToConfig2,\n        xsrfCookieName: defaultToConfig2,\n        xsrfHeaderName: defaultToConfig2,\n        onUploadProgress: defaultToConfig2,\n        onDownloadProgress: defaultToConfig2,\n        decompress: defaultToConfig2,\n        maxContentLength: defaultToConfig2,\n        maxBodyLength: defaultToConfig2,\n        beforeRedirect: defaultToConfig2,\n        transport: defaultToConfig2,\n        httpAgent: defaultToConfig2,\n        httpsAgent: defaultToConfig2,\n        cancelToken: defaultToConfig2,\n        socketPath: defaultToConfig2,\n        responseEncoding: defaultToConfig2,\n        validateStatus: mergeDirectKeys,\n        headers: function (a, b) { return mergeDeepProperties(headersToObject(a), headersToObject(b), true); }\n    };\n    utils_js_1.default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n        var merge = mergeMap[prop] || mergeDeepProperties;\n        var configValue = merge(config1[prop], config2[prop], prop);\n        (utils_js_1.default.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n    });\n    return config;\n}\nexports.default = mergeConfig;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ./AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n    var validateStatus = response.config.validateStatus;\n    if (!response.status || !validateStatus || validateStatus(response.status)) {\n        resolve(response);\n    }\n    else {\n        reject(new AxiosError_js_1.default('Request failed with status code ' + response.status, [AxiosError_js_1.default.ERR_BAD_REQUEST, AxiosError_js_1.default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));\n    }\n}\nexports.default = settle;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../defaults/index.js */ \"./node_modules/axios/lib/defaults/index.js\"));\nvar AxiosHeaders_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosHeaders.js */ \"./node_modules/axios/lib/core/AxiosHeaders.js\"));\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n    var config = this || index_js_1.default;\n    var context = response || config;\n    var headers = AxiosHeaders_js_1.default.from(context.headers);\n    var data = context.data;\n    utils_js_1.default.forEach(fns, function transform(fn) {\n        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n    });\n    headers.normalize();\n    return data;\n}\nexports.default = transformData;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\nvar transitional_js_1 = __importDefault(__webpack_require__(/*! ./transitional.js */ \"./node_modules/axios/lib/defaults/transitional.js\"));\nvar toFormData_js_1 = __importDefault(__webpack_require__(/*! ../helpers/toFormData.js */ \"./node_modules/axios/lib/helpers/toFormData.js\"));\nvar toURLEncodedForm_js_1 = __importDefault(__webpack_require__(/*! ../helpers/toURLEncodedForm.js */ \"./node_modules/axios/lib/helpers/toURLEncodedForm.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../platform/index.js */ \"./node_modules/axios/lib/platform/index.js\"));\nvar formDataToJSON_js_1 = __importDefault(__webpack_require__(/*! ../helpers/formDataToJSON.js */ \"./node_modules/axios/lib/helpers/formDataToJSON.js\"));\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n    if (utils_js_1.default.isString(rawValue)) {\n        try {\n            (parser || JSON.parse)(rawValue);\n            return utils_js_1.default.trim(rawValue);\n        }\n        catch (e) {\n            if (e.name !== 'SyntaxError') {\n                throw e;\n            }\n        }\n    }\n    return (encoder || JSON.stringify)(rawValue);\n}\nvar defaults = {\n    transitional: transitional_js_1.default,\n    adapter: ['xhr', 'http'],\n    transformRequest: [function transformRequest(data, headers) {\n            var contentType = headers.getContentType() || '';\n            var hasJSONContentType = contentType.indexOf('application/json') > -1;\n            var isObjectPayload = utils_js_1.default.isObject(data);\n            if (isObjectPayload && utils_js_1.default.isHTMLForm(data)) {\n                data = new FormData(data);\n            }\n            var isFormData = utils_js_1.default.isFormData(data);\n            if (isFormData) {\n                if (!hasJSONContentType) {\n                    return data;\n                }\n                return hasJSONContentType ? JSON.stringify((0, formDataToJSON_js_1.default)(data)) : data;\n            }\n            if (utils_js_1.default.isArrayBuffer(data) ||\n                utils_js_1.default.isBuffer(data) ||\n                utils_js_1.default.isStream(data) ||\n                utils_js_1.default.isFile(data) ||\n                utils_js_1.default.isBlob(data)) {\n                return data;\n            }\n            if (utils_js_1.default.isArrayBufferView(data)) {\n                return data.buffer;\n            }\n            if (utils_js_1.default.isURLSearchParams(data)) {\n                headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n                return data.toString();\n            }\n            var isFileList;\n            if (isObjectPayload) {\n                if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n                    return (0, toURLEncodedForm_js_1.default)(data, this.formSerializer).toString();\n                }\n                if ((isFileList = utils_js_1.default.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n                    var _FormData = this.env && this.env.FormData;\n                    return (0, toFormData_js_1.default)(isFileList ? { 'files[]': data } : data, _FormData && new _FormData(), this.formSerializer);\n                }\n            }\n            if (isObjectPayload || hasJSONContentType) {\n                headers.setContentType('application/json', false);\n                return stringifySafely(data);\n            }\n            return data;\n        }],\n    transformResponse: [function transformResponse(data) {\n            var transitional = this.transitional || defaults.transitional;\n            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n            var JSONRequested = this.responseType === 'json';\n            if (data && utils_js_1.default.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n                var silentJSONParsing = transitional && transitional.silentJSONParsing;\n                var strictJSONParsing = !silentJSONParsing && JSONRequested;\n                try {\n                    return JSON.parse(data);\n                }\n                catch (e) {\n                    if (strictJSONParsing) {\n                        if (e.name === 'SyntaxError') {\n                            throw AxiosError_js_1.default.from(e, AxiosError_js_1.default.ERR_BAD_RESPONSE, this, null, this.response);\n                        }\n                        throw e;\n                    }\n                }\n            }\n            return data;\n        }],\n    /**\n     * A timeout in milliseconds to abort a request. If set to 0 (default) a\n     * timeout is not created.\n     */\n    timeout: 0,\n    xsrfCookieName: 'XSRF-TOKEN',\n    xsrfHeaderName: 'X-XSRF-TOKEN',\n    maxContentLength: -1,\n    maxBodyLength: -1,\n    env: {\n        FormData: index_js_1.default.classes.FormData,\n        Blob: index_js_1.default.classes.Blob\n    },\n    validateStatus: function validateStatus(status) {\n        return status >= 200 && status < 300;\n    },\n    headers: {\n        common: {\n            'Accept': 'application/json, text/plain, */*',\n            'Content-Type': undefined\n        }\n    }\n};\nutils_js_1.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], function (method) {\n    defaults.headers[method] = {};\n});\nexports.default = defaults;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults/transitional.js?");

/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VERSION = void 0;\nexports.VERSION = \"1.6.5\";\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/env/data.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toFormData_js_1 = __importDefault(__webpack_require__(/*! ./toFormData.js */ \"./node_modules/axios/lib/helpers/toFormData.js\"));\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n    var charMap = {\n        '!': '%21',\n        \"'\": '%27',\n        '(': '%28',\n        ')': '%29',\n        '~': '%7E',\n        '%20': '+',\n        '%00': '\\x00'\n    };\n    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n        return charMap[match];\n    });\n}\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n    this._pairs = [];\n    params && (0, toFormData_js_1.default)(params, this, options);\n}\nvar prototype = AxiosURLSearchParams.prototype;\nprototype.append = function append(name, value) {\n    this._pairs.push([name, value]);\n};\nprototype.toString = function toString(encoder) {\n    var _encode = encoder ? function (value) {\n        return encoder.call(this, value, encode);\n    } : encode;\n    return this._pairs.map(function each(pair) {\n        return _encode(pair[0]) + '=' + _encode(pair[1]);\n    }, '').join('&');\n};\nexports.default = AxiosURLSearchParams;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/AxiosURLSearchParams.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/HttpStatusCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HttpStatusCode = {\n    Continue: 100,\n    SwitchingProtocols: 101,\n    Processing: 102,\n    EarlyHints: 103,\n    Ok: 200,\n    Created: 201,\n    Accepted: 202,\n    NonAuthoritativeInformation: 203,\n    NoContent: 204,\n    ResetContent: 205,\n    PartialContent: 206,\n    MultiStatus: 207,\n    AlreadyReported: 208,\n    ImUsed: 226,\n    MultipleChoices: 300,\n    MovedPermanently: 301,\n    Found: 302,\n    SeeOther: 303,\n    NotModified: 304,\n    UseProxy: 305,\n    Unused: 306,\n    TemporaryRedirect: 307,\n    PermanentRedirect: 308,\n    BadRequest: 400,\n    Unauthorized: 401,\n    PaymentRequired: 402,\n    Forbidden: 403,\n    NotFound: 404,\n    MethodNotAllowed: 405,\n    NotAcceptable: 406,\n    ProxyAuthenticationRequired: 407,\n    RequestTimeout: 408,\n    Conflict: 409,\n    Gone: 410,\n    LengthRequired: 411,\n    PreconditionFailed: 412,\n    PayloadTooLarge: 413,\n    UriTooLong: 414,\n    UnsupportedMediaType: 415,\n    RangeNotSatisfiable: 416,\n    ExpectationFailed: 417,\n    ImATeapot: 418,\n    MisdirectedRequest: 421,\n    UnprocessableEntity: 422,\n    Locked: 423,\n    FailedDependency: 424,\n    TooEarly: 425,\n    UpgradeRequired: 426,\n    PreconditionRequired: 428,\n    TooManyRequests: 429,\n    RequestHeaderFieldsTooLarge: 431,\n    UnavailableForLegalReasons: 451,\n    InternalServerError: 500,\n    NotImplemented: 501,\n    BadGateway: 502,\n    ServiceUnavailable: 503,\n    GatewayTimeout: 504,\n    HttpVersionNotSupported: 505,\n    VariantAlsoNegotiates: 506,\n    InsufficientStorage: 507,\n    LoopDetected: 508,\n    NotExtended: 510,\n    NetworkAuthenticationRequired: 511,\n};\nObject.entries(HttpStatusCode).forEach(function (_a) {\n    var key = _a[0], value = _a[1];\n    HttpStatusCode[value] = key;\n});\nexports.default = HttpStatusCode;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/HttpStatusCode.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction bind(fn, thisArg) {\n    return function wrap() {\n        return fn.apply(thisArg, arguments);\n    };\n}\nexports.default = bind;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar AxiosURLSearchParams_js_1 = __importDefault(__webpack_require__(/*! ../helpers/AxiosURLSearchParams.js */ \"./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\"));\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n    return encodeURIComponent(val).\n        replace(/%3A/gi, ':').\n        replace(/%24/g, '$').\n        replace(/%2C/gi, ',').\n        replace(/%20/g, '+').\n        replace(/%5B/gi, '[').\n        replace(/%5D/gi, ']');\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n    /*eslint no-param-reassign:0*/\n    if (!params) {\n        return url;\n    }\n    var _encode = options && options.encode || encode;\n    var serializeFn = options && options.serialize;\n    var serializedParams;\n    if (serializeFn) {\n        serializedParams = serializeFn(params, options);\n    }\n    else {\n        serializedParams = utils_js_1.default.isURLSearchParams(params) ?\n            params.toString() :\n            new AxiosURLSearchParams_js_1.default(params, options).toString(_encode);\n    }\n    if (serializedParams) {\n        var hashmarkIndex = url.indexOf(\"#\");\n        if (hashmarkIndex !== -1) {\n            url = url.slice(0, hashmarkIndex);\n        }\n        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n    }\n    return url;\n}\nexports.default = buildURL;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n    return relativeURL\n        ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n        : baseURL;\n}\nexports.default = combineURLs;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../platform/index.js */ \"./node_modules/axios/lib/platform/index.js\"));\nexports.default = index_js_1.default.hasStandardBrowserEnv ?\n    // Standard browser envs support document.cookie\n    {\n        write: function (name, value, expires, path, domain, secure) {\n            var cookie = [name + '=' + encodeURIComponent(value)];\n            utils_js_1.default.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n            utils_js_1.default.isString(path) && cookie.push('path=' + path);\n            utils_js_1.default.isString(domain) && cookie.push('domain=' + domain);\n            secure === true && cookie.push('secure');\n            document.cookie = cookie.join('; ');\n        },\n        read: function (name) {\n            var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n            return (match ? decodeURIComponent(match[3]) : null);\n        },\n        remove: function (name) {\n            this.write(name, '', Date.now() - 86400000);\n        }\n    }\n    :\n        // Non-standard browser env (web workers, react-native) lack needed support.\n        {\n            write: function () { },\n            read: function () {\n                return null;\n            },\n            remove: function () { }\n        };\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToJSON.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n    // foo[x][y][z]\n    // foo.x.y.z\n    // foo-x-y-z\n    // foo x y z\n    return utils_js_1.default.matchAll(/\\w+|\\[(\\w*)]/g, name).map(function (match) {\n        return match[0] === '[]' ? '' : match[1] || match[0];\n    });\n}\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n    var obj = {};\n    var keys = Object.keys(arr);\n    var i;\n    var len = keys.length;\n    var key;\n    for (i = 0; i < len; i++) {\n        key = keys[i];\n        obj[key] = arr[key];\n    }\n    return obj;\n}\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n    function buildPath(path, value, target, index) {\n        var name = path[index++];\n        if (name === '__proto__')\n            return true;\n        var isNumericKey = Number.isFinite(+name);\n        var isLast = index >= path.length;\n        name = !name && utils_js_1.default.isArray(target) ? target.length : name;\n        if (isLast) {\n            if (utils_js_1.default.hasOwnProp(target, name)) {\n                target[name] = [target[name], value];\n            }\n            else {\n                target[name] = value;\n            }\n            return !isNumericKey;\n        }\n        if (!target[name] || !utils_js_1.default.isObject(target[name])) {\n            target[name] = [];\n        }\n        var result = buildPath(path, value, target[name], index);\n        if (result && utils_js_1.default.isArray(target[name])) {\n            target[name] = arrayToObject(target[name]);\n        }\n        return !isNumericKey;\n    }\n    if (utils_js_1.default.isFormData(formData) && utils_js_1.default.isFunction(formData.entries)) {\n        var obj_1 = {};\n        utils_js_1.default.forEachEntry(formData, function (name, value) {\n            buildPath(parsePropPath(name), value, obj_1, 0);\n        });\n        return obj_1;\n    }\n    return null;\n}\nexports.default = formDataToJSON;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/formDataToJSON.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n    // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n    // by any combination of letters, digits, plus, period, or hyphen.\n    return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nexports.default = isAbsoluteURL;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n    return utils_js_1.default.isObject(payload) && (payload.isAxiosError === true);\n}\nexports.default = isAxiosError;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../platform/index.js */ \"./node_modules/axios/lib/platform/index.js\"));\nexports.default = index_js_1.default.hasStandardBrowserEnv ?\n    // Standard browser envs have full support of the APIs needed to test\n    // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n        var msie = /(msie|trident)/i.test(navigator.userAgent);\n        var urlParsingNode = document.createElement('a');\n        var originURL;\n        /**\n        * Parse a URL to discover its components\n        *\n        * @param {String} url The URL to be parsed\n        * @returns {Object}\n        */\n        function resolveURL(url) {\n            var href = url;\n            if (msie) {\n                // IE needs attribute set twice to normalize properties\n                urlParsingNode.setAttribute('href', href);\n                href = urlParsingNode.href;\n            }\n            urlParsingNode.setAttribute('href', href);\n            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n            return {\n                href: urlParsingNode.href,\n                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n                host: urlParsingNode.host,\n                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n                hostname: urlParsingNode.hostname,\n                port: urlParsingNode.port,\n                pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                    urlParsingNode.pathname :\n                    '/' + urlParsingNode.pathname\n            };\n        }\n        originURL = resolveURL(window.location.href);\n        /**\n        * Determine if a URL shares the same origin as the current location\n        *\n        * @param {String} requestURL The URL to test\n        * @returns {boolean} True if URL shares the same origin, otherwise false\n        */\n        return function isURLSameOrigin(requestURL) {\n            var parsed = (utils_js_1.default.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n            return (parsed.protocol === originURL.protocol &&\n                parsed.host === originURL.host);\n        };\n    })() :\n    // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n        return function isURLSameOrigin() {\n            return true;\n        };\n    })();\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// eslint-disable-next-line strict\nexports.default = null;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/null.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ./../utils.js */ \"./node_modules/axios/lib/utils.js\"));\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = utils_js_1.default.toObjectSet([\n    'age', 'authorization', 'content-length', 'content-type', 'etag',\n    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n    'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n    'referer', 'retry-after', 'user-agent'\n]);\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nexports.default = (function (rawHeaders) {\n    var parsed = {};\n    var key;\n    var val;\n    var i;\n    rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n        i = line.indexOf(':');\n        key = line.substring(0, i).trim().toLowerCase();\n        val = line.substring(i + 1).trim();\n        if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n            return;\n        }\n        if (key === 'set-cookie') {\n            if (parsed[key]) {\n                parsed[key].push(val);\n            }\n            else {\n                parsed[key] = [val];\n            }\n        }\n        else {\n            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n        }\n    });\n    return parsed;\n});\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction parseProtocol(url) {\n    var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n    return match && match[1] || '';\n}\nexports.default = parseProtocol;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseProtocol.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/speedometer.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/speedometer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n    samplesCount = samplesCount || 10;\n    var bytes = new Array(samplesCount);\n    var timestamps = new Array(samplesCount);\n    var head = 0;\n    var tail = 0;\n    var firstSampleTS;\n    min = min !== undefined ? min : 1000;\n    return function push(chunkLength) {\n        var now = Date.now();\n        var startedAt = timestamps[tail];\n        if (!firstSampleTS) {\n            firstSampleTS = now;\n        }\n        bytes[head] = chunkLength;\n        timestamps[head] = now;\n        var i = tail;\n        var bytesCount = 0;\n        while (i !== head) {\n            bytesCount += bytes[i++];\n            i = i % samplesCount;\n        }\n        head = (head + 1) % samplesCount;\n        if (head === tail) {\n            tail = (tail + 1) % samplesCount;\n        }\n        if (now - firstSampleTS < min) {\n            return;\n        }\n        var passed = startedAt && now - startedAt;\n        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n    };\n}\nexports.default = speedometer;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/speedometer.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n    return function wrap(arr) {\n        return callback.apply(null, arr);\n    };\n}\nexports.default = spread;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\nvar FormData_js_1 = __importDefault(__webpack_require__(/*! ../platform/node/classes/FormData.js */ \"./node_modules/axios/lib/helpers/null.js\"));\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n    return utils_js_1.default.isPlainObject(thing) || utils_js_1.default.isArray(thing);\n}\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n    return utils_js_1.default.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n    if (!path)\n        return key;\n    return path.concat(key).map(function each(token, i) {\n        // eslint-disable-next-line no-param-reassign\n        token = removeBrackets(token);\n        return !dots && i ? '[' + token + ']' : token;\n    }).join(dots ? '.' : '');\n}\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n    return utils_js_1.default.isArray(arr) && !arr.some(isVisitable);\n}\nvar predicates = utils_js_1.default.toFlatObject(utils_js_1.default, {}, null, function filter(prop) {\n    return /^is[A-Z]/.test(prop);\n});\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n    if (!utils_js_1.default.isObject(obj)) {\n        throw new TypeError('target must be an object');\n    }\n    // eslint-disable-next-line no-param-reassign\n    formData = formData || new (FormData_js_1.default || FormData)();\n    // eslint-disable-next-line no-param-reassign\n    options = utils_js_1.default.toFlatObject(options, {\n        metaTokens: true,\n        dots: false,\n        indexes: false\n    }, false, function defined(option, source) {\n        // eslint-disable-next-line no-eq-null,eqeqeq\n        return !utils_js_1.default.isUndefined(source[option]);\n    });\n    var metaTokens = options.metaTokens;\n    // eslint-disable-next-line no-use-before-define\n    var visitor = options.visitor || defaultVisitor;\n    var dots = options.dots;\n    var indexes = options.indexes;\n    var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n    var useBlob = _Blob && utils_js_1.default.isSpecCompliantForm(formData);\n    if (!utils_js_1.default.isFunction(visitor)) {\n        throw new TypeError('visitor must be a function');\n    }\n    function convertValue(value) {\n        if (value === null)\n            return '';\n        if (utils_js_1.default.isDate(value)) {\n            return value.toISOString();\n        }\n        if (!useBlob && utils_js_1.default.isBlob(value)) {\n            throw new AxiosError_js_1.default('Blob is not supported. Use a Buffer instead.');\n        }\n        if (utils_js_1.default.isArrayBuffer(value) || utils_js_1.default.isTypedArray(value)) {\n            return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n        }\n        return value;\n    }\n    /**\n     * Default visitor.\n     *\n     * @param {*} value\n     * @param {String|Number} key\n     * @param {Array<String|Number>} path\n     * @this {FormData}\n     *\n     * @returns {boolean} return true to visit the each prop of the value recursively\n     */\n    function defaultVisitor(value, key, path) {\n        var arr = value;\n        if (value && !path && typeof value === 'object') {\n            if (utils_js_1.default.endsWith(key, '{}')) {\n                // eslint-disable-next-line no-param-reassign\n                key = metaTokens ? key : key.slice(0, -2);\n                // eslint-disable-next-line no-param-reassign\n                value = JSON.stringify(value);\n            }\n            else if ((utils_js_1.default.isArray(value) && isFlatArray(value)) ||\n                ((utils_js_1.default.isFileList(value) || utils_js_1.default.endsWith(key, '[]')) && (arr = utils_js_1.default.toArray(value)))) {\n                // eslint-disable-next-line no-param-reassign\n                key = removeBrackets(key);\n                arr.forEach(function each(el, index) {\n                    !(utils_js_1.default.isUndefined(el) || el === null) && formData.append(\n                    // eslint-disable-next-line no-nested-ternary\n                    indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'), convertValue(el));\n                });\n                return false;\n            }\n        }\n        if (isVisitable(value)) {\n            return true;\n        }\n        formData.append(renderKey(path, key, dots), convertValue(value));\n        return false;\n    }\n    var stack = [];\n    var exposedHelpers = Object.assign(predicates, {\n        defaultVisitor: defaultVisitor,\n        convertValue: convertValue,\n        isVisitable: isVisitable\n    });\n    function build(value, path) {\n        if (utils_js_1.default.isUndefined(value))\n            return;\n        if (stack.indexOf(value) !== -1) {\n            throw Error('Circular reference detected in ' + path.join('.'));\n        }\n        stack.push(value);\n        utils_js_1.default.forEach(value, function each(el, key) {\n            var result = !(utils_js_1.default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_js_1.default.isString(key) ? key.trim() : key, path, exposedHelpers);\n            if (result === true) {\n                build(el, path ? path.concat(key) : [key]);\n            }\n        });\n        stack.pop();\n    }\n    if (!utils_js_1.default.isObject(obj)) {\n        throw new TypeError('data must be an object');\n    }\n    build(obj);\n    return formData;\n}\nexports.default = toFormData;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/toFormData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/toURLEncodedForm.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_js_1 = __importDefault(__webpack_require__(/*! ../utils.js */ \"./node_modules/axios/lib/utils.js\"));\nvar toFormData_js_1 = __importDefault(__webpack_require__(/*! ./toFormData.js */ \"./node_modules/axios/lib/helpers/toFormData.js\"));\nvar index_js_1 = __importDefault(__webpack_require__(/*! ../platform/index.js */ \"./node_modules/axios/lib/platform/index.js\"));\nfunction toURLEncodedForm(data, options) {\n    return (0, toFormData_js_1.default)(data, new index_js_1.default.classes.URLSearchParams(), Object.assign({\n        visitor: function (value, key, path, helpers) {\n            if (index_js_1.default.isNode && utils_js_1.default.isBuffer(value)) {\n                this.append(key, value.toString('base64'));\n                return false;\n            }\n            return helpers.defaultVisitor.apply(this, arguments);\n        }\n    }, options));\n}\nexports.default = toURLEncodedForm;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/toURLEncodedForm.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_js_1 = __webpack_require__(/*! ../env/data.js */ \"./node_modules/axios/lib/env/data.js\");\nvar AxiosError_js_1 = __importDefault(__webpack_require__(/*! ../core/AxiosError.js */ \"./node_modules/axios/lib/core/AxiosError.js\"));\nvar validators = {};\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {\n    validators[type] = function validator(thing) {\n        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n    };\n});\nvar deprecatedWarnings = {};\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n    function formatMessage(opt, desc) {\n        return '[Axios v' + data_js_1.VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n    }\n    // eslint-disable-next-line func-names\n    return function (value, opt, opts) {\n        if (validator === false) {\n            throw new AxiosError_js_1.default(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError_js_1.default.ERR_DEPRECATED);\n        }\n        if (version && !deprecatedWarnings[opt]) {\n            deprecatedWarnings[opt] = true;\n            // eslint-disable-next-line no-console\n            console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));\n        }\n        return validator ? validator(value, opt, opts) : true;\n    };\n};\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\nfunction assertOptions(options, schema, allowUnknown) {\n    if (typeof options !== 'object') {\n        throw new AxiosError_js_1.default('options must be an object', AxiosError_js_1.default.ERR_BAD_OPTION_VALUE);\n    }\n    var keys = Object.keys(options);\n    var i = keys.length;\n    while (i-- > 0) {\n        var opt = keys[i];\n        var validator = schema[opt];\n        if (validator) {\n            var value = options[opt];\n            var result = value === undefined || validator(value, opt, options);\n            if (result !== true) {\n                throw new AxiosError_js_1.default('option ' + opt + ' must be ' + result, AxiosError_js_1.default.ERR_BAD_OPTION_VALUE);\n            }\n            continue;\n        }\n        if (allowUnknown !== true) {\n            throw new AxiosError_js_1.default('Unknown option ' + opt, AxiosError_js_1.default.ERR_BAD_OPTION);\n        }\n    }\n}\nexports.default = {\n    assertOptions: assertOptions,\n    validators: validators\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/validator.js?");

/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/Blob.js":
/*!*****************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/Blob.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = typeof Blob !== 'undefined' ? Blob : null;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/platform/browser/classes/Blob.js?");

/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/FormData.js":
/*!*********************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/FormData.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = typeof FormData !== 'undefined' ? FormData : null;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/platform/browser/classes/FormData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AxiosURLSearchParams_js_1 = __importDefault(__webpack_require__(/*! ../../../helpers/AxiosURLSearchParams.js */ \"./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\"));\nexports.default = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams_js_1.default;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js?");

/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar URLSearchParams_js_1 = __importDefault(__webpack_require__(/*! ./classes/URLSearchParams.js */ \"./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\"));\nvar FormData_js_1 = __importDefault(__webpack_require__(/*! ./classes/FormData.js */ \"./node_modules/axios/lib/platform/browser/classes/FormData.js\"));\nvar Blob_js_1 = __importDefault(__webpack_require__(/*! ./classes/Blob.js */ \"./node_modules/axios/lib/platform/browser/classes/Blob.js\"));\nexports.default = {\n    isBrowser: true,\n    classes: {\n        URLSearchParams: URLSearchParams_js_1.default,\n        FormData: FormData_js_1.default,\n        Blob: Blob_js_1.default\n    },\n    protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/platform/browser/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/platform/common/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/platform/common/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasStandardBrowserEnv = exports.hasStandardBrowserWebWorkerEnv = exports.hasBrowserEnv = void 0;\nvar hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\nexports.hasBrowserEnv = hasBrowserEnv;\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nvar hasStandardBrowserEnv = (function (product) {\n    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0;\n})(typeof navigator !== 'undefined' && navigator.product);\nexports.hasStandardBrowserEnv = hasStandardBrowserEnv;\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nvar hasStandardBrowserWebWorkerEnv = (function () {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        // eslint-disable-next-line no-undef\n        self instanceof WorkerGlobalScope &&\n        typeof self.importScripts === 'function');\n})();\nexports.hasStandardBrowserWebWorkerEnv = hasStandardBrowserWebWorkerEnv;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/platform/common/utils.js?");

/***/ }),

/***/ "./node_modules/axios/lib/platform/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/platform/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar index_js_1 = __importDefault(__webpack_require__(/*! ./node/index.js */ \"./node_modules/axios/lib/platform/browser/index.js\"));\nvar utils = __importStar(__webpack_require__(/*! ./common/utils.js */ \"./node_modules/axios/lib/platform/common/utils.js\"));\nexports.default = __assign(__assign({}, utils), index_js_1.default);\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/platform/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bind_js_1 = __importDefault(__webpack_require__(/*! ./helpers/bind.js */ \"./node_modules/axios/lib/helpers/bind.js\"));\n// utils is a library of generic helper functions non-specific to axios\nvar toString = Object.prototype.toString;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar kindOf = (function (cache) { return function (thing) {\n    var str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n}; })(Object.create(null));\nvar kindOfTest = function (type) {\n    type = type.toLowerCase();\n    return function (thing) { return kindOf(thing) === type; };\n};\nvar typeOfTest = function (type) { return function (thing) { return typeof thing === type; }; };\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nvar isArray = Array.isArray;\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nvar isUndefined = typeOfTest('undefined');\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n        && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n    var result;\n    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n        result = ArrayBuffer.isView(val);\n    }\n    else {\n        result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n    }\n    return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nvar isString = typeOfTest('string');\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nvar isFunction = typeOfTest('function');\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nvar isNumber = typeOfTest('number');\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nvar isObject = function (thing) { return thing !== null && typeof thing === 'object'; };\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nvar isBoolean = function (thing) { return thing === true || thing === false; };\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nvar isPlainObject = function (val) {\n    if (kindOf(val) !== 'object') {\n        return false;\n    }\n    var prototype = getPrototypeOf(val);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nvar isDate = kindOfTest('Date');\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFile = kindOfTest('File');\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nvar isBlob = kindOfTest('Blob');\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFileList = kindOfTest('FileList');\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nvar isStream = function (val) { return isObject(val) && isFunction(val.pipe); };\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nvar isFormData = function (thing) {\n    var kind;\n    return thing && ((typeof FormData === 'function' && thing instanceof FormData) || (isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'))));\n};\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nvar trim = function (str) { return str.trim ?\n    str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); };\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.allOwnKeys, allOwnKeys = _c === void 0 ? false : _c;\n    // Don't bother if no value provided\n    if (obj === null || typeof obj === 'undefined') {\n        return;\n    }\n    var i;\n    var l;\n    // Force an array if not already something iterable\n    if (typeof obj !== 'object') {\n        /*eslint no-param-reassign:0*/\n        obj = [obj];\n    }\n    if (isArray(obj)) {\n        // Iterate over array values\n        for (i = 0, l = obj.length; i < l; i++) {\n            fn.call(null, obj[i], i, obj);\n        }\n    }\n    else {\n        // Iterate over object keys\n        var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n        var len = keys.length;\n        var key = void 0;\n        for (i = 0; i < len; i++) {\n            key = keys[i];\n            fn.call(null, obj[key], key, obj);\n        }\n    }\n}\nfunction findKey(obj, key) {\n    key = key.toLowerCase();\n    var keys = Object.keys(obj);\n    var i = keys.length;\n    var _key;\n    while (i-- > 0) {\n        _key = keys[i];\n        if (key === _key.toLowerCase()) {\n            return _key;\n        }\n    }\n    return null;\n}\nvar _global = (function () {\n    /*eslint no-undef:0*/\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global);\n})();\nvar isContextDefined = function (context) { return !isUndefined(context) && context !== _global; };\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge( /* obj1, obj2, obj3, ... */) {\n    var caseless = (isContextDefined(this) && this || {}).caseless;\n    var result = {};\n    var assignValue = function (val, key) {\n        var targetKey = caseless && findKey(result, key) || key;\n        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n            result[targetKey] = merge(result[targetKey], val);\n        }\n        else if (isPlainObject(val)) {\n            result[targetKey] = merge({}, val);\n        }\n        else if (isArray(val)) {\n            result[targetKey] = val.slice();\n        }\n        else {\n            result[targetKey] = val;\n        }\n    };\n    for (var i = 0, l = arguments.length; i < l; i++) {\n        arguments[i] && forEach(arguments[i], assignValue);\n    }\n    return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nvar extend = function (a, b, thisArg, _a) {\n    var _b = _a === void 0 ? {} : _a, allOwnKeys = _b.allOwnKeys;\n    forEach(b, function (val, key) {\n        if (thisArg && isFunction(val)) {\n            a[key] = (0, bind_js_1.default)(val, thisArg);\n        }\n        else {\n            a[key] = val;\n        }\n    }, { allOwnKeys: allOwnKeys });\n    return a;\n};\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nvar stripBOM = function (content) {\n    if (content.charCodeAt(0) === 0xFEFF) {\n        content = content.slice(1);\n    }\n    return content;\n};\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nvar inherits = function (constructor, superConstructor, props, descriptors) {\n    constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n    constructor.prototype.constructor = constructor;\n    Object.defineProperty(constructor, 'super', {\n        value: superConstructor.prototype\n    });\n    props && Object.assign(constructor.prototype, props);\n};\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nvar toFlatObject = function (sourceObj, destObj, filter, propFilter) {\n    var props;\n    var i;\n    var prop;\n    var merged = {};\n    destObj = destObj || {};\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    if (sourceObj == null)\n        return destObj;\n    do {\n        props = Object.getOwnPropertyNames(sourceObj);\n        i = props.length;\n        while (i-- > 0) {\n            prop = props[i];\n            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n                destObj[prop] = sourceObj[prop];\n                merged[prop] = true;\n            }\n        }\n        sourceObj = filter !== false && getPrototypeOf(sourceObj);\n    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n    return destObj;\n};\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nvar endsWith = function (str, searchString, position) {\n    str = String(str);\n    if (position === undefined || position > str.length) {\n        position = str.length;\n    }\n    position -= searchString.length;\n    var lastIndex = str.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n};\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nvar toArray = function (thing) {\n    if (!thing)\n        return null;\n    if (isArray(thing))\n        return thing;\n    var i = thing.length;\n    if (!isNumber(i))\n        return null;\n    var arr = new Array(i);\n    while (i-- > 0) {\n        arr[i] = thing[i];\n    }\n    return arr;\n};\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nvar isTypedArray = (function (TypedArray) {\n    // eslint-disable-next-line func-names\n    return function (thing) {\n        return TypedArray && thing instanceof TypedArray;\n    };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nvar forEachEntry = function (obj, fn) {\n    var generator = obj && obj[Symbol.iterator];\n    var iterator = generator.call(obj);\n    var result;\n    while ((result = iterator.next()) && !result.done) {\n        var pair = result.value;\n        fn.call(obj, pair[0], pair[1]);\n    }\n};\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nvar matchAll = function (regExp, str) {\n    var matches;\n    var arr = [];\n    while ((matches = regExp.exec(str)) !== null) {\n        arr.push(matches);\n    }\n    return arr;\n};\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nvar isHTMLForm = kindOfTest('HTMLFormElement');\nvar toCamelCase = function (str) {\n    return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n        return p1.toUpperCase() + p2;\n    });\n};\n/* Creating a function that will check if an object has a property. */\nvar hasOwnProperty = (function (_a) {\n    var hasOwnProperty = _a.hasOwnProperty;\n    return function (obj, prop) { return hasOwnProperty.call(obj, prop); };\n})(Object.prototype);\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nvar isRegExp = kindOfTest('RegExp');\nvar reduceDescriptors = function (obj, reducer) {\n    var descriptors = Object.getOwnPropertyDescriptors(obj);\n    var reducedDescriptors = {};\n    forEach(descriptors, function (descriptor, name) {\n        var ret;\n        if ((ret = reducer(descriptor, name, obj)) !== false) {\n            reducedDescriptors[name] = ret || descriptor;\n        }\n    });\n    Object.defineProperties(obj, reducedDescriptors);\n};\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\nvar freezeMethods = function (obj) {\n    reduceDescriptors(obj, function (descriptor, name) {\n        // skip restricted props in strict mode\n        if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n            return false;\n        }\n        var value = obj[name];\n        if (!isFunction(value))\n            return;\n        descriptor.enumerable = false;\n        if ('writable' in descriptor) {\n            descriptor.writable = false;\n            return;\n        }\n        if (!descriptor.set) {\n            descriptor.set = function () {\n                throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n            };\n        }\n    });\n};\nvar toObjectSet = function (arrayOrString, delimiter) {\n    var obj = {};\n    var define = function (arr) {\n        arr.forEach(function (value) {\n            obj[value] = true;\n        });\n    };\n    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n    return obj;\n};\nvar noop = function () { };\nvar toFiniteNumber = function (value, defaultValue) {\n    value = +value;\n    return Number.isFinite(value) ? value : defaultValue;\n};\nvar ALPHA = 'abcdefghijklmnopqrstuvwxyz';\nvar DIGIT = '0123456789';\nvar ALPHABET = {\n    DIGIT: DIGIT,\n    ALPHA: ALPHA,\n    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\nvar generateString = function (size, alphabet) {\n    if (size === void 0) { size = 16; }\n    if (alphabet === void 0) { alphabet = ALPHABET.ALPHA_DIGIT; }\n    var str = '';\n    var length = alphabet.length;\n    while (size--) {\n        str += alphabet[Math.random() * length | 0];\n    }\n    return str;\n};\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\nvar toJSONObject = function (obj) {\n    var stack = new Array(10);\n    var visit = function (source, i) {\n        if (isObject(source)) {\n            if (stack.indexOf(source) >= 0) {\n                return;\n            }\n            if (!('toJSON' in source)) {\n                stack[i] = source;\n                var target_1 = isArray(source) ? [] : {};\n                forEach(source, function (value, key) {\n                    var reducedValue = visit(value, i + 1);\n                    !isUndefined(reducedValue) && (target_1[key] = reducedValue);\n                });\n                stack[i] = undefined;\n                return target_1;\n            }\n        }\n        return source;\n    };\n    return visit(obj, 0);\n};\nvar isAsyncFn = kindOfTest('AsyncFunction');\nvar isThenable = function (thing) {\n    return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n};\nexports.default = {\n    isArray: isArray,\n    isArrayBuffer: isArrayBuffer,\n    isBuffer: isBuffer,\n    isFormData: isFormData,\n    isArrayBufferView: isArrayBufferView,\n    isString: isString,\n    isNumber: isNumber,\n    isBoolean: isBoolean,\n    isObject: isObject,\n    isPlainObject: isPlainObject,\n    isUndefined: isUndefined,\n    isDate: isDate,\n    isFile: isFile,\n    isBlob: isBlob,\n    isRegExp: isRegExp,\n    isFunction: isFunction,\n    isStream: isStream,\n    isURLSearchParams: isURLSearchParams,\n    isTypedArray: isTypedArray,\n    isFileList: isFileList,\n    forEach: forEach,\n    merge: merge,\n    extend: extend,\n    trim: trim,\n    stripBOM: stripBOM,\n    inherits: inherits,\n    toFlatObject: toFlatObject,\n    kindOf: kindOf,\n    kindOfTest: kindOfTest,\n    endsWith: endsWith,\n    toArray: toArray,\n    forEachEntry: forEachEntry,\n    matchAll: matchAll,\n    isHTMLForm: isHTMLForm,\n    hasOwnProperty: hasOwnProperty,\n    hasOwnProp: hasOwnProperty,\n    reduceDescriptors: reduceDescriptors,\n    freezeMethods: freezeMethods,\n    toObjectSet: toObjectSet,\n    toCamelCase: toCamelCase,\n    noop: noop,\n    toFiniteNumber: toFiniteNumber,\n    findKey: findKey,\n    global: _global,\n    isContextDefined: isContextDefined,\n    ALPHABET: ALPHABET,\n    generateString: generateString,\n    isSpecCompliantForm: isSpecCompliantForm,\n    toJSONObject: toJSONObject,\n    isAsyncFn: isAsyncFn,\n    isThenable: isThenable\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\nfunction getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error('Invalid string. Length must be a multiple of 4');\n    }\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf('=');\n    if (validLen === -1)\n        validLen = len;\n    var placeHoldersLen = validLen === len\n        ? 0\n        : 4 - (validLen % 4);\n    return [validLen, placeHoldersLen];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;\n}\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0\n        ? validLen - 4\n        : validLen;\n    var i;\n    for (i = 0; i < len; i += 4) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 18) |\n                (revLookup[b64.charCodeAt(i + 1)] << 12) |\n                (revLookup[b64.charCodeAt(i + 2)] << 6) |\n                revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = (tmp >> 16) & 0xFF;\n        arr[curByte++] = (tmp >> 8) & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 2) |\n                (revLookup[b64.charCodeAt(i + 1)] >> 4);\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 10) |\n                (revLookup[b64.charCodeAt(i + 1)] << 4) |\n                (revLookup[b64.charCodeAt(i + 2)] >> 2);\n        arr[curByte++] = (tmp >> 8) & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] +\n        lookup[num >> 12 & 0x3F] +\n        lookup[num >> 6 & 0x3F] +\n        lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n        tmp =\n            ((uint8[i] << 16) & 0xFF0000) +\n                ((uint8[i + 1] << 8) & 0xFF00) +\n                (uint8[i + 2] & 0xFF);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join('');\n}\nfunction fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] +\n            lookup[(tmp << 4) & 0x3F] +\n            '==');\n    }\n    else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] +\n            lookup[(tmp >> 4) & 0x3F] +\n            lookup[(tmp << 2) & 0x3F] +\n            '=');\n    }\n    return parts.join('');\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\");\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/buffer/node_modules/isarray/index.js\");\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n    ? global.TYPED_ARRAY_SUPPORT\n    : typedArraySupport();\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength();\nfunction typedArraySupport() {\n    try {\n        var arr = new Uint8Array(1);\n        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };\n        return arr.foo() === 42 && // typed array instances can be augmented\n            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n    }\n    catch (e) {\n        return false;\n    }\n}\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT\n        ? 0x7fffffff\n        : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError('Invalid typed array length');\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nfunction Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') {\n            throw new Error('If encoding is specified then the first argument must be a string');\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === 'string') {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== 'undefined' && Symbol.species &&\n        Buffer[Symbol.species] === Buffer) {\n        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n        Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true\n        });\n    }\n}\nfunction assertSize(size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be a number');\n    }\n    else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === 'string'\n            ? createBuffer(that, size).fill(fill, encoding)\n            : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8';\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\\'length\\' is out of bounds');\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    }\n    else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    }\n    else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if ((typeof ArrayBuffer !== 'undefined' &&\n            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === 'Buffer' && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n            'size: 0x' + kMaxLength().toString(16) + ' bytes');\n    }\n    return length | 0;\n}\nfunction SlowBuffer(length) {\n    if (+length != length) { // eslint-disable-line eqeqeq\n        length = 0;\n    }\n    return Buffer.alloc(+length);\n}\nBuffer.isBuffer = function isBuffer(b) {\n    return !!(b != null && b._isBuffer);\n};\nBuffer.compare = function compare(a, b) {\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n        throw new TypeError('Arguments must be Buffers');\n    }\n    if (a === b)\n        return 0;\n    var x = a.length;\n    var y = b.length;\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y)\n        return -1;\n    if (y < x)\n        return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== 'string') {\n        string = '' + string;\n    }\n    var len = string.length;\n    if (len === 0)\n        return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return len;\n            case 'utf8':\n            case 'utf-8':\n            case undefined:\n                return utf8ToBytes(string).length;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return len * 2;\n            case 'hex':\n                return len >>> 1;\n            case 'base64':\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase)\n                    return utf8ToBytes(string).length; // assume utf8\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return '';\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return '';\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return '';\n    }\n    if (!encoding)\n        encoding = 'utf8';\n    while (true) {\n        switch (encoding) {\n            case 'hex':\n                return hexSlice(this, start, end);\n            case 'utf8':\n            case 'utf-8':\n                return utf8Slice(this, start, end);\n            case 'ascii':\n                return asciiSlice(this, start, end);\n            case 'latin1':\n            case 'binary':\n                return latin1Slice(this, start, end);\n            case 'base64':\n                return base64Slice(this, start, end);\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = (encoding + '').toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 16-bits');\n    }\n    for (var i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 32-bits');\n    }\n    for (var i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 64-bits');\n    }\n    for (var i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0)\n        return '';\n    if (arguments.length === 0)\n        return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!Buffer.isBuffer(b))\n        throw new TypeError('Argument must be a Buffer');\n    if (this === b)\n        return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = '';\n    var max = exports.INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n        if (this.length > max)\n            str += ' ... ';\n    }\n    return '<Buffer ' + str + '>';\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!Buffer.isBuffer(target)) {\n        throw new TypeError('Argument must be a Buffer');\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError('out of range index');\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target)\n        return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for (var i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y)\n        return -1;\n    if (y < x)\n        return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0)\n        return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n    }\n    else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    }\n    else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : (buffer.length - 1);\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir)\n            return -1;\n        else\n            byteOffset = buffer.length - 1;\n    }\n    else if (byteOffset < 0) {\n        if (dir)\n            byteOffset = 0;\n        else\n            return -1;\n    }\n    // Normalize val\n    if (typeof val === 'string') {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    }\n    else if (typeof val === 'number') {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT &&\n            typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            }\n            else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n    }\n    throw new TypeError('val must be string, number or Buffer');\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n            encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        }\n        else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1)\n                    foundIndex = i;\n                if (i - foundIndex + 1 === valLength)\n                    return foundIndex * indexSize;\n            }\n            else {\n                if (foundIndex !== -1)\n                    i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    }\n    else {\n        if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found)\n                return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    }\n    else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0)\n        throw new TypeError('Invalid hex string');\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed))\n            return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8';\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, encoding)\n    }\n    else if (length === undefined && typeof offset === 'string') {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, offset[, length][, encoding])\n    }\n    else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined)\n                encoding = 'utf8';\n        }\n        else {\n            encoding = length;\n            length = undefined;\n        }\n        // legacy write(string, encoding, offset, length) - remove in v0.13\n    }\n    else {\n        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n        length = remaining;\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds');\n    }\n    if (!encoding)\n        encoding = 'utf8';\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n            case 'hex':\n                return hexWrite(this, string, offset, length);\n            case 'utf8':\n            case 'utf-8':\n                return utf8Write(this, string, offset, length);\n            case 'ascii':\n                return asciiWrite(this, string, offset, length);\n            case 'latin1':\n            case 'binary':\n                return latin1Write(this, string, offset, length);\n            case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n    }\n    else {\n        return base64.fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = (firstByte > 0xEF) ? 4\n            : (firstByte > 0xDF) ? 3\n                : (firstByte > 0xBF) ? 2\n                    : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        }\n        else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = '';\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0)\n        start = 0;\n    if (!end || end < 0 || end > len)\n        end = len;\n    var out = '';\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = '';\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0)\n            start = 0;\n    }\n    else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0)\n            end = 0;\n    }\n    else if (end > len) {\n        end = len;\n    }\n    if (end < start)\n        end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    }\n    else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n    if ((offset % 1) !== 0 || offset < 0)\n        throw new RangeError('offset is not uint');\n    if (offset + ext > length)\n        throw new RangeError('Trying to access beyond buffer length');\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert)\n        checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while (byteLength > 0 && (mul *= 0x100)) {\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    return this[offset] | (this[offset + 1] << 8);\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    return (this[offset] << 8) | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return ((this[offset]) |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16)) +\n        (this[offset + 3] * 0x1000000);\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return (this[offset] * 0x1000000) +\n        ((this[offset + 1] << 16) |\n            (this[offset + 2] << 8) |\n            this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert)\n        checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert)\n        checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while (i > 0 && (mul *= 0x100)) {\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80))\n        return (this[offset]);\n    return ((0xff - this[offset] + 1) * -1);\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    var val = this[offset] | (this[offset + 1] << 8);\n    return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | (this[offset] << 8);\n    return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return (this[offset]) |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16) |\n        (this[offset + 3] << 24);\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return (this[offset] << 24) |\n        (this[offset + 1] << 16) |\n        (this[offset + 2] << 8) |\n        (this[offset + 3]);\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length)\n        throw new RangeError('Index out of range');\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT)\n        value = Math.floor(value);\n    this[offset] = (value & 0xff);\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0)\n        value = 0xffff + value + 1;\n    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value & 0xff);\n        this[offset + 1] = (value >>> 8);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 8);\n        this[offset + 1] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0)\n        value = 0xffffffff + value + 1;\n    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = (value >>> 24);\n        this[offset + 2] = (value >>> 16);\n        this[offset + 1] = (value >>> 8);\n        this[offset] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 24);\n        this[offset + 1] = (value >>> 16);\n        this[offset + 2] = (value >>> 8);\n        this[offset + 3] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT)\n        value = Math.floor(value);\n    if (value < 0)\n        value = 0xff + value + 1;\n    this[offset] = (value & 0xff);\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value & 0xff);\n        this[offset + 1] = (value >>> 8);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 8);\n        this[offset + 1] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value & 0xff);\n        this[offset + 1] = (value >>> 8);\n        this[offset + 2] = (value >>> 16);\n        this[offset + 3] = (value >>> 24);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0)\n        value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 24);\n        this[offset + 1] = (value >>> 16);\n        this[offset + 2] = (value >>> 8);\n        this[offset + 3] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length)\n        throw new RangeError('Index out of range');\n    if (offset < 0)\n        throw new RangeError('Index out of range');\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start)\n        start = 0;\n    if (!end && end !== 0)\n        end = this.length;\n    if (targetStart >= target.length)\n        targetStart = target.length;\n    if (!targetStart)\n        targetStart = 0;\n    if (end > 0 && end < start)\n        end = start;\n    // Copy 0 bytes; we're done\n    if (end === start)\n        return 0;\n    if (target.length === 0 || this.length === 0)\n        return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds');\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds');\n    if (end < 0)\n        throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length)\n        end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        }\n        else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string');\n        }\n        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding);\n        }\n    }\n    else if (typeof val === 'number') {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index');\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val)\n        val = 0;\n    var i;\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val;\n        }\n    }\n    else {\n        var bytes = Buffer.isBuffer(val)\n            ? val\n            : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2)\n        return '';\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while (str.length % 4 !== 0) {\n        str = str + '=';\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim)\n        return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, '');\n}\nfunction toHex(n) {\n    if (n < 16)\n        return '0' + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1)\n                    bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        }\n        else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1)\n                bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0)\n                break;\n            bytes.push(codePoint);\n        }\n        else if (codePoint < 0x800) {\n            if ((units -= 2) < 0)\n                break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0)\n                break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0)\n                break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else {\n            throw new Error('Invalid code point');\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n            break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return base64.toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if ((i + offset >= dst.length) || (i >= src.length))\n            break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val; // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar toString = {}.toString;\nmodule.exports = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/buffer/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/chart.js/dist/chart.mjs":
/*!**********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.mjs ***!
  \**********************************************/
/*! exports provided: defaults, Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, DatasetController, Decimation, DomPlatform, DoughnutController, Element, Filler, Interaction, Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, SubTitle, Ticks, TimeScale, TimeSeriesScale, Title, Tooltip, _adapters, _detectPlatform, animator, controllers, elements, layouts, plugins, registerables, registry, scales */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Animation\", function() { return Animation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Animations\", function() { return Animations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcElement\", function() { return ArcElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarController\", function() { return BarController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarElement\", function() { return BarElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasePlatform\", function() { return BasePlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicPlatform\", function() { return BasicPlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BubbleController\", function() { return BubbleController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CategoryScale\", function() { return CategoryScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chart\", function() { return Chart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DatasetController\", function() { return DatasetController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Decimation\", function() { return plugin_decimation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomPlatform\", function() { return DomPlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoughnutController\", function() { return DoughnutController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return Element; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Filler\", function() { return index; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interaction\", function() { return Interaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Legend\", function() { return plugin_legend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineController\", function() { return LineController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineElement\", function() { return LineElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearScale\", function() { return LinearScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogarithmicScale\", function() { return LogarithmicScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PieController\", function() { return PieController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointElement\", function() { return PointElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolarAreaController\", function() { return PolarAreaController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RadarController\", function() { return RadarController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RadialLinearScale\", function() { return RadialLinearScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scale\", function() { return Scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScatterController\", function() { return ScatterController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubTitle\", function() { return plugin_subtitle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ticks\", function() { return Ticks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeScale\", function() { return TimeScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeSeriesScale\", function() { return TimeSeriesScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Title\", function() { return plugin_title; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tooltip\", function() { return plugin_tooltip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_adapters\", function() { return adapters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_detectPlatform\", function() { return _detectPlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animator\", function() { return animator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"controllers\", function() { return controllers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"elements\", function() { return elements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"layouts\", function() { return layouts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plugins\", function() { return plugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerables\", function() { return registerables; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registry\", function() { return registry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scales\", function() { return scales; });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defaults\", function() { return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"]; });\n\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"r\"].call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(from || transparent);\n    const c1 = c0.valid && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"c\"])(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.to, to, currentValue, cfg.from]);\n    const from = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"e\"][cfg.easing] || _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"e\"].linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.to, to, currentValue, cfg.from]);\n      this._from = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].animation);\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].describe('animations', {\n  _fallback: 'animation',\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(otherValue) && (singleMode || (value === 0 || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(value) === Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"u\"])(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"u\"])(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"l\"])(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(item, xAxisKey), index),\n        y: yScale.parse(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"_\"])(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(obj, iAxisKey), i);\n      parsed.push(parseValue(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(val) || isNaN(val)) {\n        return true;\n      }\n    };\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(value) !== Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"], startY, endY);\n    const minX = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"], startX, endX);\n    const minY = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"] + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"], startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"];\n    let max = -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"];\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"m\"])(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"n\"])(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"] * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"w\"])(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"y\"].bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n    return range;\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"];\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"y\"].bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(this.x) && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].route('scale.ticks', 'color', '', 'color');\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].route('scale.grid', 'color', '', 'borderColor');\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].route('scale.grid', 'borderColor', '', 'borderColor');\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].route('scale.title', 'color', '', 'color');\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].describe('scales', {\n  _fallback: 'scale',\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"A\"])(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(majorStart, 0);\n  const end = Math.min(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.font, fallback);\n  const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.padding);\n  const lines = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"R\"])(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, left, right);\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, bottom, top);\n    rotation = position === 'left' ? -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"] : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"];\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(_userMin, _suggestedMin),\n      max: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(_userMax, _suggestedMax),\n      minDefined: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(_userMin),\n      maxDefined: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(min, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(max, min)),\n      max: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(max, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"D\"])(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"F\"])(Math.min(\n        Math.asin(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n  beforeFit() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(label) && !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label)) {\n        width = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"G\"])(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(nestedLabel) && !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(nestedLabel)) {\n            width = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"G\"])(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"I\"])(this._alignToPixels ? Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndex.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n      if (isHorizontal) {\n        x = pixel;\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign: tickTextAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"J\"])(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"N\"])(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(title.font);\n    const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(position)) {\n      offset += padding.bottom;\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"][scope]) {\n      delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"][scope][id];\n      if (this.override) {\n        delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"U\"][id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"V\"])(Object.create(null), [\n    parentScope ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].get(parentScope) : {},\n    _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].get(scope),\n    item.defaults\n  ]);\n  _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"W\"])(method);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(component['before' + camelMethod], [], component);\n    registry[method](component);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass ScatterController extends DatasetController {\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"q\"])(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"w\"])(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    if (this.options.showLine) {\n      const {dataset: line, _dataset} = meta;\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    }\n    this.updateElements(points, start, count, mode);\n  }\n  addElements() {\n    const {showLine} = this.options;\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = registry.getElement('line');\n    }\n    super.addElements();\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  init(chartOptions) {}\n  formats() {\n    return abstract();\n  }\n  parse(value, format) {\n    return abstract();\n  }\n  format(timestamp, format) {\n    return abstract();\n  }\n  add(timestamp, amount, unit) {\n    return abstract();\n  }\n  diff(a, b, unit) {\n    return abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return abstract();\n  }\n  endOf(timestamp, unit) {\n    return abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Y\"] : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Z\"];\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a0\"])(element, {x: position.x, y: position.y});\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  evaluateInteractionItems,\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(e, chart);\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n    x(chart, e, options, useFinalPosition) {\n      const position = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      const position = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a3\"])(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a3\"])(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a5\"] ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"X\"])(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a2\"])(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a4\"])((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a4\"])((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a1\"])(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a2\"])(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a6\"])() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n  return {plugins, localIds};\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"U\"][config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ac\"])(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"U\"][type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ac\"])(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ac\"])(scale, [_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].scales[scale.type], _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"f\"])(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"U\"][type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"], key));\n      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a7\"], key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"U\"][type] || {},\n      _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].datasets[type] || {},\n      {type},\n      _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"],\n      _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a7\"]\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a9\"])(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(context)\n      ? Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a9\"])(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aa\"])(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ab\"])(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(value) || hasFunction(value)))\n      || (indexable && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.9.1\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a6\"])() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ad\"])();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ae\"])(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"af\"])(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ag\"])(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"af\"])(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ah\"])(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ah\"])(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a8\"])(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"N\"])(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  isPointInArea(point) {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(point, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"j\"])(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ag\"])(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n    this.notifyPlugins('afterDestroy');\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ai\"])(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aj\"])(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(options.onHover, [e, active, this], this);\n      if (isClick) {\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ai\"])(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\nconst invalidatePlugins = () => Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"]\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"U\"]\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"], startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"]);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"al\"])(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(o.innerStart, 0, innerLimit),\n    innerEnd: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"]) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  if (circular) {\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"]);\n    }\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"], innerEndAdjustedAngle + Math.PI);\n    }\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"]);\n    }\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"], outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"], circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"];\n      if (circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"] === 0) {\n        endAngle += _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"];\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"], startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n  const {options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const inner = options.borderAlign === 'inner';\n  if (!borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a0\"])(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"] || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"p\"])(angle, startAngle, endAngle);\n    const withinRadius = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"] ? Math.floor(circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"]) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderJoinStyle: undefined,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n  circular: true,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"as\"];\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"at\"];\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ap\"];\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aq\"];\n  }\n  return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ar\"];\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"am\"])(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"an\"])(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ao\"])(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"$\"])(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"au\"])(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aw\"])(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(x, bounds.left, bounds.right))\n\t\t&& (skipY || Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"av\"] : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(minIndex) && !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Z\"])(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Z\"])(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"a\"])([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (!meta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ao\"])(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ay\"])(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"az\"])(start);\n    end = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"az\"])(end);\n  }\n  return {property, start, end};\n}\nfunction _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n  return target;\n}\nfunction _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(fill)) {\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n  let value;\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n\nfunction _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n\nfunction _getTarget(source) {\n  const {chart, fill, line} = source;\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(pixel)) {\n    const horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n  return null;\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"N\"])(ctx);\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nvar index = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aA\"])(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"L\"])(ctx, this);\n      this._draw();\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"N\"])(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].color;\n    const rtlHelper = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aA\"])(opts.rtl, this.left, this.width);\n    const labelFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineWidth, 1);\n      ctx.fillStyle = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aE\"])(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"av\"])(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aB\"])(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aC\"])(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aD\"])(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(titleOpts.font);\n    const titlePadding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aA\"])(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"R\"])(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(titleOpts.font);\n    const titlePadding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(x, this.left, this.right)\n      && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(x, hitBox.left, hitBox.left + hitBox.width)\n          && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ak\"])(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(opts.text) ? opts.text.length : 1;\n    this._padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(opts.padding);\n    const textSize = lineCount * Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, bottom, top);\n        rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"] * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"S\"])(align, top, bottom);\n        rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"] * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"R\"])(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aG\"])(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.bodyFont);\n  const titleFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.titleFont);\n  const footerFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(body, (bodyItem) => {\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(bodyItem.before, maxLineWidth);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(bodyItem.lines, maxLineWidth);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(x, 0, chart.width - size.width),\n    y: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart || config._chart;\n    this._chart = this.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aA\"])(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"au\"])(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"au\"])(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"i\"])(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : (labelColors.borderWidth || 1);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"av\"])(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"av\"])(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aA\"])(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Q\"])(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aA\"])(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aB\"])(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aD\"])(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ai\"])(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ai\"])(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n        return;\n      }\n      tooltip.draw(chart.ctx);\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      beforeBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      beforeLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      afterBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      beforeFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      footer: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"],\n      afterFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aF\"]\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(min);\n  const maxDefined = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(max);\n  const countDefined = !Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aI\"])((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aI\"])(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aJ\"])((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aK\"])(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aL\"])(spacing),\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aL\"])(niceMin)\n  );\n  factor = Math.pow(10, Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aK\"])(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aK\"])(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(min);\n      const maxSign = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"s\"])(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aH\"])(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(min) ? min : 0;\n    this.max = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(generationOptions.min, Math.pow(10, Math.floor(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(dataRange.min))));\n  let exp = Math.floor(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"B\"])(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(min) ? Math.max(0, min) : null;\n    this.max = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aH\"])(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"o\"])(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(start);\n    this._valueRange = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(this.max) - Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"z\"])(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(tickOpts.backdropPadding);\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(tickOpts.font && tickOpts.font.size, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"d\"].font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(label) ? label : [label];\n  return {\n    w: Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aM\"])(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"] / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"az\"])(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"F\"])(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const extra = getTickBackdropHeight(opts) / 2;\n  const outerDistance = scale.drawingArea;\n  const additionalAngle = opts.pointLabels.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"P\"] / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n    const angle = Math.round(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"F\"])(Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"az\"])(pointLabelPosition.angle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"])));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(backdropColor)) {\n      const borderRadius = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ax\"])(optsAtIndex.borderRadius);\n      const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      const backdropLeft = left - padding.left;\n      const backdropTop = top - padding.top;\n      const backdropWidth = right - left + padding.width;\n      const backdropHeight = bottom - top + padding.height;\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"av\"])(ctx, {\n          x: backdropLeft,\n          y: backdropTop,\n          w: backdropWidth,\n          h: backdropHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n      }\n    }\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"]);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n  return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(min) && !isNaN(min) ? min : 0;\n    this.max = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"T\"] / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"az\"])(index * angleMultiplier + Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"H\"] + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"O\"])(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"K\"])(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"M\"])(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5,\n    centerPointLabels: false\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"k\"])(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && (Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aO\"])(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    adapter.init(opts);\n    Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ac\"])(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"g\"])(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"aN\"])(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(start, 0, limit);\n    end = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"E\"])(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"v\"])(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"x\"])(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"C\"])(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"t\"])(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"_\"])(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Z\"])(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = Object(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Z\"])(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n\n\n\n\n//# sourceURL=webpack:///./node_modules/chart.js/dist/chart.mjs?");

/***/ }),

/***/ "./node_modules/chart.js/dist/chunks/helpers.segment.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.segment.mjs ***!
  \***************************************************************/
/*! exports provided: $, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, _, a, a$, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM, aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ, a_, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, b, b0, b1, b2, b3, b4, b5, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$\", function() { return _isPointInArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return _factorize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return finiteOrDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return callback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return _addGrace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return _limitValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return toDegrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return _measureText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return HALF_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return _int16Range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"J\", function() { return _alignPixel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"K\", function() { return toPadding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return clipArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return renderText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return unclipArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"O\", function() { return toFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P\", function() { return PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Q\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R\", function() { return _toLeftRightCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"S\", function() { return _alignStartEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"T\", function() { return TAU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"U\", function() { return overrides; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"V\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"W\", function() { return _capitalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X\", function() { return getRelativePosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Y\", function() { return _rlookupByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Z\", function() { return _lookupByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_\", function() { return _arrayUnique; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return resolve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a$\", function() { return toLineHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a0\", function() { return getAngleFromPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a1\", function() { return getMaximumSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a2\", function() { return _getParentNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a3\", function() { return readUsedSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a4\", function() { return throttled; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a5\", function() { return supportsEventListenerOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a6\", function() { return _isDomSupported; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a7\", function() { return descriptors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a8\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a9\", function() { return _attachContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aA\", function() { return getRtlAdapter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aB\", function() { return overrideTextDirection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aC\", function() { return _textX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aD\", function() { return restoreTextDirection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aE\", function() { return drawPointLegend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aF\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aG\", function() { return distanceBetweenPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aH\", function() { return _setMinAndMaxByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aI\", function() { return niceNum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aJ\", function() { return almostWhole; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aK\", function() { return almostEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aL\", function() { return _decimalPlaces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aM\", function() { return _longestText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aN\", function() { return _filterBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aO\", function() { return _lookup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aP\", function() { return isPatternOrGradient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aQ\", function() { return getHoverColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aR\", function() { return clone$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aS\", function() { return _merger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aT\", function() { return _mergerIf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aU\", function() { return _deprecated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aV\", function() { return _splitKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aW\", function() { return toFontString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aX\", function() { return splineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aY\", function() { return splineCurveMonotone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aZ\", function() { return getStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a_\", function() { return fontString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aa\", function() { return _createResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ab\", function() { return _descriptors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ac\", function() { return mergeIf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ad\", function() { return uid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ae\", function() { return debounce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"af\", function() { return retinaScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ag\", function() { return clearCanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ah\", function() { return setsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ai\", function() { return _elementsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aj\", function() { return _isClickEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ak\", function() { return _isBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"al\", function() { return _readValueToProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"am\", function() { return _updateBezierControlPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"an\", function() { return _computeSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ao\", function() { return _boundSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ap\", function() { return _steppedInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aq\", function() { return _bezierInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ar\", function() { return _pointInLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"as\", function() { return _steppedLineTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"at\", function() { return _bezierCurveTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"au\", function() { return drawPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"av\", function() { return addRoundedRectPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aw\", function() { return toTRBL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ax\", function() { return toTRBLCorners; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ay\", function() { return _boundSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"az\", function() { return _normalizeAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b0\", function() { return PITAU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b1\", function() { return INFINITY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b2\", function() { return RAD_PER_DEG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b3\", function() { return QUARTER_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b4\", function() { return TWO_THIRDS_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b5\", function() { return _angleDiff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return defaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return effects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return resolveObjectKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return isNumberFinite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return createContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return defined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return isNullOrUndef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return listenArrayEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return toPercentage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return toDimension; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return formatNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return _angleBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return _getStartAndCountOfVisiblePoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return requestAnimFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return sign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return toRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return unlistenArrayEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return valueOrDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return _scaleRangesChanged; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return _parseObjectDataRadialScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return log10; });\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction noop() {}\nconst uid = (function() {\n  let id = 0;\n  return function() {\n    return id++;\n  };\n}());\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : value / dimension;\nconst toDimension = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n    if (!isObject(source)) {\n      continue;\n    }\n    const keys = Object.keys(source);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\nconst keyResolvers = {\n  '': v => v,\n  x: o => o.x,\n  y: o => o.y\n};\nfunction resolveObjectKey(obj, key) {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\nfunction _splitKey(key) {\n  const parts = key.split('.');\n  const keys = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value) => typeof value !== 'undefined';\nconst isFunction = (value) => typeof value === 'function';\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < (-0.5 * PI)) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {lo, hi};\n}\nconst _lookupByKey = (table, key, value, last) =>\n  _lookup(table, value, last\n    ? index => table[index][key] <= value\n    : index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n  let ticking = false;\n  let args = [];\n  return function(...rest) {\n    args = updateArgs(rest);\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {start, count};\n}\nfunction _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nconst atEdge = (t) => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n  easeInOutBounce: t => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n};\n\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n}\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n  default:\n    if (w) {\n      ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n    } else {\n      ctx.arc(x, y, radius, 0, TAU);\n    }\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      width = w ? w / 2 : size;\n      ctx.rect(x - width, y - size, 2 * width, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = w ? w / 2 : Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n  case 'px':\n    return value;\n  case '%':\n    value /= 100;\n    break;\n  }\n  return size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n      : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {offsetX, offsetY} = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\nfunction getRelativePosition(evt, chart) {\n  if ('native' in evt) {\n    return evt;\n  }\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nconst supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n  }\n  return passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\n    : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\nconst getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    },\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  let {start, end, loop} = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/chart.js/dist/chunks/helpers.segment.mjs?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/main.global.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/main.global.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\nexports.push([module.i, \"@import url(https://fonts.cdnfonts.com/css/sf-ui-display);\"]);\n// Module\nexports.push([module.i, \":root {\\n  --black: #333;\\n  --red: #DC3E22;\\n  --redB7: #B7280F;\\n  --green: #A8B64F;\\n  --green89: #899441;\\n  --white: #FFF;\\n  --whiteFD: #FDFDFD;\\n  --grayF4: #F4F4F4;\\n  --grayC4: #C4C4C4;\\n  --gray99: #999;\\n  --grayE4: #e4e4e4;\\n}\\n\\nbody {\\n  padding: 0;\\n  margin: 0;\\n  background-color: #fff;\\n  font-size: 14px;\\n  line-height: 16px;\\n  font-family: 'SF UI Display', sans-serif;\\n  -ms-overflow-style: none;\\n  scrollbar-width: none;\\n}\\n\\n* {\\n  color: var(--black);\\n  box-sizing: border-box;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n\\nul {\\n  margin: 0;\\n  padding: 0;\\n  list-style: none;\\n  font-family: 'SF UI Display', sans-serif;\\n}\\n\\na {\\n  text-decoration: none;\\n}\\n\\nbutton, select, textarea {\\n  padding: 0;\\n  border: none;\\n  outline: none;\\n  background-color: transparent;\\n  cursor: pointer;\\n  font-family: 'SF UI Display';\\n}\\n\\nbody::-webkit-scrollbar {\\n  display: none;\\n  width: 0;\\n}\\n\\n.MainContainer {\\n  margin: 0 auto;\\n  padding: 0 80px;\\n  width: 1440px;\\n  height: auto;\\n}\\n\\n@media all and (min-width: 1540px) {\\n  body::-webkit-scrollbar {\\n    width: 7px;\\n    height: 341px;\\n    border-radius: 30px;\\n  }\\n\\n  body::-webkit-scrollbar-thumb {\\n    background-color: var(--red);\\n  }\\n\\n  body::-webkit-scrollbar-track {\\n    background-color: transparent;\\n  }\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/main.global.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/content.css":
/*!****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/content.css ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".content__MainContainer--kutQM {\\n  padding: 0 80px;\\n}\\n\\n.content__ContentContainer--1dVWT {\\n  display: flex;\\n  justify-content: space-between;\\n}\\n\\n.content__LeftContainer--3mpPd {\\n  width: 531px;\\n}\\n\\n.content__RightContainer--ZQBpw {\\n  width: 733px;\\n  height: 507px;\\n  background-color: var(--grayF4);\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"MainContainer\": \"content__MainContainer--kutQM\",\n\t\"ContentContainer\": \"content__ContentContainer--1dVWT\",\n\t\"LeftContainer\": \"content__LeftContainer--3mpPd\",\n\t\"RightContainer\": \"content__RightContainer--ZQBpw\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/content.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/InfoList/infolist.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/leftSide/InfoList/infolist.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".infolist__ContentList--1dC0s {\\n  padding-left: 23px;\\n}\\n\\n.infolist__ContentListItem--1gLmF {\\n  display: block;\\n  position: relative;\\n  font-size: 1.115em;\\n  font-weight: 400;\\n  line-height: 33px;\\n}\\n\\n.infolist__ListItemDist--1oHEH {\\n  display: block;\\n  top: 15px;\\n  left: -22px;\\n  position: absolute;\\n  width: 5px;\\n  height: 5px;\\n  background-color: var(--redB7);\\n  border-radius: 100%;\\n}\\n\\n.infolist__ContentTitle--au7F8 {\\n  margin: 0;\\n  margin-bottom: 3px;\\n  font-size: 24px;\\n  font-weight: 700;\\n  line-height: 33px;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"ContentList\": \"infolist__ContentList--1dC0s\",\n\t\"ContentListItem\": \"infolist__ContentListItem--1gLmF\",\n\t\"ListItemDist\": \"infolist__ListItemDist--1oHEH\",\n\t\"ContentTitle\": \"infolist__ContentTitle--au7F8\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/InfoList/infolist.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoForm/todoform.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/leftSide/ToDoForm/todoform.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".todoform__Form--3KIIk {\\n  margin-top: 25px;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.todoform__FormInput--3aD2S {\\n  padding: 0 15px;\\n  padding-top: 19px;\\n  margin-bottom: 25px;\\n  background-color: var(--grayF4);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 300;\\n  line-height: 17px;\\n  width: 370px;\\n  height: 55px;\\n  resize: none;\\n}\\n\\n.todoform__FormInput--3aD2S::placeholder {\\n  color: #999;\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 300;\\n}\\n\\n.todoform__FormSubmit--3E3tv {\\n  display: flex;\\n  width: 173px;\\n  height: 55px;\\n  padding: 15px 50px;\\n  align-items: center;\\n  gap: 10px;\\n  background-color: var(--green);\\n  color: var(--white);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 500;\\n  line-height: 17px;\\n}\\n\\n.todoform__FormSubmit--3E3tv:hover, .todoform__FormSubmit--3E3tv:focus, .todoform__FormSubmit--3E3tv:active {\\n  background-color: var(--green89);\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Form\": \"todoform__Form--3KIIk\",\n\t\"FormInput\": \"todoform__FormInput--3aD2S\",\n\t\"FormSubmit\": \"todoform__FormSubmit--3E3tv\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoForm/todoform.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \"h2 {\\n  margin: 0;\\n}\\n\\n.todotitle__TitleContainer--1BeCV {\\n  width: 370px;\\n  padding: 19px 0;\\n  border-top: 1px solid var(--grayE4);\\n}\\n\\n.todotitle__Title--3JzYJ {\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 300;\\n  line-height: 17px;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"TitleContainer\": \"todotitle__TitleContainer--1BeCV\",\n\t\"Title\": \"todotitle__Title--3JzYJ\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/todolist.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/leftSide/ToDoList/todolist.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".todolist__ToDoListContainer--Lg18K {\\n  width: 370px;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.todolist__ToDoList--18Y3n {\\n  width: 370px;\\n  margin-top: 25px;\\n  border-bottom: 1px solid var(--grayE4);\\n  height: 120px;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n\\n.todolist__TimeSummary--3Ohfl {\\n  padding-top: 19px;\\n  font-size: 16px;\\n  font-weight: 300;\\n  line-height: 17px;\\n  color: var(--gray99);\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"ToDoListContainer\": \"todolist__ToDoListContainer--Lg18K\",\n\t\"ToDoList\": \"todolist__ToDoList--18Y3n\",\n\t\"TimeSummary\": \"todolist__TimeSummary--3Ohfl\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/todolist.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/Timer/timer.css":
/*!******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/rightSide/Timer/timer.css ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".timer__Timer--tY8Q2 {\\n  font-size: 16px;\\n  line-height: 17px;\\n}\\n\\n.timer__buttonWrapper--EyDNF {\\n  margin: 0 auto;\\n  display: flex;\\n  width: 308px;\\n  justify-content: space-between;\\n}\\n\\n.timer__StartButton--1beNK {\\n  display: inline-block;\\n  width: 145px;\\n  height: 55px;\\n  padding: 15px 50px;\\n  background-color: var(--green);\\n  align-items: center;\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 500;\\n  line-height: 17px;\\n  color: var(--whiteFD);\\n}\\n\\n.timer__StartButton--1beNK:hover, .timer__StartButton--1beNK:focus, .timer__StartButton--1beNK:active {\\n  background-color: var(--green89);\\n}\\n\\n.timer__StopButton--2rRy0 {\\n  display: inline-block;\\n  width: 138px;\\n  height: 55px;\\n  padding: 15px 0;\\n  align-items: center;\\n  border: 2px solid var(--grayC4);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 500;\\n  line-height: 17px;\\n  color: var(--grayC4);\\n}\\n\\n.timer__StopButton--2rRy0:hover, .timer__StopButton--2rRy0:focus {\\n  border-color: var(--red);\\n  color: var(--red);\\n}\\n\\n.timer__StopButton--2rRy0:active {\\n  background-color: var(--red);\\n  color: var(--white);\\n}\\n\\n.timer__TimerCount--2O9QO {\\n  position: relative;\\n  margin-bottom: 41px;\\n  font-size: 150px;\\n  width: 100%;\\n  height: 179px;\\n  font-style: normal;\\n  font-weight: 200;\\n  line-height: normal;\\n  text-align: center;\\n}\\n\\n.timer__TimerButton--3KyzP  {\\n  position: absolute;\\n  transform: translateY(-47%);\\n  top: 50%;\\n  right: 102px;\\n}\\n\\n.timer__TimerButtonStyles--I-HYd {\\n  fill: var(--grayC4);\\n}\\n\\n.timer__TimerButton--3KyzP:hover .timer__TimerButtonStyles--I-HYd, .timer__TimerButton--3KyzP:focus .timer__TimerButtonStyles--I-HYd, .timer__TimerButton--3KyzP:active  .timer__TimerButtonStyles--I-HYd {\\n  fill: var(--green89);\\n}\\n\\n.timer__TaskWrapper--LQqI5 {\\n  display: flex;\\n  position: absolute;\\n  bottom: -9px;\\n  left: 50%;\\n  transform: translateX(-50%);\\n  font-size: 0.105em;\\n  font-style: normal;\\n  font-weight: 400;\\n  line-height: 17px;\\n}\\n\\n.timer__TaskNumber--1EhdE {\\n  color: var(--gray99);\\n  padding-right: 5px;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Timer\": \"timer__Timer--tY8Q2\",\n\t\"buttonWrapper\": \"timer__buttonWrapper--EyDNF\",\n\t\"StartButton\": \"timer__StartButton--1beNK\",\n\t\"StopButton\": \"timer__StopButton--2rRy0\",\n\t\"TimerCount\": \"timer__TimerCount--2O9QO\",\n\t\"TimerButton\": \"timer__TimerButton--3KyzP\",\n\t\"TimerButtonStyles\": \"timer__TimerButtonStyles--I-HYd\",\n\t\"TaskWrapper\": \"timer__TaskWrapper--LQqI5\",\n\t\"TaskNumber\": \"timer__TaskNumber--1EhdE\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/Timer/timer.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".todotask__ToDoTask--2smur {\\n  font-size: 16px;\\n  line-height: 17px;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"ToDoTask\": \"todotask__ToDoTask--2smur\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/todocontainer.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/rightSide/ToDoContainer/todocontainer.css ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".todocontainer__ToDoContainer--3qafO {\\n  padding: 19px 40px;\\n  margin-bottom: 70px;\\n  width: 100%;\\n  height: 55px;\\n  background-color: var(--grayC4);\\n}\\n\\n.todocontainer__ToDoTaskWrapper--Ne8Fx {\\n  display: flex;\\n  justify-content: space-between;\\n  font-weight: 700;\\n}\\n\\n.todocontainer__ToDoTaskWrapper--Ne8Fx * {\\n  color: var(--white);\\n}\\n\\n.todocontainer__PomodoroNumber--29yBD {\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 400;\\n  line-height: 17px;\\n}\\n\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"ToDoContainer\": \"todocontainer__ToDoContainer--3qafO\",\n\t\"ToDoTaskWrapper\": \"todocontainer__ToDoTaskWrapper--Ne8Fx\",\n\t\"PomodoroNumber\": \"todocontainer__PomodoroNumber--29yBD\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/todocontainer.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Header/header.css":
/*!**************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Header/header.css ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".header__Header--1G647 {\\n  margin-bottom: 100px;\\n  padding: 15px 0;\\n  background-color: var(--white);\\n  box-shadow: 0px 10px 63px 0px rgba(0, 0, 0, 0.07);\\n  height: 70px;\\n}\\n\\n.header__MainContainer--ZNm0x {\\n  height: 100%;\\n}\\n\\n.header__HeaderContainer--2-43q {\\n  height: 100%;\\n  display: flex;\\n  align-items: center;\\n  justify-content: space-between;\\n  padding: 0 80px;\\n}\\n\\n.header__LogoContainer--3MtOl {\\n  display: flex;\\n  align-items: center;\\n}\\n\\n.header__LogoText--1_Tsj {\\n  margin-left: 9px;\\n  margin-top: -1px;\\n  color: var(--red);\\n  font-size: 24px;\\n  font-style: normal;\\n  font-weight: 300;\\n  line-height: 24px;\\n  text-align: center;\\n}\\n\\n.header__HeaderWrapper--3pwQN {\\n  display: flex;\\n  align-items: center;\\n  gap: 15px;\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 500;\\n  line-height: 17px;\\n  color: var(--grayC4);\\n}\\n\\n.header__HeaderButton--2ZBPG {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  margin-right: 10px;\\n  padding-right: 2px;\\n  width: 110px;\\n  color: var(--red);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 300;\\n  line-height: 17px;\\n  cursor: pointer;\\n}\\n\\n.header__HeaderLoginButton--3CkfB {\\n  color: var(--grayC4);\\n  cursor: pointer;\\n}\\n\\n.header__HeaderLoginButton--3CkfB:hover {\\n  color: var(--green);\\n}\\n\\n.header__LogoWrapper--MJSH3 {\\n  margin-right: 5px;\\n}\\n\\n.header__HeaderButtonIcon--11668 {\\n  fill: var(--red);\\n  margin-top: -4px;\\n  margin-left: -4px;\\n}\\n\\n.header__HeaderButton--2ZBPG:hover,\\n.header__HeaderButton--2ZBPG:focus,\\n.header__HeaderButton--2ZBPG:active {\\n  color: var(--redB7);\\n}\\n\\n.header__HeaderButton--2ZBPG:hover .header__HeaderButtonIcon--11668, .header__HeaderButton--2ZBPG:focus .header__HeaderButtonIcon--11668, .header__HeaderButton--2ZBPG:active .header__HeaderButtonIcon--11668 {\\n  fill: var(--redB7);\\n}\\n\\n.header__UserName--23zTC {\\n  display: inline-flex;\\n  gap: 5px;\\n  color: var(--gray99);\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Header\": \"header__Header--1G647\",\n\t\"MainContainer\": \"header__MainContainer--ZNm0x\",\n\t\"HeaderContainer\": \"header__HeaderContainer--2-43q\",\n\t\"LogoContainer\": \"header__LogoContainer--3MtOl\",\n\t\"LogoText\": \"header__LogoText--1_Tsj\",\n\t\"HeaderWrapper\": \"header__HeaderWrapper--3pwQN\",\n\t\"HeaderButton\": \"header__HeaderButton--2ZBPG\",\n\t\"HeaderLoginButton\": \"header__HeaderLoginButton--3CkfB\",\n\t\"LogoWrapper\": \"header__LogoWrapper--MJSH3\",\n\t\"HeaderButtonIcon\": \"header__HeaderButtonIcon--11668\",\n\t\"UserName\": \"header__UserName--23zTC\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Header/header.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Input/input.css":
/*!************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Input/input.css ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".input__Input--1KIxk {\\n  display: block;\\n  width: 370px;\\n  height: 55px;\\n  padding: 0 15px;\\n  margin: 0 auto;\\n  margin-bottom: 15px;\\n  background-color: var(--grayF4);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 300;\\n  line-height: 17px;\\n  color: var(--black);\\n  border: none;\\n  outline: none;\\n  cursor: text;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Input\": \"input__Input--1KIxk\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Input/input.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Login/login.css":
/*!************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Login/login.css ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".login__Login--3n7br {\\n  margin-top: -50px;\\n  max-width: 1440px;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.login__LoginWrapper--3vtXS {\\n  margin: auto;\\n  width: 500px;\\n  padding: 35px;\\n  border: 2px solid var(--grayC4);\\n  background-color: var(--white);\\n  border-radius: 5px;\\n}\\n\\n.login__LoginTitle--bIEId {\\n  text-align: center;\\n  margin-bottom: 25px;\\n}\\n\\n.login__LoginBtn--1Oaka {\\n  cursor: pointer;\\n  display: flex;\\n  margin: 0 auto;\\n  margin-top: 25px;\\n  max-width: 260px;\\n  width: auto;\\n  height: 55px;\\n  padding: 15px 50px;\\n  align-items: center;\\n  background-color: var(--green);\\n  color: var(--white);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 500;\\n  line-height: 17px;\\n}\\n\\n.login__LoginMessage--CzBEm {\\n  display: flex;\\n  justify-content: center;\\n  color: var(--green);\\n}\\n\\n.login__LoginError--3GbSh {\\n  display: flex;\\n  justify-content: center;\\n  color: red;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Login\": \"login__Login--3n7br\",\n\t\"LoginWrapper\": \"login__LoginWrapper--3vtXS\",\n\t\"LoginTitle\": \"login__LoginTitle--bIEId\",\n\t\"LoginBtn\": \"login__LoginBtn--1Oaka\",\n\t\"LoginMessage\": \"login__LoginMessage--CzBEm\",\n\t\"LoginError\": \"login__LoginError--3GbSh\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Login/login.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Placeholder/placeholder.css":
/*!************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Placeholder/placeholder.css ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".placeholder__Placeholder--2HZbb {\\n  margin: 0 auto;\\n  max-width: 1280px;\\n  height: 400px;\\n  background: var(--grayF4);\\n  border-radius: 20px;\\n}\\n\\n.placeholder__MainContainer--2jQIC {\\n  padding: 0 80px;\\n  height: 100%;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  gap: 50px;\\n  padding: 0 80px;\\n}\\n\\n.placeholder__PlaceholderImg--1Qcwj {\\n  width: 250px;\\n  height: 250px;\\n}\\n\\n.placeholder__PlaceholderPretitle--3C4k6 {\\n  margin-bottom: 8px;\\n  font-size: 16px;\\n}\\n\\n.placeholder__PlaceholderTitle--3hpDe {\\n  max-width: 500px;\\n  font-size: 30px;\\n  font-weight: 600;\\n  line-height: 120%;\\n}\\n\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Placeholder\": \"placeholder__Placeholder--2HZbb\",\n\t\"MainContainer\": \"placeholder__MainContainer--2jQIC\",\n\t\"PlaceholderImg\": \"placeholder__PlaceholderImg--1Qcwj\",\n\t\"PlaceholderPretitle\": \"placeholder__PlaceholderPretitle--3C4k6\",\n\t\"PlaceholderTitle\": \"placeholder__PlaceholderTitle--3hpDe\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Placeholder/placeholder.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Registration/registration.css":
/*!**************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Registration/registration.css ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".registration__Registration--3MbOh {\\n  margin-top: -50px;\\n  max-width: 1440px;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.registration__RegistrationWrapper--3JHlB {\\n  margin: auto;\\n  width: 500px;\\n  padding: 35px;\\n  border: 2px solid var(--grayC4);\\n  background-color: var(--white);\\n  border-radius: 5px;\\n}\\n\\n.registration__RegistrationTitle--263lW {\\n  text-align: center;\\n  margin-bottom: 25px;\\n}\\n\\n.registration__RegistrationBtn--2TPkK {\\n  cursor: pointer;\\n  display: flex;\\n  margin: 0 auto;\\n  margin-top: 25px;\\n  max-width: 260px;\\n  width: auto;\\n  height: 55px;\\n  padding: 15px 50px;\\n  align-items: center;\\n  background-color: var(--green);\\n  color: var(--white);\\n  font-size: 16px;\\n  font-style: normal;\\n  font-weight: 500;\\n  line-height: 17px;\\n}\\n\\n.registration__RegistrationMessage--3kx_2 {\\n  display: flex;\\n  justify-content: center;\\n  color: var(--green);\\n}\\n\\n.registration__RegistrationError--2ROBB {\\n  display: flex;\\n  justify-content: center;\\n  color: red;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Registration\": \"registration__Registration--3MbOh\",\n\t\"RegistrationWrapper\": \"registration__RegistrationWrapper--3JHlB\",\n\t\"RegistrationTitle\": \"registration__RegistrationTitle--263lW\",\n\t\"RegistrationBtn\": \"registration__RegistrationBtn--2TPkK\",\n\t\"RegistrationMessage\": \"registration__RegistrationMessage--3kx_2\",\n\t\"RegistrationError\": \"registration__RegistrationError--2ROBB\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Registration/registration.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Statistics/statistics.css":
/*!**********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Statistics/statistics.css ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".statistics__Statistics--AfRtF {\\n  display: flex;\\n  flex-direction: column;\\n  margin: -12px auto 0;\\n  padding: 0 80px 99px;\\n  max-width: 1440px;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.statistics__StatisticsHeaderWrapper--3rdYj {\\n  display: flex;\\n  justify-content: space-between;\\n  margin-bottom: 40px;\\n  height: 55px;\\n}\\n\\n.statistics__StatisticsTitle--2wIN4 {\\n  font-size: 24px;\\n}\\n\\n.statistics__StatisticsDropdown--3QAPQ {\\n  width: 370px;\\n  height: 55px;\\n  background: var(--grayF4);\\n}\\n\\n.statistics__StatisticsContainer--npF_k {\\n  display: flex;\\n  gap: 32px;\\n  margin-bottom: 32px;\\n}\\n\\n.statistics__col--1QuIX {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 32px;\\n}\\n\\n.statistics__card1--7YdAM {\\n  width: 296px;\\n  height: 260px;\\n  background: var(--grayF4);\\n}\\n\\n.statistics__card2--3ZtJH {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  width: 296px;\\n  height: 179px;\\n  background: var(--grayF4);\\n}\\n\\n.statistics__StatisticsChart--1UhrW {\\n  width: 952px;\\n  height: 471px;\\n  background: var(--grayF4);\\n}\\n\\n.statistics__StatisticsGrid--1SWce {\\n  display: grid;\\n  grid-template-columns: repeat(3, 1fr);\\n  gap: 32px;\\n}\\n\\n.statistics__GridItem--3pLWa {\\n  width: 405px;\\n  height: 179px;\\n  background: var(--grayF4);\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"Statistics\": \"statistics__Statistics--AfRtF\",\n\t\"StatisticsHeaderWrapper\": \"statistics__StatisticsHeaderWrapper--3rdYj\",\n\t\"StatisticsTitle\": \"statistics__StatisticsTitle--2wIN4\",\n\t\"StatisticsDropdown\": \"statistics__StatisticsDropdown--3QAPQ\",\n\t\"StatisticsContainer\": \"statistics__StatisticsContainer--npF_k\",\n\t\"col\": \"statistics__col--1QuIX\",\n\t\"card1\": \"statistics__card1--7YdAM\",\n\t\"card2\": \"statistics__card2--3ZtJH\",\n\t\"StatisticsChart\": \"statistics__StatisticsChart--1UhrW\",\n\t\"StatisticsGrid\": \"statistics__StatisticsGrid--1SWce\",\n\t\"GridItem\": \"statistics__GridItem--3pLWa\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Statistics/statistics.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n    var list = []; // return the list of modules as css string\n    list.toString = function toString() {\n        return this.map(function (item) {\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join('');\n    }; // import a list of modules into the list\n    // eslint-disable-next-line func-names\n    list.i = function (modules, mediaQuery, dedupe) {\n        if (typeof modules === 'string') {\n            // eslint-disable-next-line no-param-reassign\n            modules = [[null, modules, '']];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for (var i = 0; i < this.length; i++) {\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for (var _i = 0; _i < modules.length; _i++) {\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                }\n                else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === 'function') {\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function (source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n        });\n        return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n    }\n    return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/deepmerge/dist/es.js":
/*!*******************************************!*\
  !*** ./node_modules/deepmerge/dist/es.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value)\n        && !isSpecial(value);\n};\nfunction isNonNullObject(value) {\n    return !!value && typeof value === 'object';\n}\nfunction isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]'\n        || stringValue === '[object Date]'\n        || isReactElement(value);\n}\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\nfunction isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n}\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n    return (options.clone !== false && options.isMergeableObject(value))\n        ? deepmerge(emptyTarget(value), value, options)\n        : value;\n}\nfunction defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n        return cloneUnlessOtherwiseSpecified(element, options);\n    });\n}\nfunction mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n        Object.keys(target).forEach(function (key) {\n            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n        });\n    }\n    Object.keys(source).forEach(function (key) {\n        if (!options.isMergeableObject(source[key]) || !target[key]) {\n            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n        }\n        else {\n            destination[key] = deepmerge(target[key], source[key], options);\n        }\n    });\n    return destination;\n}\nfunction deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n        return cloneUnlessOtherwiseSpecified(source, options);\n    }\n    else if (sourceIsArray) {\n        return options.arrayMerge(target, source, options);\n    }\n    else {\n        return mergeObject(target, source, options);\n    }\n}\ndeepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n        throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n        return deepmerge(prev, next, options);\n    }, {});\n};\nvar deepmerge_1 = deepmerge;\nexports.default = deepmerge_1;\n\n\n//# sourceURL=webpack:///./node_modules/deepmerge/dist/es.js?");

/***/ }),

/***/ "./node_modules/formik/dist/formik.esm.js":
/*!************************************************!*\
  !*** ./node_modules/formik/dist/formik.esm.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.yupToFormErrors = exports.withFormik = exports.validateYupSchema = exports.useFormikContext = exports.useFormik = exports.useField = exports.swap = exports.setNestedObjectValues = exports.setIn = exports.replace = exports.prepareDataForValidation = exports.move = exports.isString = exports.isPromise = exports.isObject = exports.isNaN = exports.isInteger = exports.isInputEvent = exports.isFunction = exports.isEmptyChildren = exports.isEmptyArray = exports.insert = exports.getIn = exports.getActiveElement = exports.connect = exports.FormikProvider = exports.FormikContext = exports.FormikConsumer = exports.Formik = exports.Form = exports.FieldArray = exports.Field = exports.FastField = exports.ErrorMessage = void 0;\nvar deepmerge_1 = __importDefault(__webpack_require__(/*! deepmerge */ \"./node_modules/deepmerge/dist/es.js\"));\nvar isPlainObject_1 = __importDefault(__webpack_require__(/*! lodash-es/isPlainObject */ \"./node_modules/lodash-es/isPlainObject.js\"));\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar react_fast_compare_1 = __importDefault(__webpack_require__(/*! react-fast-compare */ \"./node_modules/react-fast-compare/index.js\"));\nvar tiny_warning_1 = __importDefault(__webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash-es/clone */ \"./node_modules/lodash-es/clone.js\"));\nvar toPath_1 = __importDefault(__webpack_require__(/*! lodash-es/toPath */ \"./node_modules/lodash-es/toPath.js\"));\nvar hoist_non_react_statics_1 = __importDefault(__webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\"));\nvar cloneDeep_1 = __importDefault(__webpack_require__(/*! lodash-es/cloneDeep */ \"./node_modules/lodash-es/cloneDeep.js\"));\nfunction _extends() {\n    _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null)\n        return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n            continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nvar FormikContext = /*#__PURE__*/ (0, react_1.createContext)(undefined);\nexports.FormikContext = FormikContext;\nFormikContext.displayName = 'FormikContext';\nvar FormikProvider = FormikContext.Provider;\nexports.FormikProvider = FormikProvider;\nvar FormikConsumer = FormikContext.Consumer;\nexports.FormikConsumer = FormikConsumer;\nfunction useFormikContext() {\n    var formik = (0, react_1.useContext)(FormikContext);\n    !!!formik ?  true ? (0, tiny_warning_1.default)(false, \"Formik context is undefined, please verify you are calling useFormikContext() as child of a <Formik> component.\") : undefined : void 0;\n    return formik;\n}\nexports.useFormikContext = useFormikContext;\n/** @private is the value an empty array? */\nvar isEmptyArray = function isEmptyArray(value) {\n    return Array.isArray(value) && value.length === 0;\n};\nexports.isEmptyArray = isEmptyArray;\n/** @private is the given object a Function? */\nvar isFunction = function isFunction(obj) {\n    return typeof obj === 'function';\n};\nexports.isFunction = isFunction;\n/** @private is the given object an Object? */\nvar isObject = function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n};\nexports.isObject = isObject;\n/** @private is the given object an integer? */\nvar isInteger = function isInteger(obj) {\n    return String(Math.floor(Number(obj))) === obj;\n};\nexports.isInteger = isInteger;\n/** @private is the given object a string? */\nvar isString = function isString(obj) {\n    return Object.prototype.toString.call(obj) === '[object String]';\n};\nexports.isString = isString;\n/** @private is the given object a NaN? */\n// eslint-disable-next-line no-self-compare\nvar isNaN$1 = function isNaN(obj) {\n    return obj !== obj;\n};\nexports.isNaN = isNaN$1;\n/** @private Does a React component have exactly 0 children? */\nvar isEmptyChildren = function isEmptyChildren(children) {\n    return react_1.Children.count(children) === 0;\n};\nexports.isEmptyChildren = isEmptyChildren;\n/** @private is the given object/value a promise? */\nvar isPromise = function isPromise(value) {\n    return isObject(value) && isFunction(value.then);\n};\nexports.isPromise = isPromise;\n/** @private is the given object/value a type of synthetic event? */\nvar isInputEvent = function isInputEvent(value) {\n    return value && isObject(value) && isObject(value.target);\n};\nexports.isInputEvent = isInputEvent;\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?Document} doc Defaults to current document.\n * @return {Element | null}\n * @see https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/dom/getActiveElement.js\n */\nfunction getActiveElement(doc) {\n    doc = doc || (typeof document !== 'undefined' ? document : undefined);\n    if (typeof doc === 'undefined') {\n        return null;\n    }\n    try {\n        return doc.activeElement || doc.body;\n    }\n    catch (e) {\n        return doc.body;\n    }\n}\nexports.getActiveElement = getActiveElement;\n/**\n * Deeply get a value from an object via its path.\n */\nfunction getIn(obj, key, def, p) {\n    if (p === void 0) {\n        p = 0;\n    }\n    var path = (0, toPath_1.default)(key);\n    while (obj && p < path.length) {\n        obj = obj[path[p++]];\n    } // check if path is not in the end\n    if (p !== path.length && !obj) {\n        return def;\n    }\n    return obj === undefined ? def : obj;\n}\nexports.getIn = getIn;\n/**\n * Deeply set a value from in object via it's path. If the value at `path`\n * has changed, return a shallow copy of obj with `value` set at `path`.\n * If `value` has not changed, return the original `obj`.\n *\n * Existing objects / arrays along `path` are also shallow copied. Sibling\n * objects along path retain the same internal js reference. Since new\n * objects / arrays are only created along `path`, we can test if anything\n * changed in a nested structure by comparing the object's reference in\n * the old and new object, similar to how russian doll cache invalidation\n * works.\n *\n * In earlier versions of this function, which used cloneDeep, there were\n * issues whereby settings a nested value would mutate the parent\n * instead of creating a new object. `clone` avoids that bug making a\n * shallow copy of the objects along the update path\n * so no object is mutated in place.\n *\n * Before changing this function, please read through the following\n * discussions.\n *\n * @see https://github.com/developit/linkstate\n * @see https://github.com/jaredpalmer/formik/pull/123\n */\nfunction setIn(obj, path, value) {\n    var res = (0, clone_1.default)(obj); // this keeps inheritance when obj is a class\n    var resVal = res;\n    var i = 0;\n    var pathArray = (0, toPath_1.default)(path);\n    for (; i < pathArray.length - 1; i++) {\n        var currentPath = pathArray[i];\n        var currentObj = getIn(obj, pathArray.slice(0, i + 1));\n        if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {\n            resVal = resVal[currentPath] = (0, clone_1.default)(currentObj);\n        }\n        else {\n            var nextPath = pathArray[i + 1];\n            resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n        }\n    } // Return original object if new value is the same as current\n    if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n        return obj;\n    }\n    if (value === undefined) {\n        delete resVal[pathArray[i]];\n    }\n    else {\n        resVal[pathArray[i]] = value;\n    } // If the path array has a single element, the loop did not run.\n    // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\n    if (i === 0 && value === undefined) {\n        delete res[pathArray[i]];\n    }\n    return res;\n}\nexports.setIn = setIn;\n/**\n * Recursively a set the same value for all keys and arrays nested object, cloning\n * @param object\n * @param value\n * @param visited\n * @param response\n */\nfunction setNestedObjectValues(object, value, visited, response) {\n    if (visited === void 0) {\n        visited = new WeakMap();\n    }\n    if (response === void 0) {\n        response = {};\n    }\n    for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {\n        var k = _Object$keys[_i];\n        var val = object[k];\n        if (isObject(val)) {\n            if (!visited.get(val)) {\n                visited.set(val, true); // In order to keep array values consistent for both dot path  and\n                // bracket syntax, we need to check if this is an array so that\n                // this will output  { friends: [true] } and not { friends: { \"0\": true } }\n                response[k] = Array.isArray(val) ? [] : {};\n                setNestedObjectValues(val, value, visited, response[k]);\n            }\n        }\n        else {\n            response[k] = value;\n        }\n    }\n    return response;\n}\nexports.setNestedObjectValues = setNestedObjectValues;\nfunction formikReducer(state, msg) {\n    switch (msg.type) {\n        case 'SET_VALUES':\n            return _extends({}, state, {\n                values: msg.payload\n            });\n        case 'SET_TOUCHED':\n            return _extends({}, state, {\n                touched: msg.payload\n            });\n        case 'SET_ERRORS':\n            if ((0, react_fast_compare_1.default)(state.errors, msg.payload)) {\n                return state;\n            }\n            return _extends({}, state, {\n                errors: msg.payload\n            });\n        case 'SET_STATUS':\n            return _extends({}, state, {\n                status: msg.payload\n            });\n        case 'SET_ISSUBMITTING':\n            return _extends({}, state, {\n                isSubmitting: msg.payload\n            });\n        case 'SET_ISVALIDATING':\n            return _extends({}, state, {\n                isValidating: msg.payload\n            });\n        case 'SET_FIELD_VALUE':\n            return _extends({}, state, {\n                values: setIn(state.values, msg.payload.field, msg.payload.value)\n            });\n        case 'SET_FIELD_TOUCHED':\n            return _extends({}, state, {\n                touched: setIn(state.touched, msg.payload.field, msg.payload.value)\n            });\n        case 'SET_FIELD_ERROR':\n            return _extends({}, state, {\n                errors: setIn(state.errors, msg.payload.field, msg.payload.value)\n            });\n        case 'RESET_FORM':\n            return _extends({}, state, msg.payload);\n        case 'SET_FORMIK_STATE':\n            return msg.payload(state);\n        case 'SUBMIT_ATTEMPT':\n            return _extends({}, state, {\n                touched: setNestedObjectValues(state.values, true),\n                isSubmitting: true,\n                submitCount: state.submitCount + 1\n            });\n        case 'SUBMIT_FAILURE':\n            return _extends({}, state, {\n                isSubmitting: false\n            });\n        case 'SUBMIT_SUCCESS':\n            return _extends({}, state, {\n                isSubmitting: false\n            });\n        default:\n            return state;\n    }\n} // Initial empty states // objects\nvar emptyErrors = {};\nvar emptyTouched = {};\nfunction useFormik(_ref) {\n    var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose(_ref, [\"validateOnChange\", \"validateOnBlur\", \"validateOnMount\", \"isInitialValid\", \"enableReinitialize\", \"onSubmit\"]);\n    var props = _extends({\n        validateOnChange: validateOnChange,\n        validateOnBlur: validateOnBlur,\n        validateOnMount: validateOnMount,\n        onSubmit: onSubmit\n    }, rest);\n    var initialValues = (0, react_1.useRef)(props.initialValues);\n    var initialErrors = (0, react_1.useRef)(props.initialErrors || emptyErrors);\n    var initialTouched = (0, react_1.useRef)(props.initialTouched || emptyTouched);\n    var initialStatus = (0, react_1.useRef)(props.initialStatus);\n    var isMounted = (0, react_1.useRef)(false);\n    var fieldRegistry = (0, react_1.useRef)({});\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, react_1.useEffect)(function () {\n            !(typeof isInitialValid === 'undefined') ?  true ? (0, tiny_warning_1.default)(false, 'isInitialValid has been deprecated and will be removed in future versions of Formik. Please use initialErrors or validateOnMount instead.') : undefined : void 0; // eslint-disable-next-line\n        }, []);\n    }\n    (0, react_1.useEffect)(function () {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    var _React$useState = (0, react_1.useState)(0), setIteration = _React$useState[1];\n    var stateRef = (0, react_1.useRef)({\n        values: props.initialValues,\n        errors: props.initialErrors || emptyErrors,\n        touched: props.initialTouched || emptyTouched,\n        status: props.initialStatus,\n        isSubmitting: false,\n        isValidating: false,\n        submitCount: 0\n    });\n    var state = stateRef.current;\n    var dispatch = (0, react_1.useCallback)(function (action) {\n        var prev = stateRef.current;\n        stateRef.current = formikReducer(prev, action); // force rerender\n        if (prev !== stateRef.current)\n            setIteration(function (x) {\n                return x + 1;\n            });\n    }, []);\n    var runValidateHandler = (0, react_1.useCallback)(function (values, field) {\n        return new Promise(function (resolve, reject) {\n            var maybePromisedErrors = props.validate(values, field);\n            if (maybePromisedErrors == null) {\n                // use loose null check here on purpose\n                resolve(emptyErrors);\n            }\n            else if (isPromise(maybePromisedErrors)) {\n                maybePromisedErrors.then(function (errors) {\n                    resolve(errors || emptyErrors);\n                }, function (actualException) {\n                    if (true) {\n                        console.warn(\"Warning: An unhandled error was caught during validation in <Formik validate />\", actualException);\n                    }\n                    reject(actualException);\n                });\n            }\n            else {\n                resolve(maybePromisedErrors);\n            }\n        });\n    }, [props.validate]);\n    /**\n     * Run validation against a Yup schema and optionally run a function if successful\n     */\n    var runValidationSchema = (0, react_1.useCallback)(function (values, field) {\n        var validationSchema = props.validationSchema;\n        var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;\n        var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);\n        return new Promise(function (resolve, reject) {\n            promise.then(function () {\n                resolve(emptyErrors);\n            }, function (err) {\n                // Yup will throw a validation error if validation fails. We catch those and\n                // resolve them into Formik errors. We can sniff if something is a Yup error\n                // by checking error.name.\n                // @see https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n                if (err.name === 'ValidationError') {\n                    resolve(yupToFormErrors(err));\n                }\n                else {\n                    // We throw any other errors\n                    if (true) {\n                        console.warn(\"Warning: An unhandled error was caught during validation in <Formik validationSchema />\", err);\n                    }\n                    reject(err);\n                }\n            });\n        });\n    }, [props.validationSchema]);\n    var runSingleFieldLevelValidation = (0, react_1.useCallback)(function (field, value) {\n        return new Promise(function (resolve) {\n            return resolve(fieldRegistry.current[field].validate(value));\n        });\n    }, []);\n    var runFieldLevelValidations = (0, react_1.useCallback)(function (values) {\n        var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function (f) {\n            return isFunction(fieldRegistry.current[f].validate);\n        }); // Construct an array with all of the field validation functions\n        var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function (f) {\n            return runSingleFieldLevelValidation(f, getIn(values, f));\n        }) : [Promise.resolve('DO_NOT_DELETE_YOU_WILL_BE_FIRED')]; // use special case ;)\n        return Promise.all(fieldValidations).then(function (fieldErrorsList) {\n            return fieldErrorsList.reduce(function (prev, curr, index) {\n                if (curr === 'DO_NOT_DELETE_YOU_WILL_BE_FIRED') {\n                    return prev;\n                }\n                if (curr) {\n                    prev = setIn(prev, fieldKeysWithValidation[index], curr);\n                }\n                return prev;\n            }, {});\n        });\n    }, [runSingleFieldLevelValidation]); // Run all validations and return the result\n    var runAllValidations = (0, react_1.useCallback)(function (values) {\n        return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function (_ref2) {\n            var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];\n            var combinedErrors = deepmerge_1.default.all([fieldErrors, schemaErrors, validateErrors], {\n                arrayMerge: arrayMerge\n            });\n            return combinedErrors;\n        });\n    }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]); // Run all validations methods and update state accordingly\n    var validateFormWithHighPriority = useEventCallback(function (values) {\n        if (values === void 0) {\n            values = state.values;\n        }\n        dispatch({\n            type: 'SET_ISVALIDATING',\n            payload: true\n        });\n        return runAllValidations(values).then(function (combinedErrors) {\n            if (!!isMounted.current) {\n                dispatch({\n                    type: 'SET_ISVALIDATING',\n                    payload: false\n                });\n                dispatch({\n                    type: 'SET_ERRORS',\n                    payload: combinedErrors\n                });\n            }\n            return combinedErrors;\n        });\n    });\n    (0, react_1.useEffect)(function () {\n        if (validateOnMount && isMounted.current === true && (0, react_fast_compare_1.default)(initialValues.current, props.initialValues)) {\n            validateFormWithHighPriority(initialValues.current);\n        }\n    }, [validateOnMount, validateFormWithHighPriority]);\n    var resetForm = (0, react_1.useCallback)(function (nextState) {\n        var values = nextState && nextState.values ? nextState.values : initialValues.current;\n        var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};\n        var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};\n        var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;\n        initialValues.current = values;\n        initialErrors.current = errors;\n        initialTouched.current = touched;\n        initialStatus.current = status;\n        var dispatchFn = function dispatchFn() {\n            dispatch({\n                type: 'RESET_FORM',\n                payload: {\n                    isSubmitting: !!nextState && !!nextState.isSubmitting,\n                    errors: errors,\n                    touched: touched,\n                    status: status,\n                    values: values,\n                    isValidating: !!nextState && !!nextState.isValidating,\n                    submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === 'number' ? nextState.submitCount : 0\n                }\n            });\n        };\n        if (props.onReset) {\n            var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);\n            if (isPromise(maybePromisedOnReset)) {\n                maybePromisedOnReset.then(dispatchFn);\n            }\n            else {\n                dispatchFn();\n            }\n        }\n        else {\n            dispatchFn();\n        }\n    }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);\n    (0, react_1.useEffect)(function () {\n        if (isMounted.current === true && !(0, react_fast_compare_1.default)(initialValues.current, props.initialValues)) {\n            if (enableReinitialize) {\n                initialValues.current = props.initialValues;\n                resetForm();\n                if (validateOnMount) {\n                    validateFormWithHighPriority(initialValues.current);\n                }\n            }\n        }\n    }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);\n    (0, react_1.useEffect)(function () {\n        if (enableReinitialize && isMounted.current === true && !(0, react_fast_compare_1.default)(initialErrors.current, props.initialErrors)) {\n            initialErrors.current = props.initialErrors || emptyErrors;\n            dispatch({\n                type: 'SET_ERRORS',\n                payload: props.initialErrors || emptyErrors\n            });\n        }\n    }, [enableReinitialize, props.initialErrors]);\n    (0, react_1.useEffect)(function () {\n        if (enableReinitialize && isMounted.current === true && !(0, react_fast_compare_1.default)(initialTouched.current, props.initialTouched)) {\n            initialTouched.current = props.initialTouched || emptyTouched;\n            dispatch({\n                type: 'SET_TOUCHED',\n                payload: props.initialTouched || emptyTouched\n            });\n        }\n    }, [enableReinitialize, props.initialTouched]);\n    (0, react_1.useEffect)(function () {\n        if (enableReinitialize && isMounted.current === true && !(0, react_fast_compare_1.default)(initialStatus.current, props.initialStatus)) {\n            initialStatus.current = props.initialStatus;\n            dispatch({\n                type: 'SET_STATUS',\n                payload: props.initialStatus\n            });\n        }\n    }, [enableReinitialize, props.initialStatus, props.initialTouched]);\n    var validateField = useEventCallback(function (name) {\n        // This will efficiently validate a single field by avoiding state\n        // changes if the validation function is synchronous. It's different from\n        // what is called when using validateForm.\n        if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {\n            var value = getIn(state.values, name);\n            var maybePromise = fieldRegistry.current[name].validate(value);\n            if (isPromise(maybePromise)) {\n                // Only flip isValidating if the function is async.\n                dispatch({\n                    type: 'SET_ISVALIDATING',\n                    payload: true\n                });\n                return maybePromise.then(function (x) {\n                    return x;\n                }).then(function (error) {\n                    dispatch({\n                        type: 'SET_FIELD_ERROR',\n                        payload: {\n                            field: name,\n                            value: error\n                        }\n                    });\n                    dispatch({\n                        type: 'SET_ISVALIDATING',\n                        payload: false\n                    });\n                });\n            }\n            else {\n                dispatch({\n                    type: 'SET_FIELD_ERROR',\n                    payload: {\n                        field: name,\n                        value: maybePromise\n                    }\n                });\n                return Promise.resolve(maybePromise);\n            }\n        }\n        else if (props.validationSchema) {\n            dispatch({\n                type: 'SET_ISVALIDATING',\n                payload: true\n            });\n            return runValidationSchema(state.values, name).then(function (x) {\n                return x;\n            }).then(function (error) {\n                dispatch({\n                    type: 'SET_FIELD_ERROR',\n                    payload: {\n                        field: name,\n                        value: getIn(error, name)\n                    }\n                });\n                dispatch({\n                    type: 'SET_ISVALIDATING',\n                    payload: false\n                });\n            });\n        }\n        return Promise.resolve();\n    });\n    var registerField = (0, react_1.useCallback)(function (name, _ref3) {\n        var validate = _ref3.validate;\n        fieldRegistry.current[name] = {\n            validate: validate\n        };\n    }, []);\n    var unregisterField = (0, react_1.useCallback)(function (name) {\n        delete fieldRegistry.current[name];\n    }, []);\n    var setTouched = useEventCallback(function (touched, shouldValidate) {\n        dispatch({\n            type: 'SET_TOUCHED',\n            payload: touched\n        });\n        var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n    });\n    var setErrors = (0, react_1.useCallback)(function (errors) {\n        dispatch({\n            type: 'SET_ERRORS',\n            payload: errors\n        });\n    }, []);\n    var setValues = useEventCallback(function (values, shouldValidate) {\n        var resolvedValues = isFunction(values) ? values(state.values) : values;\n        dispatch({\n            type: 'SET_VALUES',\n            payload: resolvedValues\n        });\n        var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();\n    });\n    var setFieldError = (0, react_1.useCallback)(function (field, value) {\n        dispatch({\n            type: 'SET_FIELD_ERROR',\n            payload: {\n                field: field,\n                value: value\n            }\n        });\n    }, []);\n    var setFieldValue = useEventCallback(function (field, value, shouldValidate) {\n        dispatch({\n            type: 'SET_FIELD_VALUE',\n            payload: {\n                field: field,\n                value: value\n            }\n        });\n        var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();\n    });\n    var executeChange = (0, react_1.useCallback)(function (eventOrTextValue, maybePath) {\n        // By default, assume that the first argument is a string. This allows us to use\n        // handleChange with React Native and React Native Web's onChangeText prop which\n        // provides just the value of the input.\n        var field = maybePath;\n        var val = eventOrTextValue;\n        var parsed; // If the first argument is not a string though, it has to be a synthetic React Event (or a fake one),\n        // so we handle like we would a normal HTML change event.\n        if (!isString(eventOrTextValue)) {\n            // If we can, persist the event\n            // @see https://reactjs.org/docs/events.html#event-pooling\n            if (eventOrTextValue.persist) {\n                eventOrTextValue.persist();\n            }\n            var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;\n            var type = target.type, name = target.name, id = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;\n            field = maybePath ? maybePath : name ? name : id;\n            if (!field && \"development\" !== \"production\") {\n                warnAboutMissingIdentifier({\n                    htmlContent: outerHTML,\n                    documentationAnchorLink: 'handlechange-e-reactchangeeventany--void',\n                    handlerName: 'handleChange'\n                });\n            }\n            val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? '' : parsed) : /checkbox/.test(type) // checkboxes\n                ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple // <select multiple>\n                ? getSelectedValues(options) : value;\n        }\n        if (field) {\n            // Set form fields by name\n            setFieldValue(field, val);\n        }\n    }, [setFieldValue, state.values]);\n    var handleChange = useEventCallback(function (eventOrPath) {\n        if (isString(eventOrPath)) {\n            return function (event) {\n                return executeChange(event, eventOrPath);\n            };\n        }\n        else {\n            executeChange(eventOrPath);\n        }\n    });\n    var setFieldTouched = useEventCallback(function (field, touched, shouldValidate) {\n        if (touched === void 0) {\n            touched = true;\n        }\n        dispatch({\n            type: 'SET_FIELD_TOUCHED',\n            payload: {\n                field: field,\n                value: touched\n            }\n        });\n        var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n    });\n    var executeBlur = (0, react_1.useCallback)(function (e, path) {\n        if (e.persist) {\n            e.persist();\n        }\n        var _e$target = e.target, name = _e$target.name, id = _e$target.id, outerHTML = _e$target.outerHTML;\n        var field = path ? path : name ? name : id;\n        if (!field && \"development\" !== \"production\") {\n            warnAboutMissingIdentifier({\n                htmlContent: outerHTML,\n                documentationAnchorLink: 'handleblur-e-any--void',\n                handlerName: 'handleBlur'\n            });\n        }\n        setFieldTouched(field, true);\n    }, [setFieldTouched]);\n    var handleBlur = useEventCallback(function (eventOrString) {\n        if (isString(eventOrString)) {\n            return function (event) {\n                return executeBlur(event, eventOrString);\n            };\n        }\n        else {\n            executeBlur(eventOrString);\n        }\n    });\n    var setFormikState = (0, react_1.useCallback)(function (stateOrCb) {\n        if (isFunction(stateOrCb)) {\n            dispatch({\n                type: 'SET_FORMIK_STATE',\n                payload: stateOrCb\n            });\n        }\n        else {\n            dispatch({\n                type: 'SET_FORMIK_STATE',\n                payload: function payload() {\n                    return stateOrCb;\n                }\n            });\n        }\n    }, []);\n    var setStatus = (0, react_1.useCallback)(function (status) {\n        dispatch({\n            type: 'SET_STATUS',\n            payload: status\n        });\n    }, []);\n    var setSubmitting = (0, react_1.useCallback)(function (isSubmitting) {\n        dispatch({\n            type: 'SET_ISSUBMITTING',\n            payload: isSubmitting\n        });\n    }, []);\n    var submitForm = useEventCallback(function () {\n        dispatch({\n            type: 'SUBMIT_ATTEMPT'\n        });\n        return validateFormWithHighPriority().then(function (combinedErrors) {\n            // In case an error was thrown and passed to the resolved Promise,\n            // `combinedErrors` can be an instance of an Error. We need to check\n            // that and abort the submit.\n            // If we don't do that, calling `Object.keys(new Error())` yields an\n            // empty array, which causes the validation to pass and the form\n            // to be submitted.\n            var isInstanceOfError = combinedErrors instanceof Error;\n            var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;\n            if (isActuallyValid) {\n                // Proceed with submit...\n                //\n                // To respect sync submit fns, we can't simply wrap executeSubmit in a promise and\n                // _always_ dispatch SUBMIT_SUCCESS because isSubmitting would then always be false.\n                // This would be fine in simple cases, but make it impossible to disable submit\n                // buttons where people use callbacks or promises as side effects (which is basically\n                // all of v1 Formik code). Instead, recall that we are inside of a promise chain already,\n                //  so we can try/catch executeSubmit(), if it returns undefined, then just bail.\n                // If there are errors, throw em. Otherwise, wrap executeSubmit in a promise and handle\n                // cleanup of isSubmitting on behalf of the consumer.\n                var promiseOrUndefined;\n                try {\n                    promiseOrUndefined = executeSubmit(); // Bail if it's sync, consumer is responsible for cleaning up\n                    // via setSubmitting(false)\n                    if (promiseOrUndefined === undefined) {\n                        return;\n                    }\n                }\n                catch (error) {\n                    throw error;\n                }\n                return Promise.resolve(promiseOrUndefined).then(function (result) {\n                    if (!!isMounted.current) {\n                        dispatch({\n                            type: 'SUBMIT_SUCCESS'\n                        });\n                    }\n                    return result;\n                })[\"catch\"](function (_errors) {\n                    if (!!isMounted.current) {\n                        dispatch({\n                            type: 'SUBMIT_FAILURE'\n                        }); // This is a legit error rejected by the onSubmit fn\n                        // so we don't want to break the promise chain\n                        throw _errors;\n                    }\n                });\n            }\n            else if (!!isMounted.current) {\n                // ^^^ Make sure Formik is still mounted before updating state\n                dispatch({\n                    type: 'SUBMIT_FAILURE'\n                }); // throw combinedErrors;\n                if (isInstanceOfError) {\n                    throw combinedErrors;\n                }\n            }\n            return;\n        });\n    });\n    var handleSubmit = useEventCallback(function (e) {\n        if (e && e.preventDefault && isFunction(e.preventDefault)) {\n            e.preventDefault();\n        }\n        if (e && e.stopPropagation && isFunction(e.stopPropagation)) {\n            e.stopPropagation();\n        } // Warn if form submission is triggered by a <button> without a\n        // specified `type` attribute during development. This mitigates\n        // a common gotcha in forms with both reset and submit buttons,\n        // where the dev forgets to add type=\"button\" to the reset button.\n        if ( true && typeof document !== 'undefined') {\n            // Safely get the active element (works with IE)\n            var activeElement = getActiveElement();\n            if (activeElement !== null && activeElement instanceof HTMLButtonElement) {\n                !(activeElement.attributes && activeElement.attributes.getNamedItem('type')) ?  true ? (0, tiny_warning_1.default)(false, 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type=\"submit\"`. If this is not a submit button, please add `type=\"button\"`.') : undefined : void 0;\n            }\n        }\n        submitForm()[\"catch\"](function (reason) {\n            console.warn(\"Warning: An unhandled error was caught from submitForm()\", reason);\n        });\n    });\n    var imperativeMethods = {\n        resetForm: resetForm,\n        validateForm: validateFormWithHighPriority,\n        validateField: validateField,\n        setErrors: setErrors,\n        setFieldError: setFieldError,\n        setFieldTouched: setFieldTouched,\n        setFieldValue: setFieldValue,\n        setStatus: setStatus,\n        setSubmitting: setSubmitting,\n        setTouched: setTouched,\n        setValues: setValues,\n        setFormikState: setFormikState,\n        submitForm: submitForm\n    };\n    var executeSubmit = useEventCallback(function () {\n        return onSubmit(state.values, imperativeMethods);\n    });\n    var handleReset = useEventCallback(function (e) {\n        if (e && e.preventDefault && isFunction(e.preventDefault)) {\n            e.preventDefault();\n        }\n        if (e && e.stopPropagation && isFunction(e.stopPropagation)) {\n            e.stopPropagation();\n        }\n        resetForm();\n    });\n    var getFieldMeta = (0, react_1.useCallback)(function (name) {\n        return {\n            value: getIn(state.values, name),\n            error: getIn(state.errors, name),\n            touched: !!getIn(state.touched, name),\n            initialValue: getIn(initialValues.current, name),\n            initialTouched: !!getIn(initialTouched.current, name),\n            initialError: getIn(initialErrors.current, name)\n        };\n    }, [state.errors, state.touched, state.values]);\n    var getFieldHelpers = (0, react_1.useCallback)(function (name) {\n        return {\n            setValue: function setValue(value, shouldValidate) {\n                return setFieldValue(name, value, shouldValidate);\n            },\n            setTouched: function setTouched(value, shouldValidate) {\n                return setFieldTouched(name, value, shouldValidate);\n            },\n            setError: function setError(value) {\n                return setFieldError(name, value);\n            }\n        };\n    }, [setFieldValue, setFieldTouched, setFieldError]);\n    var getFieldProps = (0, react_1.useCallback)(function (nameOrOptions) {\n        var isAnObject = isObject(nameOrOptions);\n        var name = isAnObject ? nameOrOptions.name : nameOrOptions;\n        var valueState = getIn(state.values, name);\n        var field = {\n            name: name,\n            value: valueState,\n            onChange: handleChange,\n            onBlur: handleBlur\n        };\n        if (isAnObject) {\n            var type = nameOrOptions.type, valueProp = nameOrOptions.value, is = nameOrOptions.as, multiple = nameOrOptions.multiple;\n            if (type === 'checkbox') {\n                if (valueProp === undefined) {\n                    field.checked = !!valueState;\n                }\n                else {\n                    field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));\n                    field.value = valueProp;\n                }\n            }\n            else if (type === 'radio') {\n                field.checked = valueState === valueProp;\n                field.value = valueProp;\n            }\n            else if (is === 'select' && multiple) {\n                field.value = field.value || [];\n                field.multiple = true;\n            }\n        }\n        return field;\n    }, [handleBlur, handleChange, state.values]);\n    var dirty = (0, react_1.useMemo)(function () {\n        return !(0, react_fast_compare_1.default)(initialValues.current, state.values);\n    }, [initialValues.current, state.values]);\n    var isValid = (0, react_1.useMemo)(function () {\n        return typeof isInitialValid !== 'undefined' ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;\n    }, [isInitialValid, dirty, state.errors, props]);\n    var ctx = _extends({}, state, {\n        initialValues: initialValues.current,\n        initialErrors: initialErrors.current,\n        initialTouched: initialTouched.current,\n        initialStatus: initialStatus.current,\n        handleBlur: handleBlur,\n        handleChange: handleChange,\n        handleReset: handleReset,\n        handleSubmit: handleSubmit,\n        resetForm: resetForm,\n        setErrors: setErrors,\n        setFormikState: setFormikState,\n        setFieldTouched: setFieldTouched,\n        setFieldValue: setFieldValue,\n        setFieldError: setFieldError,\n        setStatus: setStatus,\n        setSubmitting: setSubmitting,\n        setTouched: setTouched,\n        setValues: setValues,\n        submitForm: submitForm,\n        validateForm: validateFormWithHighPriority,\n        validateField: validateField,\n        isValid: isValid,\n        dirty: dirty,\n        unregisterField: unregisterField,\n        registerField: registerField,\n        getFieldProps: getFieldProps,\n        getFieldMeta: getFieldMeta,\n        getFieldHelpers: getFieldHelpers,\n        validateOnBlur: validateOnBlur,\n        validateOnChange: validateOnChange,\n        validateOnMount: validateOnMount\n    });\n    return ctx;\n}\nexports.useFormik = useFormik;\nfunction Formik(props) {\n    var formikbag = useFormik(props);\n    var component = props.component, children = props.children, render = props.render, innerRef = props.innerRef; // This allows folks to pass a ref to <Formik />\n    (0, react_1.useImperativeHandle)(innerRef, function () {\n        return formikbag;\n    });\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, react_1.useEffect)(function () {\n            !!props.render ?  true ? (0, tiny_warning_1.default)(false, \"<Formik render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Formik render={(props) => ...} /> with <Formik>{(props) => ...}</Formik>\") : undefined : void 0; // eslint-disable-next-line\n        }, []);\n    }\n    return (0, react_1.createElement)(FormikProvider, {\n        value: formikbag\n    }, component ? (0, react_1.createElement)(component, formikbag) : render ? render(formikbag) : children // children come last, always called\n        ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? react_1.Children.only(children) : null : null);\n}\nexports.Formik = Formik;\nfunction warnAboutMissingIdentifier(_ref4) {\n    var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;\n    console.warn(\"Warning: Formik called `\" + handlerName + \"`, but you forgot to pass an `id` or `name` attribute to your input:\\n    \" + htmlContent + \"\\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#\" + documentationAnchorLink + \"\\n  \");\n}\n/**\n * Transform Yup ValidationError to a more usable object\n */\nfunction yupToFormErrors(yupError) {\n    var errors = {};\n    if (yupError.inner) {\n        if (yupError.inner.length === 0) {\n            return setIn(errors, yupError.path, yupError.message);\n        }\n        for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref5;\n            if (_isArray) {\n                if (_i >= _iterator.length)\n                    break;\n                _ref5 = _iterator[_i++];\n            }\n            else {\n                _i = _iterator.next();\n                if (_i.done)\n                    break;\n                _ref5 = _i.value;\n            }\n            var err = _ref5;\n            if (!getIn(errors, err.path)) {\n                errors = setIn(errors, err.path, err.message);\n            }\n        }\n    }\n    return errors;\n}\nexports.yupToFormErrors = yupToFormErrors;\n/**\n * Validate a yup schema.\n */\nfunction validateYupSchema(values, schema, sync, context) {\n    if (sync === void 0) {\n        sync = false;\n    }\n    var normalizedValues = prepareDataForValidation(values);\n    return schema[sync ? 'validateSync' : 'validate'](normalizedValues, {\n        abortEarly: false,\n        context: context || normalizedValues\n    });\n}\nexports.validateYupSchema = validateYupSchema;\n/**\n * Recursively prepare values.\n */\nfunction prepareDataForValidation(values) {\n    var data = Array.isArray(values) ? [] : {};\n    for (var k in values) {\n        if (Object.prototype.hasOwnProperty.call(values, k)) {\n            var key = String(k);\n            if (Array.isArray(values[key]) === true) {\n                data[key] = values[key].map(function (value) {\n                    if (Array.isArray(value) === true || (0, isPlainObject_1.default)(value)) {\n                        return prepareDataForValidation(value);\n                    }\n                    else {\n                        return value !== '' ? value : undefined;\n                    }\n                });\n            }\n            else if ((0, isPlainObject_1.default)(values[key])) {\n                data[key] = prepareDataForValidation(values[key]);\n            }\n            else {\n                data[key] = values[key] !== '' ? values[key] : undefined;\n            }\n        }\n    }\n    return data;\n}\nexports.prepareDataForValidation = prepareDataForValidation;\n/**\n * deepmerge array merging algorithm\n * https://github.com/KyleAMathews/deepmerge#combine-array\n */\nfunction arrayMerge(target, source, options) {\n    var destination = target.slice();\n    source.forEach(function merge(e, i) {\n        if (typeof destination[i] === 'undefined') {\n            var cloneRequested = options.clone !== false;\n            var shouldClone = cloneRequested && options.isMergeableObject(e);\n            destination[i] = shouldClone ? (0, deepmerge_1.default)(Array.isArray(e) ? [] : {}, e, options) : e;\n        }\n        else if (options.isMergeableObject(e)) {\n            destination[i] = (0, deepmerge_1.default)(target[i], e, options);\n        }\n        else if (target.indexOf(e) === -1) {\n            destination.push(e);\n        }\n    });\n    return destination;\n}\n/** Return multi select values based on an array of options */\nfunction getSelectedValues(options) {\n    return Array.from(options).filter(function (el) {\n        return el.selected;\n    }).map(function (el) {\n        return el.value;\n    });\n}\n/** Return the next value for a checkbox */\nfunction getValueForCheckbox(currentValue, checked, valueProp) {\n    // If the current value was a boolean, return a boolean\n    if (typeof currentValue === 'boolean') {\n        return Boolean(checked);\n    } // If the currentValue was not a boolean we want to return an array\n    var currentArrayOfValues = [];\n    var isValueInArray = false;\n    var index = -1;\n    if (!Array.isArray(currentValue)) {\n        // eslint-disable-next-line eqeqeq\n        if (!valueProp || valueProp == 'true' || valueProp == 'false') {\n            return Boolean(checked);\n        }\n    }\n    else {\n        // If the current value is already an array, use it\n        currentArrayOfValues = currentValue;\n        index = currentValue.indexOf(valueProp);\n        isValueInArray = index >= 0;\n    } // If the checkbox was checked and the value is not already present in the aray we want to add the new value to the array of values\n    if (checked && valueProp && !isValueInArray) {\n        return currentArrayOfValues.concat(valueProp);\n    } // If the checkbox was unchecked and the value is not in the array, simply return the already existing array of values\n    if (!isValueInArray) {\n        return currentArrayOfValues;\n    } // If the checkbox was unchecked and the value is in the array, remove the value and return the array\n    return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));\n} // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n// @see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react_1.useLayoutEffect : react_1.useEffect;\nfunction useEventCallback(fn) {\n    var ref = (0, react_1.useRef)(fn); // we copy a ref to the callback scoped to the current state/props on each render\n    useIsomorphicLayoutEffect(function () {\n        ref.current = fn;\n    });\n    return (0, react_1.useCallback)(function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        return ref.current.apply(void 0, args);\n    }, []);\n}\nfunction useField(propsOrFieldName) {\n    var formik = useFormikContext();\n    var getFieldProps = formik.getFieldProps, getFieldMeta = formik.getFieldMeta, getFieldHelpers = formik.getFieldHelpers, registerField = formik.registerField, unregisterField = formik.unregisterField;\n    var isAnObject = isObject(propsOrFieldName); // Normalize propsOrFieldName to FieldHookConfig<Val>\n    var props = isAnObject ? propsOrFieldName : {\n        name: propsOrFieldName\n    };\n    var fieldName = props.name, validateFn = props.validate;\n    (0, react_1.useEffect)(function () {\n        if (fieldName) {\n            registerField(fieldName, {\n                validate: validateFn\n            });\n        }\n        return function () {\n            if (fieldName) {\n                unregisterField(fieldName);\n            }\n        };\n    }, [registerField, unregisterField, fieldName, validateFn]);\n    if (true) {\n        !formik ?  true ? (0, tiny_warning_1.default)(false, 'useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component') : undefined : void 0;\n    }\n    !fieldName ?  true ? (0, tiny_warning_1.default)(false, 'Invalid field name. Either pass `useField` a string or an object containing a `name` key.') : undefined : void 0;\n    var fieldHelpers = (0, react_1.useMemo)(function () {\n        return getFieldHelpers(fieldName);\n    }, [getFieldHelpers, fieldName]);\n    return [getFieldProps(props), getFieldMeta(fieldName), fieldHelpers];\n}\nexports.useField = useField;\nfunction Field(_ref) {\n    var validate = _ref.validate, name = _ref.name, render = _ref.render, children = _ref.children, is = _ref.as, component = _ref.component, className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, [\"validate\", \"name\", \"render\", \"children\", \"as\", \"component\", \"className\"]);\n    var _useFormikContext = useFormikContext(), formik = _objectWithoutPropertiesLoose(_useFormikContext, [\"validate\", \"validationSchema\"]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, react_1.useEffect)(function () {\n            !!render ?  true ? (0, tiny_warning_1.default)(false, \"<Field render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Field name=\\\"\" + name + \"\\\" render={({field, form}) => ...} /> with <Field name=\\\"\" + name + \"\\\">{({field, form, meta}) => ...}</Field>\") : undefined : void 0;\n            !!(is && children && isFunction(children)) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <Field as> and <Field children> as a function in the same <Field> component; <Field as> will be ignored.') : undefined : void 0;\n            !!(component && children && isFunction(children)) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.') : undefined : void 0;\n            !!(render && children && !isEmptyChildren(children)) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored') : undefined : void 0; // eslint-disable-next-line\n        }, []);\n    } // Register field and field-level validation with parent <Formik>\n    var registerField = formik.registerField, unregisterField = formik.unregisterField;\n    (0, react_1.useEffect)(function () {\n        registerField(name, {\n            validate: validate\n        });\n        return function () {\n            unregisterField(name);\n        };\n    }, [registerField, unregisterField, name, validate]);\n    var field = formik.getFieldProps(_extends({\n        name: name\n    }, props));\n    var meta = formik.getFieldMeta(name);\n    var legacyBag = {\n        field: field,\n        form: formik\n    };\n    if (render) {\n        return render(_extends({}, legacyBag, {\n            meta: meta\n        }));\n    }\n    if (isFunction(children)) {\n        return children(_extends({}, legacyBag, {\n            meta: meta\n        }));\n    }\n    if (component) {\n        // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n        if (typeof component === 'string') {\n            var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n            return (0, react_1.createElement)(component, _extends({\n                ref: innerRef\n            }, field, rest, {\n                className: className\n            }), children);\n        } // We don't pass `meta` for backwards compat\n        return (0, react_1.createElement)(component, _extends({\n            field: field,\n            form: formik\n        }, props, {\n            className: className\n        }), children);\n    } // default to input here so we can check for both `as` and `children` above\n    var asElement = is || 'input';\n    if (typeof asElement === 'string') {\n        var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n        return (0, react_1.createElement)(asElement, _extends({\n            ref: _innerRef\n        }, field, _rest, {\n            className: className\n        }), children);\n    }\n    return (0, react_1.createElement)(asElement, _extends({}, field, props, {\n        className: className\n    }), children);\n}\nexports.Field = Field;\nvar Form = /*#__PURE__*/ (0, react_1.forwardRef)(function (props, ref) {\n    // iOS needs an \"action\" attribute for nice input: https://stackoverflow.com/a/39485162/406725\n    // We default the action to \"#\" in case the preventDefault fails (just updates the URL hash)\n    var action = props.action, rest = _objectWithoutPropertiesLoose(props, [\"action\"]);\n    var _action = action != null ? action : '#';\n    var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;\n    return (0, react_1.createElement)(\"form\", _extends({\n        onSubmit: handleSubmit,\n        ref: ref,\n        onReset: handleReset,\n        action: _action\n    }, rest));\n});\nexports.Form = Form;\nForm.displayName = 'Form';\n/**\n * A public higher-order component to access the imperative API\n */\nfunction withFormik(_ref) {\n    var _ref$mapPropsToValues = _ref.mapPropsToValues, mapPropsToValues = _ref$mapPropsToValues === void 0 ? function (vanillaProps) {\n        var val = {};\n        for (var k in vanillaProps) {\n            if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== 'function') {\n                // @todo TypeScript fix\n                val[k] = vanillaProps[k];\n            }\n        }\n        return val;\n    } : _ref$mapPropsToValues, config = _objectWithoutPropertiesLoose(_ref, [\"mapPropsToValues\"]);\n    return function createFormik(Component$1) {\n        var componentDisplayName = Component$1.displayName || Component$1.name || Component$1.constructor && Component$1.constructor.name || 'Component';\n        /**\n         * We need to use closures here for to provide the wrapped component's props to\n         * the respective withFormik config methods.\n         */\n        var C = /*#__PURE__*/ function (_React$Component) {\n            _inheritsLoose(C, _React$Component);\n            function C() {\n                var _this;\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                }\n                _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n                _this.validate = function (values) {\n                    return config.validate(values, _this.props);\n                };\n                _this.validationSchema = function () {\n                    return isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;\n                };\n                _this.handleSubmit = function (values, actions) {\n                    return config.handleSubmit(values, _extends({}, actions, {\n                        props: _this.props\n                    }));\n                };\n                _this.renderFormComponent = function (formikProps) {\n                    return (0, react_1.createElement)(Component$1, _extends({}, _this.props, formikProps));\n                };\n                return _this;\n            }\n            var _proto = C.prototype;\n            _proto.render = function render() {\n                var _this$props = this.props, props = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n                return (0, react_1.createElement)(Formik, _extends({}, props, config, {\n                    validate: config.validate && this.validate,\n                    validationSchema: config.validationSchema && this.validationSchema,\n                    initialValues: mapPropsToValues(this.props),\n                    initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),\n                    initialErrors: config.mapPropsToErrors && config.mapPropsToErrors(this.props),\n                    initialTouched: config.mapPropsToTouched && config.mapPropsToTouched(this.props),\n                    onSubmit: this.handleSubmit,\n                    children: this.renderFormComponent\n                }));\n            };\n            return C;\n        }(react_1.Component);\n        C.displayName = \"WithFormik(\" + componentDisplayName + \")\";\n        return (0, hoist_non_react_statics_1.default)(C, Component$1 // cast type to ComponentClass (even if SFC)\n        );\n    };\n}\nexports.withFormik = withFormik;\n/**\n * Connect any component to Formik context, and inject as a prop called `formik`;\n * @param Comp React Component\n */\nfunction connect(Comp) {\n    var C = function C(props) {\n        return (0, react_1.createElement)(FormikConsumer, null, function (formik) {\n            !!!formik ?  true ? (0, tiny_warning_1.default)(false, \"Formik context is undefined, please verify you are rendering <Form>, <Field>, <FastField>, <FieldArray>, or your custom context-using component as a child of a <Formik> component. Component name: \" + Comp.name) : undefined : void 0;\n            return (0, react_1.createElement)(Comp, _extends({}, props, {\n                formik: formik\n            }));\n        });\n    };\n    var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || 'Component'; // Assign Comp to C.WrappedComponent so we can access the inner component in tests\n    // For example, <Field.WrappedComponent /> gets us <FieldInner/>\n    C.WrappedComponent = Comp;\n    C.displayName = \"FormikConnect(\" + componentDisplayName + \")\";\n    return (0, hoist_non_react_statics_1.default)(C, Comp // cast type to ComponentClass (even if SFC)\n    );\n}\nexports.connect = connect;\n/**\n * Some array helpers!\n */\nvar move = function move(array, from, to) {\n    var copy = copyArrayLike(array);\n    var value = copy[from];\n    copy.splice(from, 1);\n    copy.splice(to, 0, value);\n    return copy;\n};\nexports.move = move;\nvar swap = function swap(arrayLike, indexA, indexB) {\n    var copy = copyArrayLike(arrayLike);\n    var a = copy[indexA];\n    copy[indexA] = copy[indexB];\n    copy[indexB] = a;\n    return copy;\n};\nexports.swap = swap;\nvar insert = function insert(arrayLike, index, value) {\n    var copy = copyArrayLike(arrayLike);\n    copy.splice(index, 0, value);\n    return copy;\n};\nexports.insert = insert;\nvar replace = function replace(arrayLike, index, value) {\n    var copy = copyArrayLike(arrayLike);\n    copy[index] = value;\n    return copy;\n};\nexports.replace = replace;\nvar copyArrayLike = function copyArrayLike(arrayLike) {\n    if (!arrayLike) {\n        return [];\n    }\n    else if (Array.isArray(arrayLike)) {\n        return [].concat(arrayLike);\n    }\n    else {\n        var maxIndex = Object.keys(arrayLike).map(function (key) {\n            return parseInt(key);\n        }).reduce(function (max, el) {\n            return el > max ? el : max;\n        }, 0);\n        return Array.from(_extends({}, arrayLike, {\n            length: maxIndex + 1\n        }));\n    }\n};\nvar createAlterationHandler = function createAlterationHandler(alteration, defaultFunction) {\n    var fn = typeof alteration === 'function' ? alteration : defaultFunction;\n    return function (data) {\n        if (Array.isArray(data) || isObject(data)) {\n            var clone = copyArrayLike(data);\n            return fn(clone);\n        } // This can be assumed to be a primitive, which\n        // is a case for top level validation errors\n        return data;\n    };\n};\nvar FieldArrayInner = /*#__PURE__*/ function (_React$Component) {\n    _inheritsLoose(FieldArrayInner, _React$Component);\n    function FieldArrayInner(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this; // We need TypeScript generics on these, so we'll bind them in the constructor\n        // @todo Fix TS 3.2.1\n        _this.updateArrayField = function (fn, alterTouched, alterErrors) {\n            var _this$props = _this.props, name = _this$props.name, setFormikState = _this$props.formik.setFormikState;\n            setFormikState(function (prevState) {\n                var updateErrors = createAlterationHandler(alterErrors, fn);\n                var updateTouched = createAlterationHandler(alterTouched, fn); // values fn should be executed before updateErrors and updateTouched,\n                // otherwise it causes an error with unshift.\n                var values = setIn(prevState.values, name, fn(getIn(prevState.values, name)));\n                var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : undefined;\n                var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : undefined;\n                if (isEmptyArray(fieldError)) {\n                    fieldError = undefined;\n                }\n                if (isEmptyArray(fieldTouched)) {\n                    fieldTouched = undefined;\n                }\n                return _extends({}, prevState, {\n                    values: values,\n                    errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,\n                    touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched\n                });\n            });\n        };\n        _this.push = function (value) {\n            return _this.updateArrayField(function (arrayLike) {\n                return [].concat(copyArrayLike(arrayLike), [(0, cloneDeep_1.default)(value)]);\n            }, false, false);\n        };\n        _this.handlePush = function (value) {\n            return function () {\n                return _this.push(value);\n            };\n        };\n        _this.swap = function (indexA, indexB) {\n            return _this.updateArrayField(function (array) {\n                return swap(array, indexA, indexB);\n            }, true, true);\n        };\n        _this.handleSwap = function (indexA, indexB) {\n            return function () {\n                return _this.swap(indexA, indexB);\n            };\n        };\n        _this.move = function (from, to) {\n            return _this.updateArrayField(function (array) {\n                return move(array, from, to);\n            }, true, true);\n        };\n        _this.handleMove = function (from, to) {\n            return function () {\n                return _this.move(from, to);\n            };\n        };\n        _this.insert = function (index, value) {\n            return _this.updateArrayField(function (array) {\n                return insert(array, index, value);\n            }, function (array) {\n                return insert(array, index, null);\n            }, function (array) {\n                return insert(array, index, null);\n            });\n        };\n        _this.handleInsert = function (index, value) {\n            return function () {\n                return _this.insert(index, value);\n            };\n        };\n        _this.replace = function (index, value) {\n            return _this.updateArrayField(function (array) {\n                return replace(array, index, value);\n            }, false, false);\n        };\n        _this.handleReplace = function (index, value) {\n            return function () {\n                return _this.replace(index, value);\n            };\n        };\n        _this.unshift = function (value) {\n            var length = -1;\n            _this.updateArrayField(function (array) {\n                var arr = array ? [value].concat(array) : [value];\n                length = arr.length;\n                return arr;\n            }, function (array) {\n                return array ? [null].concat(array) : [null];\n            }, function (array) {\n                return array ? [null].concat(array) : [null];\n            });\n            return length;\n        };\n        _this.handleUnshift = function (value) {\n            return function () {\n                return _this.unshift(value);\n            };\n        };\n        _this.handleRemove = function (index) {\n            return function () {\n                return _this.remove(index);\n            };\n        };\n        _this.handlePop = function () {\n            return function () {\n                return _this.pop();\n            };\n        };\n        _this.remove = _this.remove.bind(_assertThisInitialized(_this));\n        _this.pop = _this.pop.bind(_assertThisInitialized(_this));\n        return _this;\n    }\n    var _proto = FieldArrayInner.prototype;\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.validateOnChange && this.props.formik.validateOnChange && !(0, react_fast_compare_1.default)(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {\n            this.props.formik.validateForm(this.props.formik.values);\n        }\n    };\n    _proto.remove = function remove(index) {\n        // We need to make sure we also remove relevant pieces of `touched` and `errors`\n        var result;\n        this.updateArrayField(// so this gets call 3 times\n        function (array) {\n            var copy = array ? copyArrayLike(array) : [];\n            if (!result) {\n                result = copy[index];\n            }\n            if (isFunction(copy.splice)) {\n                copy.splice(index, 1);\n            } // if the array only includes undefined values we have to return an empty array\n            return isFunction(copy.every) ? copy.every(function (v) {\n                return v === undefined;\n            }) ? [] : copy : copy;\n        }, true, true);\n        return result;\n    };\n    _proto.pop = function pop() {\n        // Remove relevant pieces of `touched` and `errors` too!\n        var result;\n        this.updateArrayField(// so this gets call 3 times\n        function (array) {\n            var tmp = array.slice();\n            if (!result) {\n                result = tmp && tmp.pop && tmp.pop();\n            }\n            return tmp;\n        }, true, true);\n        return result;\n    };\n    _proto.render = function render() {\n        var arrayHelpers = {\n            push: this.push,\n            pop: this.pop,\n            swap: this.swap,\n            move: this.move,\n            insert: this.insert,\n            replace: this.replace,\n            unshift: this.unshift,\n            remove: this.remove,\n            handlePush: this.handlePush,\n            handlePop: this.handlePop,\n            handleSwap: this.handleSwap,\n            handleMove: this.handleMove,\n            handleInsert: this.handleInsert,\n            handleReplace: this.handleReplace,\n            handleUnshift: this.handleUnshift,\n            handleRemove: this.handleRemove\n        };\n        var _this$props2 = this.props, component = _this$props2.component, render = _this$props2.render, children = _this$props2.children, name = _this$props2.name, _this$props2$formik = _this$props2.formik, restOfFormik = _objectWithoutPropertiesLoose(_this$props2$formik, [\"validate\", \"validationSchema\"]);\n        var props = _extends({}, arrayHelpers, {\n            form: restOfFormik,\n            name: name\n        });\n        return component ? (0, react_1.createElement)(component, props) : render ? render(props) : children // children come last, always called\n            ? typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? react_1.Children.only(children) : null : null;\n    };\n    return FieldArrayInner;\n}(react_1.Component);\nFieldArrayInner.defaultProps = {\n    validateOnChange: true\n};\nvar FieldArray = /*#__PURE__*/ connect(FieldArrayInner);\nexports.FieldArray = FieldArray;\nvar ErrorMessageImpl = /*#__PURE__*/ function (_React$Component) {\n    _inheritsLoose(ErrorMessageImpl, _React$Component);\n    function ErrorMessageImpl() {\n        return _React$Component.apply(this, arguments) || this;\n    }\n    var _proto = ErrorMessageImpl.prototype;\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    _proto.render = function render() {\n        var _this$props = this.props, component = _this$props.component, formik = _this$props.formik, render = _this$props.render, children = _this$props.children, name = _this$props.name, rest = _objectWithoutPropertiesLoose(_this$props, [\"component\", \"formik\", \"render\", \"children\", \"name\"]);\n        var touch = getIn(formik.touched, name);\n        var error = getIn(formik.errors, name);\n        return !!touch && !!error ? render ? isFunction(render) ? render(error) : null : children ? isFunction(children) ? children(error) : null : component ? (0, react_1.createElement)(component, rest, error) : error : null;\n    };\n    return ErrorMessageImpl;\n}(react_1.Component);\nvar ErrorMessage = /*#__PURE__*/ connect(ErrorMessageImpl);\nexports.ErrorMessage = ErrorMessage;\n/**\n * Custom Field component for quickly hooking into Formik\n * context and wiring up forms.\n */\nvar FastFieldInner = /*#__PURE__*/ function (_React$Component) {\n    _inheritsLoose(FastFieldInner, _React$Component);\n    function FastFieldInner(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this;\n        var render = props.render, children = props.children, component = props.component, is = props.as, name = props.name;\n        !!render ?  true ? (0, tiny_warning_1.default)(false, \"<FastField render> has been deprecated. Please use a child callback function instead: <FastField name={\" + name + \"}>{props => ...}</FastField> instead.\") : undefined : void 0;\n        !!(component && render) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <FastField component> and <FastField render> in the same <FastField> component; <FastField component> will be ignored') : undefined : void 0;\n        !!(is && children && isFunction(children)) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <FastField as> and <FastField children> as a function in the same <FastField> component; <FastField as> will be ignored.') : undefined : void 0;\n        !!(component && children && isFunction(children)) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <FastField component> and <FastField children> as a function in the same <FastField> component; <FastField component> will be ignored.') : undefined : void 0;\n        !!(render && children && !isEmptyChildren(children)) ?  true ? (0, tiny_warning_1.default)(false, 'You should not use <FastField render> and <FastField children> in the same <FastField> component; <FastField children> will be ignored') : undefined : void 0;\n        return _this;\n    }\n    var _proto = FastFieldInner.prototype;\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (this.props.shouldUpdate) {\n            return this.props.shouldUpdate(props, this.props);\n        }\n        else if (props.name !== this.props.name || getIn(props.formik.values, this.props.name) !== getIn(this.props.formik.values, this.props.name) || getIn(props.formik.errors, this.props.name) !== getIn(this.props.formik.errors, this.props.name) || getIn(props.formik.touched, this.props.name) !== getIn(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || props.formik.isSubmitting !== this.props.formik.isSubmitting) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    _proto.componentDidMount = function componentDidMount() {\n        // Register the Field with the parent Formik. Parent will cycle through\n        // registered Field's validate fns right prior to submit\n        this.props.formik.registerField(this.props.name, {\n            validate: this.props.validate\n        });\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.name !== prevProps.name) {\n            this.props.formik.unregisterField(prevProps.name);\n            this.props.formik.registerField(this.props.name, {\n                validate: this.props.validate\n            });\n        }\n        if (this.props.validate !== prevProps.validate) {\n            this.props.formik.registerField(this.props.name, {\n                validate: this.props.validate\n            });\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.props.formik.unregisterField(this.props.name);\n    };\n    _proto.render = function render() {\n        var _this$props = this.props, name = _this$props.name, render = _this$props.render, is = _this$props.as, children = _this$props.children, component = _this$props.component, formik = _this$props.formik, props = _objectWithoutPropertiesLoose(_this$props, [\"validate\", \"name\", \"render\", \"as\", \"children\", \"component\", \"shouldUpdate\", \"formik\"]);\n        var restOfFormik = _objectWithoutPropertiesLoose(formik, [\"validate\", \"validationSchema\"]);\n        var field = formik.getFieldProps(_extends({\n            name: name\n        }, props));\n        var meta = {\n            value: getIn(formik.values, name),\n            error: getIn(formik.errors, name),\n            touched: !!getIn(formik.touched, name),\n            initialValue: getIn(formik.initialValues, name),\n            initialTouched: !!getIn(formik.initialTouched, name),\n            initialError: getIn(formik.initialErrors, name)\n        };\n        var bag = {\n            field: field,\n            meta: meta,\n            form: restOfFormik\n        };\n        if (render) {\n            return render(bag);\n        }\n        if (isFunction(children)) {\n            return children(bag);\n        }\n        if (component) {\n            // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n            if (typeof component === 'string') {\n                var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n                return (0, react_1.createElement)(component, _extends({\n                    ref: innerRef\n                }, field, rest), children);\n            } // We don't pass `meta` for backwards compat\n            return (0, react_1.createElement)(component, _extends({\n                field: field,\n                form: formik\n            }, props), children);\n        } // default to input here so we can check for both `as` and `children` above\n        var asElement = is || 'input';\n        if (typeof asElement === 'string') {\n            var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose(props, [\"innerRef\"]);\n            return (0, react_1.createElement)(asElement, _extends({\n                ref: _innerRef\n            }, field, _rest), children);\n        }\n        return (0, react_1.createElement)(asElement, _extends({}, field, props), children);\n    };\n    return FastFieldInner;\n}(react_1.Component);\nvar FastField = /*#__PURE__*/ connect(FastFieldInner);\nexports.FastField = FastField;\n\n\n\n//# sourceURL=webpack:///./node_modules/formik/dist/formik.esm.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = (nBytes * 8) - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? (nBytes - 1) : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & ((1 << (-nBits)) - 1);\n    s >>= (-nBits);\n    nBits += eLen;\n    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }\n    m = e & ((1 << (-nBits)) - 1);\n    e >>= (-nBits);\n    nBits += mLen;\n    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }\n    if (e === 0) {\n        e = 1 - eBias;\n    }\n    else if (e === eMax) {\n        return m ? NaN : ((s ? -1 : 1) * Infinity);\n    }\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = (nBytes * 8) - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n    var i = isLE ? 0 : (nBytes - 1);\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    }\n    else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        }\n        else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        }\n        else if (e + eBias >= 1) {\n            m = ((value * c) - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        }\n        else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }\n    e = (e << mLen) | m;\n    eLen += mLen;\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }\n    buffer[offset + i - d] |= s * 128;\n};\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_DataView.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_DataView.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/* Built-in method references that are verified to be native. */\nvar DataView = (0, _getNative_js_1.default)(_root_js_1.default, 'DataView');\nexports.default = DataView;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_DataView.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Hash.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_Hash.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _hashClear_js_1 = __importDefault(__webpack_require__(/*! ./_hashClear.js */ \"./node_modules/lodash-es/_hashClear.js\"));\nvar _hashDelete_js_1 = __importDefault(__webpack_require__(/*! ./_hashDelete.js */ \"./node_modules/lodash-es/_hashDelete.js\"));\nvar _hashGet_js_1 = __importDefault(__webpack_require__(/*! ./_hashGet.js */ \"./node_modules/lodash-es/_hashGet.js\"));\nvar _hashHas_js_1 = __importDefault(__webpack_require__(/*! ./_hashHas.js */ \"./node_modules/lodash-es/_hashHas.js\"));\nvar _hashSet_js_1 = __importDefault(__webpack_require__(/*! ./_hashSet.js */ \"./node_modules/lodash-es/_hashSet.js\"));\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear_js_1.default;\nHash.prototype['delete'] = _hashDelete_js_1.default;\nHash.prototype.get = _hashGet_js_1.default;\nHash.prototype.has = _hashHas_js_1.default;\nHash.prototype.set = _hashSet_js_1.default;\nexports.default = Hash;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Hash.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_ListCache.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_ListCache.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _listCacheClear_js_1 = __importDefault(__webpack_require__(/*! ./_listCacheClear.js */ \"./node_modules/lodash-es/_listCacheClear.js\"));\nvar _listCacheDelete_js_1 = __importDefault(__webpack_require__(/*! ./_listCacheDelete.js */ \"./node_modules/lodash-es/_listCacheDelete.js\"));\nvar _listCacheGet_js_1 = __importDefault(__webpack_require__(/*! ./_listCacheGet.js */ \"./node_modules/lodash-es/_listCacheGet.js\"));\nvar _listCacheHas_js_1 = __importDefault(__webpack_require__(/*! ./_listCacheHas.js */ \"./node_modules/lodash-es/_listCacheHas.js\"));\nvar _listCacheSet_js_1 = __importDefault(__webpack_require__(/*! ./_listCacheSet.js */ \"./node_modules/lodash-es/_listCacheSet.js\"));\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear_js_1.default;\nListCache.prototype['delete'] = _listCacheDelete_js_1.default;\nListCache.prototype.get = _listCacheGet_js_1.default;\nListCache.prototype.has = _listCacheHas_js_1.default;\nListCache.prototype.set = _listCacheSet_js_1.default;\nexports.default = ListCache;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_ListCache.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Map.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Map.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/* Built-in method references that are verified to be native. */\nvar Map = (0, _getNative_js_1.default)(_root_js_1.default, 'Map');\nexports.default = Map;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Map.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_MapCache.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_MapCache.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _mapCacheClear_js_1 = __importDefault(__webpack_require__(/*! ./_mapCacheClear.js */ \"./node_modules/lodash-es/_mapCacheClear.js\"));\nvar _mapCacheDelete_js_1 = __importDefault(__webpack_require__(/*! ./_mapCacheDelete.js */ \"./node_modules/lodash-es/_mapCacheDelete.js\"));\nvar _mapCacheGet_js_1 = __importDefault(__webpack_require__(/*! ./_mapCacheGet.js */ \"./node_modules/lodash-es/_mapCacheGet.js\"));\nvar _mapCacheHas_js_1 = __importDefault(__webpack_require__(/*! ./_mapCacheHas.js */ \"./node_modules/lodash-es/_mapCacheHas.js\"));\nvar _mapCacheSet_js_1 = __importDefault(__webpack_require__(/*! ./_mapCacheSet.js */ \"./node_modules/lodash-es/_mapCacheSet.js\"));\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear_js_1.default;\nMapCache.prototype['delete'] = _mapCacheDelete_js_1.default;\nMapCache.prototype.get = _mapCacheGet_js_1.default;\nMapCache.prototype.has = _mapCacheHas_js_1.default;\nMapCache.prototype.set = _mapCacheSet_js_1.default;\nexports.default = MapCache;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_MapCache.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Promise.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_Promise.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/* Built-in method references that are verified to be native. */\nvar Promise = (0, _getNative_js_1.default)(_root_js_1.default, 'Promise');\nexports.default = Promise;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Promise.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Set.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Set.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/* Built-in method references that are verified to be native. */\nvar Set = (0, _getNative_js_1.default)(_root_js_1.default, 'Set');\nexports.default = Set;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Set.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Stack.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_Stack.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ListCache_js_1 = __importDefault(__webpack_require__(/*! ./_ListCache.js */ \"./node_modules/lodash-es/_ListCache.js\"));\nvar _stackClear_js_1 = __importDefault(__webpack_require__(/*! ./_stackClear.js */ \"./node_modules/lodash-es/_stackClear.js\"));\nvar _stackDelete_js_1 = __importDefault(__webpack_require__(/*! ./_stackDelete.js */ \"./node_modules/lodash-es/_stackDelete.js\"));\nvar _stackGet_js_1 = __importDefault(__webpack_require__(/*! ./_stackGet.js */ \"./node_modules/lodash-es/_stackGet.js\"));\nvar _stackHas_js_1 = __importDefault(__webpack_require__(/*! ./_stackHas.js */ \"./node_modules/lodash-es/_stackHas.js\"));\nvar _stackSet_js_1 = __importDefault(__webpack_require__(/*! ./_stackSet.js */ \"./node_modules/lodash-es/_stackSet.js\"));\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n    var data = this.__data__ = new _ListCache_js_1.default(entries);\n    this.size = data.size;\n}\n// Add methods to `Stack`.\nStack.prototype.clear = _stackClear_js_1.default;\nStack.prototype['delete'] = _stackDelete_js_1.default;\nStack.prototype.get = _stackGet_js_1.default;\nStack.prototype.has = _stackHas_js_1.default;\nStack.prototype.set = _stackSet_js_1.default;\nexports.default = Stack;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Stack.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Symbol.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/** Built-in value references. */\nvar Symbol = _root_js_1.default.Symbol;\nexports.default = Symbol;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Symbol.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_Uint8Array.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_Uint8Array.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/** Built-in value references. */\nvar Uint8Array = _root_js_1.default.Uint8Array;\nexports.default = Uint8Array;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_Uint8Array.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_WeakMap.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_WeakMap.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/* Built-in method references that are verified to be native. */\nvar WeakMap = (0, _getNative_js_1.default)(_root_js_1.default, 'WeakMap');\nexports.default = WeakMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_WeakMap.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_arrayEach.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arrayEach.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n            break;\n        }\n    }\n    return array;\n}\nexports.default = arrayEach;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_arrayEach.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_arrayFilter.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_arrayFilter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n    while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n            result[resIndex++] = value;\n        }\n    }\n    return result;\n}\nexports.default = arrayFilter;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_arrayFilter.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_arrayLikeKeys.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_arrayLikeKeys.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseTimes_js_1 = __importDefault(__webpack_require__(/*! ./_baseTimes.js */ \"./node_modules/lodash-es/_baseTimes.js\"));\nvar isArguments_js_1 = __importDefault(__webpack_require__(/*! ./isArguments.js */ \"./node_modules/lodash-es/isArguments.js\"));\nvar isArray_js_1 = __importDefault(__webpack_require__(/*! ./isArray.js */ \"./node_modules/lodash-es/isArray.js\"));\nvar isBuffer_js_1 = __importDefault(__webpack_require__(/*! ./isBuffer.js */ \"./node_modules/lodash-es/isBuffer.js\"));\nvar _isIndex_js_1 = __importDefault(__webpack_require__(/*! ./_isIndex.js */ \"./node_modules/lodash-es/_isIndex.js\"));\nvar isTypedArray_js_1 = __importDefault(__webpack_require__(/*! ./isTypedArray.js */ \"./node_modules/lodash-es/isTypedArray.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n    var isArr = (0, isArray_js_1.default)(value), isArg = !isArr && (0, isArguments_js_1.default)(value), isBuff = !isArr && !isArg && (0, isBuffer_js_1.default)(value), isType = !isArr && !isArg && !isBuff && (0, isTypedArray_js_1.default)(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? (0, _baseTimes_js_1.default)(value.length, String) : [], length = result.length;\n    for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n            // Safari 9 has enumerable `arguments.length` in strict mode.\n            key == 'length' ||\n                // Node.js 0.10 has enumerable non-index properties on buffers.\n                (isBuff && (key == 'offset' || key == 'parent')) ||\n                // PhantomJS 2 has enumerable non-index properties on typed arrays.\n                (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n                // Skip index properties.\n                (0, _isIndex_js_1.default)(key, length)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nexports.default = arrayLikeKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_arrayLikeKeys.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_arrayMap.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_arrayMap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n    var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n    while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n}\nexports.default = arrayMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_arrayMap.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_arrayPush.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arrayPush.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n    var index = -1, length = values.length, offset = array.length;\n    while (++index < length) {\n        array[offset + index] = values[index];\n    }\n    return array;\n}\nexports.default = arrayPush;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_arrayPush.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_assignValue.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_assignValue.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseAssignValue_js_1 = __importDefault(__webpack_require__(/*! ./_baseAssignValue.js */ \"./node_modules/lodash-es/_baseAssignValue.js\"));\nvar eq_js_1 = __importDefault(__webpack_require__(/*! ./eq.js */ \"./node_modules/lodash-es/eq.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && (0, eq_js_1.default)(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n        (0, _baseAssignValue_js_1.default)(object, key, value);\n    }\n}\nexports.default = assignValue;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_assignValue.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_assocIndexOf.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_assocIndexOf.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar eq_js_1 = __importDefault(__webpack_require__(/*! ./eq.js */ \"./node_modules/lodash-es/eq.js\"));\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n        if ((0, eq_js_1.default)(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n}\nexports.default = assocIndexOf;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_assocIndexOf.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseAssign.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseAssign.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _copyObject_js_1 = __importDefault(__webpack_require__(/*! ./_copyObject.js */ \"./node_modules/lodash-es/_copyObject.js\"));\nvar keys_js_1 = __importDefault(__webpack_require__(/*! ./keys.js */ \"./node_modules/lodash-es/keys.js\"));\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n    return object && (0, _copyObject_js_1.default)(source, (0, keys_js_1.default)(source), object);\n}\nexports.default = baseAssign;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseAssign.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseAssignIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignIn.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _copyObject_js_1 = __importDefault(__webpack_require__(/*! ./_copyObject.js */ \"./node_modules/lodash-es/_copyObject.js\"));\nvar keysIn_js_1 = __importDefault(__webpack_require__(/*! ./keysIn.js */ \"./node_modules/lodash-es/keysIn.js\"));\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n    return object && (0, _copyObject_js_1.default)(source, (0, keysIn_js_1.default)(source), object);\n}\nexports.default = baseAssignIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseAssignIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseAssignValue.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignValue.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _defineProperty_js_1 = __importDefault(__webpack_require__(/*! ./_defineProperty.js */ \"./node_modules/lodash-es/_defineProperty.js\"));\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n    if (key == '__proto__' && _defineProperty_js_1.default) {\n        (0, _defineProperty_js_1.default)(object, key, {\n            'configurable': true,\n            'enumerable': true,\n            'value': value,\n            'writable': true\n        });\n    }\n    else {\n        object[key] = value;\n    }\n}\nexports.default = baseAssignValue;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseAssignValue.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseClone.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseClone.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Stack_js_1 = __importDefault(__webpack_require__(/*! ./_Stack.js */ \"./node_modules/lodash-es/_Stack.js\"));\nvar _arrayEach_js_1 = __importDefault(__webpack_require__(/*! ./_arrayEach.js */ \"./node_modules/lodash-es/_arrayEach.js\"));\nvar _assignValue_js_1 = __importDefault(__webpack_require__(/*! ./_assignValue.js */ \"./node_modules/lodash-es/_assignValue.js\"));\nvar _baseAssign_js_1 = __importDefault(__webpack_require__(/*! ./_baseAssign.js */ \"./node_modules/lodash-es/_baseAssign.js\"));\nvar _baseAssignIn_js_1 = __importDefault(__webpack_require__(/*! ./_baseAssignIn.js */ \"./node_modules/lodash-es/_baseAssignIn.js\"));\nvar _cloneBuffer_js_1 = __importDefault(__webpack_require__(/*! ./_cloneBuffer.js */ \"./node_modules/lodash-es/_cloneBuffer.js\"));\nvar _copyArray_js_1 = __importDefault(__webpack_require__(/*! ./_copyArray.js */ \"./node_modules/lodash-es/_copyArray.js\"));\nvar _copySymbols_js_1 = __importDefault(__webpack_require__(/*! ./_copySymbols.js */ \"./node_modules/lodash-es/_copySymbols.js\"));\nvar _copySymbolsIn_js_1 = __importDefault(__webpack_require__(/*! ./_copySymbolsIn.js */ \"./node_modules/lodash-es/_copySymbolsIn.js\"));\nvar _getAllKeys_js_1 = __importDefault(__webpack_require__(/*! ./_getAllKeys.js */ \"./node_modules/lodash-es/_getAllKeys.js\"));\nvar _getAllKeysIn_js_1 = __importDefault(__webpack_require__(/*! ./_getAllKeysIn.js */ \"./node_modules/lodash-es/_getAllKeysIn.js\"));\nvar _getTag_js_1 = __importDefault(__webpack_require__(/*! ./_getTag.js */ \"./node_modules/lodash-es/_getTag.js\"));\nvar _initCloneArray_js_1 = __importDefault(__webpack_require__(/*! ./_initCloneArray.js */ \"./node_modules/lodash-es/_initCloneArray.js\"));\nvar _initCloneByTag_js_1 = __importDefault(__webpack_require__(/*! ./_initCloneByTag.js */ \"./node_modules/lodash-es/_initCloneByTag.js\"));\nvar _initCloneObject_js_1 = __importDefault(__webpack_require__(/*! ./_initCloneObject.js */ \"./node_modules/lodash-es/_initCloneObject.js\"));\nvar isArray_js_1 = __importDefault(__webpack_require__(/*! ./isArray.js */ \"./node_modules/lodash-es/isArray.js\"));\nvar isBuffer_js_1 = __importDefault(__webpack_require__(/*! ./isBuffer.js */ \"./node_modules/lodash-es/isBuffer.js\"));\nvar isMap_js_1 = __importDefault(__webpack_require__(/*! ./isMap.js */ \"./node_modules/lodash-es/isMap.js\"));\nvar isObject_js_1 = __importDefault(__webpack_require__(/*! ./isObject.js */ \"./node_modules/lodash-es/isObject.js\"));\nvar isSet_js_1 = __importDefault(__webpack_require__(/*! ./isSet.js */ \"./node_modules/lodash-es/isSet.js\"));\nvar keys_js_1 = __importDefault(__webpack_require__(/*! ./keys.js */ \"./node_modules/lodash-es/keys.js\"));\nvar keysIn_js_1 = __importDefault(__webpack_require__(/*! ./keysIn.js */ \"./node_modules/lodash-es/keysIn.js\"));\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';\nvar arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\n    cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n        cloneableTags[boolTag] = cloneableTags[dateTag] =\n            cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n                cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n                    cloneableTags[int32Tag] = cloneableTags[mapTag] =\n                        cloneableTags[numberTag] = cloneableTags[objectTag] =\n                            cloneableTags[regexpTag] = cloneableTags[setTag] =\n                                cloneableTags[stringTag] = cloneableTags[symbolTag] =\n                                    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n                                        cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\n    cloneableTags[weakMapTag] = false;\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n        return result;\n    }\n    if (!(0, isObject_js_1.default)(value)) {\n        return value;\n    }\n    var isArr = (0, isArray_js_1.default)(value);\n    if (isArr) {\n        result = (0, _initCloneArray_js_1.default)(value);\n        if (!isDeep) {\n            return (0, _copyArray_js_1.default)(value, result);\n        }\n    }\n    else {\n        var tag = (0, _getTag_js_1.default)(value), isFunc = tag == funcTag || tag == genTag;\n        if ((0, isBuffer_js_1.default)(value)) {\n            return (0, _cloneBuffer_js_1.default)(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n            result = (isFlat || isFunc) ? {} : (0, _initCloneObject_js_1.default)(value);\n            if (!isDeep) {\n                return isFlat\n                    ? (0, _copySymbolsIn_js_1.default)(value, (0, _baseAssignIn_js_1.default)(result, value))\n                    : (0, _copySymbols_js_1.default)(value, (0, _baseAssign_js_1.default)(result, value));\n            }\n        }\n        else {\n            if (!cloneableTags[tag]) {\n                return object ? value : {};\n            }\n            result = (0, _initCloneByTag_js_1.default)(value, tag, isDeep);\n        }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new _Stack_js_1.default);\n    var stacked = stack.get(value);\n    if (stacked) {\n        return stacked;\n    }\n    stack.set(value, result);\n    if ((0, isSet_js_1.default)(value)) {\n        value.forEach(function (subValue) {\n            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n    }\n    else if ((0, isMap_js_1.default)(value)) {\n        value.forEach(function (subValue, key) {\n            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n    }\n    var keysFunc = isFull\n        ? (isFlat ? _getAllKeysIn_js_1.default : _getAllKeys_js_1.default)\n        : (isFlat ? keysIn_js_1.default : keys_js_1.default);\n    var props = isArr ? undefined : keysFunc(value);\n    (0, _arrayEach_js_1.default)(props || value, function (subValue, key) {\n        if (props) {\n            key = subValue;\n            subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        (0, _assignValue_js_1.default)(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n    return result;\n}\nexports.default = baseClone;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseClone.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseCreate.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseCreate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isObject_js_1 = __importDefault(__webpack_require__(/*! ./isObject.js */ \"./node_modules/lodash-es/isObject.js\"));\n/** Built-in value references. */\nvar objectCreate = Object.create;\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function () {\n    function object() { }\n    return function (proto) {\n        if (!(0, isObject_js_1.default)(proto)) {\n            return {};\n        }\n        if (objectCreate) {\n            return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n    };\n}());\nexports.default = baseCreate;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseCreate.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseGetAllKeys.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseGetAllKeys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _arrayPush_js_1 = __importDefault(__webpack_require__(/*! ./_arrayPush.js */ \"./node_modules/lodash-es/_arrayPush.js\"));\nvar isArray_js_1 = __importDefault(__webpack_require__(/*! ./isArray.js */ \"./node_modules/lodash-es/isArray.js\"));\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return (0, isArray_js_1.default)(object) ? result : (0, _arrayPush_js_1.default)(result, symbolsFunc(object));\n}\nexports.default = baseGetAllKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseGetAllKeys.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseGetTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Symbol_js_1 = __importDefault(__webpack_require__(/*! ./_Symbol.js */ \"./node_modules/lodash-es/_Symbol.js\"));\nvar _getRawTag_js_1 = __importDefault(__webpack_require__(/*! ./_getRawTag.js */ \"./node_modules/lodash-es/_getRawTag.js\"));\nvar _objectToString_js_1 = __importDefault(__webpack_require__(/*! ./_objectToString.js */ \"./node_modules/lodash-es/_objectToString.js\"));\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]', undefinedTag = '[object Undefined]';\n/** Built-in value references. */\nvar symToStringTag = _Symbol_js_1.default ? _Symbol_js_1.default.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return (symToStringTag && symToStringTag in Object(value))\n        ? (0, _getRawTag_js_1.default)(value)\n        : (0, _objectToString_js_1.default)(value);\n}\nexports.default = baseGetTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseGetTag.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsArguments.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsArguments.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetTag_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetTag.js */ \"./node_modules/lodash-es/_baseGetTag.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n    return (0, isObjectLike_js_1.default)(value) && (0, _baseGetTag_js_1.default)(value) == argsTag;\n}\nexports.default = baseIsArguments;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseIsArguments.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsMap.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsMap.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getTag_js_1 = __importDefault(__webpack_require__(/*! ./_getTag.js */ \"./node_modules/lodash-es/_getTag.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n    return (0, isObjectLike_js_1.default)(value) && (0, _getTag_js_1.default)(value) == mapTag;\n}\nexports.default = baseIsMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseIsMap.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsNative.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNative.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isFunction_js_1 = __importDefault(__webpack_require__(/*! ./isFunction.js */ \"./node_modules/lodash-es/isFunction.js\"));\nvar _isMasked_js_1 = __importDefault(__webpack_require__(/*! ./_isMasked.js */ \"./node_modules/lodash-es/_isMasked.js\"));\nvar isObject_js_1 = __importDefault(__webpack_require__(/*! ./isObject.js */ \"./node_modules/lodash-es/isObject.js\"));\nvar _toSource_js_1 = __importDefault(__webpack_require__(/*! ./_toSource.js */ \"./node_modules/lodash-es/_toSource.js\"));\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n/** Used for built-in method references. */\nvar funcProto = Function.prototype, objectProto = Object.prototype;\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n        .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n    if (!(0, isObject_js_1.default)(value) || (0, _isMasked_js_1.default)(value)) {\n        return false;\n    }\n    var pattern = (0, isFunction_js_1.default)(value) ? reIsNative : reIsHostCtor;\n    return pattern.test((0, _toSource_js_1.default)(value));\n}\nexports.default = baseIsNative;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseIsNative.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getTag_js_1 = __importDefault(__webpack_require__(/*! ./_getTag.js */ \"./node_modules/lodash-es/_getTag.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n    return (0, isObjectLike_js_1.default)(value) && (0, _getTag_js_1.default)(value) == setTag;\n}\nexports.default = baseIsSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseIsSet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsTypedArray.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsTypedArray.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetTag_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetTag.js */ \"./node_modules/lodash-es/_baseGetTag.js\"));\nvar isLength_js_1 = __importDefault(__webpack_require__(/*! ./isLength.js */ \"./node_modules/lodash-es/isLength.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';\nvar arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n        typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n                typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n        typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n            typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n                typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n                    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n                        typedArrayTags[setTag] = typedArrayTags[stringTag] =\n                            typedArrayTags[weakMapTag] = false;\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n    return (0, isObjectLike_js_1.default)(value) &&\n        (0, isLength_js_1.default)(value.length) && !!typedArrayTags[(0, _baseGetTag_js_1.default)(value)];\n}\nexports.default = baseIsTypedArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseIsTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseKeys.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _isPrototype_js_1 = __importDefault(__webpack_require__(/*! ./_isPrototype.js */ \"./node_modules/lodash-es/_isPrototype.js\"));\nvar _nativeKeys_js_1 = __importDefault(__webpack_require__(/*! ./_nativeKeys.js */ \"./node_modules/lodash-es/_nativeKeys.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n    if (!(0, _isPrototype_js_1.default)(object)) {\n        return (0, _nativeKeys_js_1.default)(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n            result.push(key);\n        }\n    }\n    return result;\n}\nexports.default = baseKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseKeys.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseKeysIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeysIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isObject_js_1 = __importDefault(__webpack_require__(/*! ./isObject.js */ \"./node_modules/lodash-es/isObject.js\"));\nvar _isPrototype_js_1 = __importDefault(__webpack_require__(/*! ./_isPrototype.js */ \"./node_modules/lodash-es/_isPrototype.js\"));\nvar _nativeKeysIn_js_1 = __importDefault(__webpack_require__(/*! ./_nativeKeysIn.js */ \"./node_modules/lodash-es/_nativeKeysIn.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n    if (!(0, isObject_js_1.default)(object)) {\n        return (0, _nativeKeysIn_js_1.default)(object);\n    }\n    var isProto = (0, _isPrototype_js_1.default)(object), result = [];\n    for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nexports.default = baseKeysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseTimes.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseTimes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n    var index = -1, result = Array(n);\n    while (++index < n) {\n        result[index] = iteratee(index);\n    }\n    return result;\n}\nexports.default = baseTimes;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseTimes.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Symbol_js_1 = __importDefault(__webpack_require__(/*! ./_Symbol.js */ \"./node_modules/lodash-es/_Symbol.js\"));\nvar _arrayMap_js_1 = __importDefault(__webpack_require__(/*! ./_arrayMap.js */ \"./node_modules/lodash-es/_arrayMap.js\"));\nvar isArray_js_1 = __importDefault(__webpack_require__(/*! ./isArray.js */ \"./node_modules/lodash-es/isArray.js\"));\nvar isSymbol_js_1 = __importDefault(__webpack_require__(/*! ./isSymbol.js */ \"./node_modules/lodash-es/isSymbol.js\"));\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol_js_1.default ? _Symbol_js_1.default.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n        return value;\n    }\n    if ((0, isArray_js_1.default)(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return (0, _arrayMap_js_1.default)(value, baseToString) + '';\n    }\n    if ((0, isSymbol_js_1.default)(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\nexports.default = baseToString;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseToString.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_baseUnary.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseUnary.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n    return function (value) {\n        return func(value);\n    };\n}\nexports.default = baseUnary;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_baseUnary.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_cloneArrayBuffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_cloneArrayBuffer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Uint8Array_js_1 = __importDefault(__webpack_require__(/*! ./_Uint8Array.js */ \"./node_modules/lodash-es/_Uint8Array.js\"));\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new _Uint8Array_js_1.default(result).set(new _Uint8Array_js_1.default(arrayBuffer));\n    return result;\n}\nexports.default = cloneArrayBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_cloneArrayBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_cloneBuffer.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneBuffer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n/** Built-in value references. */\nvar Buffer = moduleExports ? _root_js_1.default.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n        return buffer.slice();\n    }\n    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n    buffer.copy(result);\n    return result;\n}\nexports.default = cloneBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_cloneBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_cloneDataView.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_cloneDataView.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _cloneArrayBuffer_js_1 = __importDefault(__webpack_require__(/*! ./_cloneArrayBuffer.js */ \"./node_modules/lodash-es/_cloneArrayBuffer.js\"));\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? (0, _cloneArrayBuffer_js_1.default)(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nexports.default = cloneDataView;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_cloneDataView.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_cloneRegExp.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneRegExp.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n}\nexports.default = cloneRegExp;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_cloneRegExp.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_cloneSymbol.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneSymbol.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Symbol_js_1 = __importDefault(__webpack_require__(/*! ./_Symbol.js */ \"./node_modules/lodash-es/_Symbol.js\"));\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol_js_1.default ? _Symbol_js_1.default.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\nexports.default = cloneSymbol;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_cloneSymbol.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_cloneTypedArray.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_cloneTypedArray.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _cloneArrayBuffer_js_1 = __importDefault(__webpack_require__(/*! ./_cloneArrayBuffer.js */ \"./node_modules/lodash-es/_cloneArrayBuffer.js\"));\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? (0, _cloneArrayBuffer_js_1.default)(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nexports.default = cloneTypedArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_cloneTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_copyArray.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_copyArray.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n    var index = -1, length = source.length;\n    array || (array = Array(length));\n    while (++index < length) {\n        array[index] = source[index];\n    }\n    return array;\n}\nexports.default = copyArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_copyArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_copyObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_copyObject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _assignValue_js_1 = __importDefault(__webpack_require__(/*! ./_assignValue.js */ \"./node_modules/lodash-es/_assignValue.js\"));\nvar _baseAssignValue_js_1 = __importDefault(__webpack_require__(/*! ./_baseAssignValue.js */ \"./node_modules/lodash-es/_baseAssignValue.js\"));\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n    var index = -1, length = props.length;\n    while (++index < length) {\n        var key = props[index];\n        var newValue = customizer\n            ? customizer(object[key], source[key], key, object, source)\n            : undefined;\n        if (newValue === undefined) {\n            newValue = source[key];\n        }\n        if (isNew) {\n            (0, _baseAssignValue_js_1.default)(object, key, newValue);\n        }\n        else {\n            (0, _assignValue_js_1.default)(object, key, newValue);\n        }\n    }\n    return object;\n}\nexports.default = copyObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_copyObject.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_copySymbols.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_copySymbols.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _copyObject_js_1 = __importDefault(__webpack_require__(/*! ./_copyObject.js */ \"./node_modules/lodash-es/_copyObject.js\"));\nvar _getSymbols_js_1 = __importDefault(__webpack_require__(/*! ./_getSymbols.js */ \"./node_modules/lodash-es/_getSymbols.js\"));\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n    return (0, _copyObject_js_1.default)(source, (0, _getSymbols_js_1.default)(source), object);\n}\nexports.default = copySymbols;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_copySymbols.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_copySymbolsIn.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_copySymbolsIn.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _copyObject_js_1 = __importDefault(__webpack_require__(/*! ./_copyObject.js */ \"./node_modules/lodash-es/_copyObject.js\"));\nvar _getSymbolsIn_js_1 = __importDefault(__webpack_require__(/*! ./_getSymbolsIn.js */ \"./node_modules/lodash-es/_getSymbolsIn.js\"));\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n    return (0, _copyObject_js_1.default)(source, (0, _getSymbolsIn_js_1.default)(source), object);\n}\nexports.default = copySymbolsIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_copySymbolsIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_coreJsData.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_coreJsData.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root_js_1.default['__core-js_shared__'];\nexports.default = coreJsData;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_coreJsData.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_defineProperty.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_defineProperty.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\nvar defineProperty = (function () {\n    try {\n        var func = (0, _getNative_js_1.default)(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n    }\n    catch (e) { }\n}());\nexports.default = defineProperty;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_defineProperty.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_freeGlobal.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\nexports.default = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_freeGlobal.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getAllKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getAllKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetAllKeys_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetAllKeys.js */ \"./node_modules/lodash-es/_baseGetAllKeys.js\"));\nvar _getSymbols_js_1 = __importDefault(__webpack_require__(/*! ./_getSymbols.js */ \"./node_modules/lodash-es/_getSymbols.js\"));\nvar keys_js_1 = __importDefault(__webpack_require__(/*! ./keys.js */ \"./node_modules/lodash-es/keys.js\"));\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n    return (0, _baseGetAllKeys_js_1.default)(object, keys_js_1.default, _getSymbols_js_1.default);\n}\nexports.default = getAllKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getAllKeys.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getAllKeysIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getAllKeysIn.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetAllKeys_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetAllKeys.js */ \"./node_modules/lodash-es/_baseGetAllKeys.js\"));\nvar _getSymbolsIn_js_1 = __importDefault(__webpack_require__(/*! ./_getSymbolsIn.js */ \"./node_modules/lodash-es/_getSymbolsIn.js\"));\nvar keysIn_js_1 = __importDefault(__webpack_require__(/*! ./keysIn.js */ \"./node_modules/lodash-es/keysIn.js\"));\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n    return (0, _baseGetAllKeys_js_1.default)(object, keysIn_js_1.default, _getSymbolsIn_js_1.default);\n}\nexports.default = getAllKeysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getAllKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getMapData.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getMapData.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _isKeyable_js_1 = __importDefault(__webpack_require__(/*! ./_isKeyable.js */ \"./node_modules/lodash-es/_isKeyable.js\"));\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n    var data = map.__data__;\n    return (0, _isKeyable_js_1.default)(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n}\nexports.default = getMapData;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getMapData.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseIsNative_js_1 = __importDefault(__webpack_require__(/*! ./_baseIsNative.js */ \"./node_modules/lodash-es/_baseIsNative.js\"));\nvar _getValue_js_1 = __importDefault(__webpack_require__(/*! ./_getValue.js */ \"./node_modules/lodash-es/_getValue.js\"));\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n    var value = (0, _getValue_js_1.default)(object, key);\n    return (0, _baseIsNative_js_1.default)(value) ? value : undefined;\n}\nexports.default = getNative;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getNative.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getPrototype.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getPrototype.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _overArg_js_1 = __importDefault(__webpack_require__(/*! ./_overArg.js */ \"./node_modules/lodash-es/_overArg.js\"));\n/** Built-in value references. */\nvar getPrototype = (0, _overArg_js_1.default)(Object.getPrototypeOf, Object);\nexports.default = getPrototype;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getPrototype.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getRawTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Symbol_js_1 = __importDefault(__webpack_require__(/*! ./_Symbol.js */ \"./node_modules/lodash-es/_Symbol.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n/** Built-in value references. */\nvar symToStringTag = _Symbol_js_1.default ? _Symbol_js_1.default.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n    try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n    }\n    catch (e) { }\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n        if (isOwn) {\n            value[symToStringTag] = tag;\n        }\n        else {\n            delete value[symToStringTag];\n        }\n    }\n    return result;\n}\nexports.default = getRawTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getRawTag.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getSymbols.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getSymbols.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _arrayFilter_js_1 = __importDefault(__webpack_require__(/*! ./_arrayFilter.js */ \"./node_modules/lodash-es/_arrayFilter.js\"));\nvar stubArray_js_1 = __importDefault(__webpack_require__(/*! ./stubArray.js */ \"./node_modules/lodash-es/stubArray.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray_js_1.default : function (object) {\n    if (object == null) {\n        return [];\n    }\n    object = Object(object);\n    return (0, _arrayFilter_js_1.default)(nativeGetSymbols(object), function (symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n    });\n};\nexports.default = getSymbols;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getSymbols.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getSymbolsIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getSymbolsIn.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _arrayPush_js_1 = __importDefault(__webpack_require__(/*! ./_arrayPush.js */ \"./node_modules/lodash-es/_arrayPush.js\"));\nvar _getPrototype_js_1 = __importDefault(__webpack_require__(/*! ./_getPrototype.js */ \"./node_modules/lodash-es/_getPrototype.js\"));\nvar _getSymbols_js_1 = __importDefault(__webpack_require__(/*! ./_getSymbols.js */ \"./node_modules/lodash-es/_getSymbols.js\"));\nvar stubArray_js_1 = __importDefault(__webpack_require__(/*! ./stubArray.js */ \"./node_modules/lodash-es/stubArray.js\"));\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray_js_1.default : function (object) {\n    var result = [];\n    while (object) {\n        (0, _arrayPush_js_1.default)(result, (0, _getSymbols_js_1.default)(object));\n        object = (0, _getPrototype_js_1.default)(object);\n    }\n    return result;\n};\nexports.default = getSymbolsIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getSymbolsIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_getTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _DataView_js_1 = __importDefault(__webpack_require__(/*! ./_DataView.js */ \"./node_modules/lodash-es/_DataView.js\"));\nvar _Map_js_1 = __importDefault(__webpack_require__(/*! ./_Map.js */ \"./node_modules/lodash-es/_Map.js\"));\nvar _Promise_js_1 = __importDefault(__webpack_require__(/*! ./_Promise.js */ \"./node_modules/lodash-es/_Promise.js\"));\nvar _Set_js_1 = __importDefault(__webpack_require__(/*! ./_Set.js */ \"./node_modules/lodash-es/_Set.js\"));\nvar _WeakMap_js_1 = __importDefault(__webpack_require__(/*! ./_WeakMap.js */ \"./node_modules/lodash-es/_WeakMap.js\"));\nvar _baseGetTag_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetTag.js */ \"./node_modules/lodash-es/_baseGetTag.js\"));\nvar _toSource_js_1 = __importDefault(__webpack_require__(/*! ./_toSource.js */ \"./node_modules/lodash-es/_toSource.js\"));\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';\nvar dataViewTag = '[object DataView]';\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = (0, _toSource_js_1.default)(_DataView_js_1.default), mapCtorString = (0, _toSource_js_1.default)(_Map_js_1.default), promiseCtorString = (0, _toSource_js_1.default)(_Promise_js_1.default), setCtorString = (0, _toSource_js_1.default)(_Set_js_1.default), weakMapCtorString = (0, _toSource_js_1.default)(_WeakMap_js_1.default);\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = _baseGetTag_js_1.default;\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((_DataView_js_1.default && getTag(new _DataView_js_1.default(new ArrayBuffer(1))) != dataViewTag) ||\n    (_Map_js_1.default && getTag(new _Map_js_1.default) != mapTag) ||\n    (_Promise_js_1.default && getTag(_Promise_js_1.default.resolve()) != promiseTag) ||\n    (_Set_js_1.default && getTag(new _Set_js_1.default) != setTag) ||\n    (_WeakMap_js_1.default && getTag(new _WeakMap_js_1.default) != weakMapTag)) {\n    getTag = function (value) {\n        var result = (0, _baseGetTag_js_1.default)(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? (0, _toSource_js_1.default)(Ctor) : '';\n        if (ctorString) {\n            switch (ctorString) {\n                case dataViewCtorString: return dataViewTag;\n                case mapCtorString: return mapTag;\n                case promiseCtorString: return promiseTag;\n                case setCtorString: return setTag;\n                case weakMapCtorString: return weakMapTag;\n            }\n        }\n        return result;\n    };\n}\nexports.default = getTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getTag.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_getValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_getValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n    return object == null ? undefined : object[key];\n}\nexports.default = getValue;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_getValue.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_hashClear.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_hashClear.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _nativeCreate_js_1 = __importDefault(__webpack_require__(/*! ./_nativeCreate.js */ \"./node_modules/lodash-es/_nativeCreate.js\"));\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n    this.__data__ = _nativeCreate_js_1.default ? (0, _nativeCreate_js_1.default)(null) : {};\n    this.size = 0;\n}\nexports.default = hashClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_hashClear.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_hashDelete.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_hashDelete.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n}\nexports.default = hashDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_hashDelete.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_hashGet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashGet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _nativeCreate_js_1 = __importDefault(__webpack_require__(/*! ./_nativeCreate.js */ \"./node_modules/lodash-es/_nativeCreate.js\"));\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n    var data = this.__data__;\n    if (_nativeCreate_js_1.default) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\nexports.default = hashGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_hashGet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_hashHas.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashHas.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _nativeCreate_js_1 = __importDefault(__webpack_require__(/*! ./_nativeCreate.js */ \"./node_modules/lodash-es/_nativeCreate.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n    var data = this.__data__;\n    return _nativeCreate_js_1.default ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\nexports.default = hashHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_hashHas.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_hashSet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashSet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _nativeCreate_js_1 = __importDefault(__webpack_require__(/*! ./_nativeCreate.js */ \"./node_modules/lodash-es/_nativeCreate.js\"));\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = (_nativeCreate_js_1.default && value === undefined) ? HASH_UNDEFINED : value;\n    return this;\n}\nexports.default = hashSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_hashSet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_initCloneArray.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneArray.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n    var length = array.length, result = new array.constructor(length);\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n    }\n    return result;\n}\nexports.default = initCloneArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_initCloneArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_initCloneByTag.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneByTag.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _cloneArrayBuffer_js_1 = __importDefault(__webpack_require__(/*! ./_cloneArrayBuffer.js */ \"./node_modules/lodash-es/_cloneArrayBuffer.js\"));\nvar _cloneDataView_js_1 = __importDefault(__webpack_require__(/*! ./_cloneDataView.js */ \"./node_modules/lodash-es/_cloneDataView.js\"));\nvar _cloneRegExp_js_1 = __importDefault(__webpack_require__(/*! ./_cloneRegExp.js */ \"./node_modules/lodash-es/_cloneRegExp.js\"));\nvar _cloneSymbol_js_1 = __importDefault(__webpack_require__(/*! ./_cloneSymbol.js */ \"./node_modules/lodash-es/_cloneSymbol.js\"));\nvar _cloneTypedArray_js_1 = __importDefault(__webpack_require__(/*! ./_cloneTypedArray.js */ \"./node_modules/lodash-es/_cloneTypedArray.js\"));\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';\nvar arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n    var Ctor = object.constructor;\n    switch (tag) {\n        case arrayBufferTag:\n            return (0, _cloneArrayBuffer_js_1.default)(object);\n        case boolTag:\n        case dateTag:\n            return new Ctor(+object);\n        case dataViewTag:\n            return (0, _cloneDataView_js_1.default)(object, isDeep);\n        case float32Tag:\n        case float64Tag:\n        case int8Tag:\n        case int16Tag:\n        case int32Tag:\n        case uint8Tag:\n        case uint8ClampedTag:\n        case uint16Tag:\n        case uint32Tag:\n            return (0, _cloneTypedArray_js_1.default)(object, isDeep);\n        case mapTag:\n            return new Ctor;\n        case numberTag:\n        case stringTag:\n            return new Ctor(object);\n        case regexpTag:\n            return (0, _cloneRegExp_js_1.default)(object);\n        case setTag:\n            return new Ctor;\n        case symbolTag:\n            return (0, _cloneSymbol_js_1.default)(object);\n    }\n}\nexports.default = initCloneByTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_initCloneByTag.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_initCloneObject.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneObject.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseCreate_js_1 = __importDefault(__webpack_require__(/*! ./_baseCreate.js */ \"./node_modules/lodash-es/_baseCreate.js\"));\nvar _getPrototype_js_1 = __importDefault(__webpack_require__(/*! ./_getPrototype.js */ \"./node_modules/lodash-es/_getPrototype.js\"));\nvar _isPrototype_js_1 = __importDefault(__webpack_require__(/*! ./_isPrototype.js */ \"./node_modules/lodash-es/_isPrototype.js\"));\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n    return (typeof object.constructor == 'function' && !(0, _isPrototype_js_1.default)(object))\n        ? (0, _baseCreate_js_1.default)((0, _getPrototype_js_1.default)(object))\n        : {};\n}\nexports.default = initCloneObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_initCloneObject.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_isIndex.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_isIndex.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length &&\n        (type == 'number' ||\n            (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\nexports.default = isIndex;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_isIndex.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_isKeyable.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_isKeyable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n    var type = typeof value;\n    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n}\nexports.default = isKeyable;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_isKeyable.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_isMasked.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_isMasked.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _coreJsData_js_1 = __importDefault(__webpack_require__(/*! ./_coreJsData.js */ \"./node_modules/lodash-es/_coreJsData.js\"));\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function () {\n    var uid = /[^.]+$/.exec(_coreJsData_js_1.default && _coreJsData_js_1.default.keys && _coreJsData_js_1.default.keys.IE_PROTO || '');\n    return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n    return !!maskSrcKey && (maskSrcKey in func);\n}\nexports.default = isMasked;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_isMasked.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_isPrototype.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_isPrototype.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n    var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n    return value === proto;\n}\nexports.default = isPrototype;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_isPrototype.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_listCacheClear.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheClear.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n}\nexports.default = listCacheClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_listCacheClear.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_listCacheDelete.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheDelete.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _assocIndexOf_js_1 = __importDefault(__webpack_require__(/*! ./_assocIndexOf.js */ \"./node_modules/lodash-es/_assocIndexOf.js\"));\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n    var data = this.__data__, index = (0, _assocIndexOf_js_1.default)(data, key);\n    if (index < 0) {\n        return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n        data.pop();\n    }\n    else {\n        splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n}\nexports.default = listCacheDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_listCacheDelete.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_listCacheGet.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheGet.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _assocIndexOf_js_1 = __importDefault(__webpack_require__(/*! ./_assocIndexOf.js */ \"./node_modules/lodash-es/_assocIndexOf.js\"));\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n    var data = this.__data__, index = (0, _assocIndexOf_js_1.default)(data, key);\n    return index < 0 ? undefined : data[index][1];\n}\nexports.default = listCacheGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_listCacheGet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_listCacheHas.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheHas.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _assocIndexOf_js_1 = __importDefault(__webpack_require__(/*! ./_assocIndexOf.js */ \"./node_modules/lodash-es/_assocIndexOf.js\"));\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n    return (0, _assocIndexOf_js_1.default)(this.__data__, key) > -1;\n}\nexports.default = listCacheHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_listCacheHas.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_listCacheSet.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheSet.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _assocIndexOf_js_1 = __importDefault(__webpack_require__(/*! ./_assocIndexOf.js */ \"./node_modules/lodash-es/_assocIndexOf.js\"));\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n    var data = this.__data__, index = (0, _assocIndexOf_js_1.default)(data, key);\n    if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n    }\n    else {\n        data[index][1] = value;\n    }\n    return this;\n}\nexports.default = listCacheSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_listCacheSet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheClear.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheClear.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _Hash_js_1 = __importDefault(__webpack_require__(/*! ./_Hash.js */ \"./node_modules/lodash-es/_Hash.js\"));\nvar _ListCache_js_1 = __importDefault(__webpack_require__(/*! ./_ListCache.js */ \"./node_modules/lodash-es/_ListCache.js\"));\nvar _Map_js_1 = __importDefault(__webpack_require__(/*! ./_Map.js */ \"./node_modules/lodash-es/_Map.js\"));\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n        'hash': new _Hash_js_1.default,\n        'map': new (_Map_js_1.default || _ListCache_js_1.default),\n        'string': new _Hash_js_1.default\n    };\n}\nexports.default = mapCacheClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_mapCacheClear.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheDelete.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheDelete.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getMapData_js_1 = __importDefault(__webpack_require__(/*! ./_getMapData.js */ \"./node_modules/lodash-es/_getMapData.js\"));\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n    var result = (0, _getMapData_js_1.default)(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n}\nexports.default = mapCacheDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_mapCacheDelete.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheGet.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheGet.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getMapData_js_1 = __importDefault(__webpack_require__(/*! ./_getMapData.js */ \"./node_modules/lodash-es/_getMapData.js\"));\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n    return (0, _getMapData_js_1.default)(this, key).get(key);\n}\nexports.default = mapCacheGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_mapCacheGet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheHas.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheHas.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getMapData_js_1 = __importDefault(__webpack_require__(/*! ./_getMapData.js */ \"./node_modules/lodash-es/_getMapData.js\"));\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n    return (0, _getMapData_js_1.default)(this, key).has(key);\n}\nexports.default = mapCacheHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_mapCacheHas.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheSet.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheSet.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getMapData_js_1 = __importDefault(__webpack_require__(/*! ./_getMapData.js */ \"./node_modules/lodash-es/_getMapData.js\"));\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n    var data = (0, _getMapData_js_1.default)(this, key), size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n}\nexports.default = mapCacheSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_mapCacheSet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_memoizeCapped.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_memoizeCapped.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar memoize_js_1 = __importDefault(__webpack_require__(/*! ./memoize.js */ \"./node_modules/lodash-es/memoize.js\"));\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n    var result = (0, memoize_js_1.default)(func, function (key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n            cache.clear();\n        }\n        return key;\n    });\n    var cache = result.cache;\n    return result;\n}\nexports.default = memoizeCapped;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_memoizeCapped.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_nativeCreate.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeCreate.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _getNative_js_1 = __importDefault(__webpack_require__(/*! ./_getNative.js */ \"./node_modules/lodash-es/_getNative.js\"));\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = (0, _getNative_js_1.default)(Object, 'create');\nexports.default = nativeCreate;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_nativeCreate.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _overArg_js_1 = __importDefault(__webpack_require__(/*! ./_overArg.js */ \"./node_modules/lodash-es/_overArg.js\"));\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = (0, _overArg_js_1.default)(Object.keys, Object);\nexports.default = nativeKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_nativeKeys.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeysIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeysIn.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n    var result = [];\n    if (object != null) {\n        for (var key in Object(object)) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nexports.default = nativeKeysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_nativeKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_nodeUtil.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_nodeUtil.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _freeGlobal_js_1 = __importDefault(__webpack_require__(/*! ./_freeGlobal.js */ \"./node_modules/lodash-es/_freeGlobal.js\"));\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && _freeGlobal_js_1.default.process;\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function () {\n    try {\n        // Use `util.types` for Node.js 10+.\n        var types = freeModule && freeModule.require && freeModule.require('util').types;\n        if (types) {\n            return types;\n        }\n        // Legacy `process.binding('util')` for Node.js < 10.\n        return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    }\n    catch (e) { }\n}());\nexports.default = nodeUtil;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_nodeUtil.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_objectToString.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n    return nativeObjectToString.call(value);\n}\nexports.default = objectToString;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_objectToString.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_overArg.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_overArg.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n    return function (arg) {\n        return func(transform(arg));\n    };\n}\nexports.default = overArg;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_overArg.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_root.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _freeGlobal_js_1 = __importDefault(__webpack_require__(/*! ./_freeGlobal.js */ \"./node_modules/lodash-es/_freeGlobal.js\"));\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\nvar root = _freeGlobal_js_1.default || freeSelf || Function('return this')();\nexports.default = root;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_root.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_stackClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_stackClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ListCache_js_1 = __importDefault(__webpack_require__(/*! ./_ListCache.js */ \"./node_modules/lodash-es/_ListCache.js\"));\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n    this.__data__ = new _ListCache_js_1.default;\n    this.size = 0;\n}\nexports.default = stackClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_stackClear.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_stackDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_stackDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n    var data = this.__data__, result = data['delete'](key);\n    this.size = data.size;\n    return result;\n}\nexports.default = stackDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_stackDelete.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_stackGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n    return this.__data__.get(key);\n}\nexports.default = stackGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_stackGet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_stackHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n    return this.__data__.has(key);\n}\nexports.default = stackHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_stackHas.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_stackSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ListCache_js_1 = __importDefault(__webpack_require__(/*! ./_ListCache.js */ \"./node_modules/lodash-es/_ListCache.js\"));\nvar _Map_js_1 = __importDefault(__webpack_require__(/*! ./_Map.js */ \"./node_modules/lodash-es/_Map.js\"));\nvar _MapCache_js_1 = __importDefault(__webpack_require__(/*! ./_MapCache.js */ \"./node_modules/lodash-es/_MapCache.js\"));\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n    var data = this.__data__;\n    if (data instanceof _ListCache_js_1.default) {\n        var pairs = data.__data__;\n        if (!_Map_js_1.default || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n            pairs.push([key, value]);\n            this.size = ++data.size;\n            return this;\n        }\n        data = this.__data__ = new _MapCache_js_1.default(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n}\nexports.default = stackSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_stackSet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_stringToPath.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_stringToPath.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _memoizeCapped_js_1 = __importDefault(__webpack_require__(/*! ./_memoizeCapped.js */ \"./node_modules/lodash-es/_memoizeCapped.js\"));\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = (0, _memoizeCapped_js_1.default)(function (string) {\n    var result = [];\n    if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n    }\n    string.replace(rePropName, function (match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n    });\n    return result;\n});\nexports.default = stringToPath;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_stringToPath.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_toKey.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_toKey.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isSymbol_js_1 = __importDefault(__webpack_require__(/*! ./isSymbol.js */ \"./node_modules/lodash-es/isSymbol.js\"));\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n    if (typeof value == 'string' || (0, isSymbol_js_1.default)(value)) {\n        return value;\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\nexports.default = toKey;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_toKey.js?");

/***/ }),

/***/ "./node_modules/lodash-es/_toSource.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_toSource.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n    if (func != null) {\n        try {\n            return funcToString.call(func);\n        }\n        catch (e) { }\n        try {\n            return (func + '');\n        }\n        catch (e) { }\n    }\n    return '';\n}\nexports.default = toSource;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/_toSource.js?");

/***/ }),

/***/ "./node_modules/lodash-es/clone.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/clone.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseClone_js_1 = __importDefault(__webpack_require__(/*! ./_baseClone.js */ \"./node_modules/lodash-es/_baseClone.js\"));\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n    return (0, _baseClone_js_1.default)(value, CLONE_SYMBOLS_FLAG);\n}\nexports.default = clone;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/clone.js?");

/***/ }),

/***/ "./node_modules/lodash-es/cloneDeep.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/cloneDeep.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseClone_js_1 = __importDefault(__webpack_require__(/*! ./_baseClone.js */ \"./node_modules/lodash-es/_baseClone.js\"));\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n    return (0, _baseClone_js_1.default)(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\nexports.default = cloneDeep;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/cloneDeep.js?");

/***/ }),

/***/ "./node_modules/lodash-es/eq.js":
/*!**************************************!*\
  !*** ./node_modules/lodash-es/eq.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n    return value === other || (value !== value && other !== other);\n}\nexports.default = eq;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/eq.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isArguments.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArguments.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseIsArguments_js_1 = __importDefault(__webpack_require__(/*! ./_baseIsArguments.js */ \"./node_modules/lodash-es/_baseIsArguments.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = (0, _baseIsArguments_js_1.default)(function () { return arguments; }()) ? _baseIsArguments_js_1.default : function (value) {\n    return (0, isObjectLike_js_1.default)(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n};\nexports.default = isArguments;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isArguments.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\nexports.default = isArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isArrayLike.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArrayLike.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isFunction_js_1 = __importDefault(__webpack_require__(/*! ./isFunction.js */ \"./node_modules/lodash-es/isFunction.js\"));\nvar isLength_js_1 = __importDefault(__webpack_require__(/*! ./isLength.js */ \"./node_modules/lodash-es/isLength.js\"));\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n    return value != null && (0, isLength_js_1.default)(value.length) && !(0, isFunction_js_1.default)(value);\n}\nexports.default = isArrayLike;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isBuffer.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isBuffer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _root_js_1 = __importDefault(__webpack_require__(/*! ./_root.js */ \"./node_modules/lodash-es/_root.js\"));\nvar stubFalse_js_1 = __importDefault(__webpack_require__(/*! ./stubFalse.js */ \"./node_modules/lodash-es/stubFalse.js\"));\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n/** Built-in value references. */\nvar Buffer = moduleExports ? _root_js_1.default.Buffer : undefined;\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse_js_1.default;\nexports.default = isBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/isFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetTag_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetTag.js */ \"./node_modules/lodash-es/_baseGetTag.js\"));\nvar isObject_js_1 = __importDefault(__webpack_require__(/*! ./isObject.js */ \"./node_modules/lodash-es/isObject.js\"));\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n    if (!(0, isObject_js_1.default)(value)) {\n        return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = (0, _baseGetTag_js_1.default)(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nexports.default = isFunction;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isFunction.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isLength.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isLength.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n    return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\nexports.default = isLength;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isLength.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseIsMap_js_1 = __importDefault(__webpack_require__(/*! ./_baseIsMap.js */ \"./node_modules/lodash-es/_baseIsMap.js\"));\nvar _baseUnary_js_1 = __importDefault(__webpack_require__(/*! ./_baseUnary.js */ \"./node_modules/lodash-es/_baseUnary.js\"));\nvar _nodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./_nodeUtil.js */ \"./node_modules/lodash-es/_nodeUtil.js\"));\n/* Node.js helper references. */\nvar nodeIsMap = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isMap;\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? (0, _baseUnary_js_1.default)(nodeIsMap) : _baseIsMap_js_1.default;\nexports.default = isMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isMap.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n}\nexports.default = isObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isObject.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isObjectLike.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n    return value != null && typeof value == 'object';\n}\nexports.default = isObjectLike;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isObjectLike.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isPlainObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/isPlainObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetTag_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetTag.js */ \"./node_modules/lodash-es/_baseGetTag.js\"));\nvar _getPrototype_js_1 = __importDefault(__webpack_require__(/*! ./_getPrototype.js */ \"./node_modules/lodash-es/_getPrototype.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n/** Used for built-in method references. */\nvar funcProto = Function.prototype, objectProto = Object.prototype;\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n    if (!(0, isObjectLike_js_1.default)(value) || (0, _baseGetTag_js_1.default)(value) != objectTag) {\n        return false;\n    }\n    var proto = (0, _getPrototype_js_1.default)(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n    return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n}\nexports.default = isPlainObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isPlainObject.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseIsSet_js_1 = __importDefault(__webpack_require__(/*! ./_baseIsSet.js */ \"./node_modules/lodash-es/_baseIsSet.js\"));\nvar _baseUnary_js_1 = __importDefault(__webpack_require__(/*! ./_baseUnary.js */ \"./node_modules/lodash-es/_baseUnary.js\"));\nvar _nodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./_nodeUtil.js */ \"./node_modules/lodash-es/_nodeUtil.js\"));\n/* Node.js helper references. */\nvar nodeIsSet = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isSet;\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? (0, _baseUnary_js_1.default)(nodeIsSet) : _baseIsSet_js_1.default;\nexports.default = isSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isSet.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isSymbol.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isSymbol.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseGetTag_js_1 = __importDefault(__webpack_require__(/*! ./_baseGetTag.js */ \"./node_modules/lodash-es/_baseGetTag.js\"));\nvar isObjectLike_js_1 = __importDefault(__webpack_require__(/*! ./isObjectLike.js */ \"./node_modules/lodash-es/isObjectLike.js\"));\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n    return typeof value == 'symbol' ||\n        ((0, isObjectLike_js_1.default)(value) && (0, _baseGetTag_js_1.default)(value) == symbolTag);\n}\nexports.default = isSymbol;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isSymbol.js?");

/***/ }),

/***/ "./node_modules/lodash-es/isTypedArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isTypedArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseIsTypedArray_js_1 = __importDefault(__webpack_require__(/*! ./_baseIsTypedArray.js */ \"./node_modules/lodash-es/_baseIsTypedArray.js\"));\nvar _baseUnary_js_1 = __importDefault(__webpack_require__(/*! ./_baseUnary.js */ \"./node_modules/lodash-es/_baseUnary.js\"));\nvar _nodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./_nodeUtil.js */ \"./node_modules/lodash-es/_nodeUtil.js\"));\n/* Node.js helper references. */\nvar nodeIsTypedArray = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isTypedArray;\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? (0, _baseUnary_js_1.default)(nodeIsTypedArray) : _baseIsTypedArray_js_1.default;\nexports.default = isTypedArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/isTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/keys.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/keys.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _arrayLikeKeys_js_1 = __importDefault(__webpack_require__(/*! ./_arrayLikeKeys.js */ \"./node_modules/lodash-es/_arrayLikeKeys.js\"));\nvar _baseKeys_js_1 = __importDefault(__webpack_require__(/*! ./_baseKeys.js */ \"./node_modules/lodash-es/_baseKeys.js\"));\nvar isArrayLike_js_1 = __importDefault(__webpack_require__(/*! ./isArrayLike.js */ \"./node_modules/lodash-es/isArrayLike.js\"));\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n    return (0, isArrayLike_js_1.default)(object) ? (0, _arrayLikeKeys_js_1.default)(object) : (0, _baseKeys_js_1.default)(object);\n}\nexports.default = keys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/keys.js?");

/***/ }),

/***/ "./node_modules/lodash-es/keysIn.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/keysIn.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _arrayLikeKeys_js_1 = __importDefault(__webpack_require__(/*! ./_arrayLikeKeys.js */ \"./node_modules/lodash-es/_arrayLikeKeys.js\"));\nvar _baseKeysIn_js_1 = __importDefault(__webpack_require__(/*! ./_baseKeysIn.js */ \"./node_modules/lodash-es/_baseKeysIn.js\"));\nvar isArrayLike_js_1 = __importDefault(__webpack_require__(/*! ./isArrayLike.js */ \"./node_modules/lodash-es/isArrayLike.js\"));\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n    return (0, isArrayLike_js_1.default)(object) ? (0, _arrayLikeKeys_js_1.default)(object, true) : (0, _baseKeysIn_js_1.default)(object);\n}\nexports.default = keysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/keysIn.js?");

/***/ }),

/***/ "./node_modules/lodash-es/memoize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/memoize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _MapCache_js_1 = __importDefault(__webpack_require__(/*! ./_MapCache.js */ \"./node_modules/lodash-es/_MapCache.js\"));\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function () {\n        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize.Cache || _MapCache_js_1.default);\n    return memoized;\n}\n// Expose `MapCache`.\nmemoize.Cache = _MapCache_js_1.default;\nexports.default = memoize;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/memoize.js?");

/***/ }),

/***/ "./node_modules/lodash-es/stubArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n    return [];\n}\nexports.default = stubArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/stubArray.js?");

/***/ }),

/***/ "./node_modules/lodash-es/stubFalse.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubFalse.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n    return false;\n}\nexports.default = stubFalse;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/stubFalse.js?");

/***/ }),

/***/ "./node_modules/lodash-es/toPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/toPath.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _arrayMap_js_1 = __importDefault(__webpack_require__(/*! ./_arrayMap.js */ \"./node_modules/lodash-es/_arrayMap.js\"));\nvar _copyArray_js_1 = __importDefault(__webpack_require__(/*! ./_copyArray.js */ \"./node_modules/lodash-es/_copyArray.js\"));\nvar isArray_js_1 = __importDefault(__webpack_require__(/*! ./isArray.js */ \"./node_modules/lodash-es/isArray.js\"));\nvar isSymbol_js_1 = __importDefault(__webpack_require__(/*! ./isSymbol.js */ \"./node_modules/lodash-es/isSymbol.js\"));\nvar _stringToPath_js_1 = __importDefault(__webpack_require__(/*! ./_stringToPath.js */ \"./node_modules/lodash-es/_stringToPath.js\"));\nvar _toKey_js_1 = __importDefault(__webpack_require__(/*! ./_toKey.js */ \"./node_modules/lodash-es/_toKey.js\"));\nvar toString_js_1 = __importDefault(__webpack_require__(/*! ./toString.js */ \"./node_modules/lodash-es/toString.js\"));\n/**\n * Converts `value` to a property path array.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Util\n * @param {*} value The value to convert.\n * @returns {Array} Returns the new property path array.\n * @example\n *\n * _.toPath('a.b.c');\n * // => ['a', 'b', 'c']\n *\n * _.toPath('a[0].b.c');\n * // => ['a', '0', 'b', 'c']\n */\nfunction toPath(value) {\n    if ((0, isArray_js_1.default)(value)) {\n        return (0, _arrayMap_js_1.default)(value, _toKey_js_1.default);\n    }\n    return (0, isSymbol_js_1.default)(value) ? [value] : (0, _copyArray_js_1.default)((0, _stringToPath_js_1.default)((0, toString_js_1.default)(value)));\n}\nexports.default = toPath;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/toPath.js?");

/***/ }),

/***/ "./node_modules/lodash-es/toString.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toString.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _baseToString_js_1 = __importDefault(__webpack_require__(/*! ./_baseToString.js */ \"./node_modules/lodash-es/_baseToString.js\"));\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n    return value == null ? '' : (0, _baseToString_js_1.default)(value);\n}\nexports.default = toString;\n\n\n//# sourceURL=webpack:///./node_modules/lodash-es/toString.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/ObserverComponent.js":
/*!**************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/ObserverComponent.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Observer = void 0;\nvar useObserver_1 = __webpack_require__(/*! ./useObserver */ \"./node_modules/mobx-react-lite/es/useObserver.js\");\nfunction ObserverComponent(_a) {\n    var children = _a.children, render = _a.render;\n    var component = children || render;\n    if (typeof component !== \"function\") {\n        return null;\n    }\n    return (0, useObserver_1.useObserver)(component);\n}\nexports.Observer = ObserverComponent;\nif (true) {\n    ObserverComponent.propTypes = {\n        children: ObserverPropsCheck,\n        render: ObserverPropsCheck\n    };\n}\nObserverComponent.displayName = \"Observer\";\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\n    var hasProp = typeof props[key] === \"function\";\n    var hasExtraProp = typeof props[extraKey] === \"function\";\n    if (hasProp && hasExtraProp) {\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n    }\n    if (hasProp || hasExtraProp) {\n        return null;\n    }\n    return new Error(\"Invalid prop `\" +\n        propFullName +\n        \"` of type `\" +\n        typeof props[key] +\n        \"` supplied to\" +\n        \" `\" +\n        componentName +\n        \"`, expected `function`.\");\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/ObserverComponent.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useStaticRendering = exports.observerBatching = exports.isObserverBatched = exports.useObserver = exports.clearTimers = exports._observerFinalizationRegistry = exports.useAsObservableSource = exports.useLocalStore = exports.useLocalObservable = exports.Observer = exports.observer = exports.enableStaticRendering = exports.isUsingStaticRendering = void 0;\nvar _a;\n__webpack_require__(/*! ./utils/assertEnvironment */ \"./node_modules/mobx-react-lite/es/utils/assertEnvironment.js\");\nvar reactBatchedUpdates_1 = __webpack_require__(/*! ./utils/reactBatchedUpdates */ \"./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js\");\nvar observerBatching_1 = __webpack_require__(/*! ./utils/observerBatching */ \"./node_modules/mobx-react-lite/es/utils/observerBatching.js\");\nvar utils_1 = __webpack_require__(/*! ./utils/utils */ \"./node_modules/mobx-react-lite/es/utils/utils.js\");\nvar useObserver_1 = __webpack_require__(/*! ./useObserver */ \"./node_modules/mobx-react-lite/es/useObserver.js\");\nvar staticRendering_1 = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\nvar observerFinalizationRegistry_1 = __webpack_require__(/*! ./utils/observerFinalizationRegistry */ \"./node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js\");\nObject.defineProperty(exports, \"_observerFinalizationRegistry\", { enumerable: true, get: function () { return observerFinalizationRegistry_1.observerFinalizationRegistry; } });\n(0, observerBatching_1.observerBatching)(reactBatchedUpdates_1.unstable_batchedUpdates);\nvar staticRendering_2 = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\nObject.defineProperty(exports, \"isUsingStaticRendering\", { enumerable: true, get: function () { return staticRendering_2.isUsingStaticRendering; } });\nObject.defineProperty(exports, \"enableStaticRendering\", { enumerable: true, get: function () { return staticRendering_2.enableStaticRendering; } });\nvar observer_1 = __webpack_require__(/*! ./observer */ \"./node_modules/mobx-react-lite/es/observer.js\");\nObject.defineProperty(exports, \"observer\", { enumerable: true, get: function () { return observer_1.observer; } });\nvar ObserverComponent_1 = __webpack_require__(/*! ./ObserverComponent */ \"./node_modules/mobx-react-lite/es/ObserverComponent.js\");\nObject.defineProperty(exports, \"Observer\", { enumerable: true, get: function () { return ObserverComponent_1.Observer; } });\nvar useLocalObservable_1 = __webpack_require__(/*! ./useLocalObservable */ \"./node_modules/mobx-react-lite/es/useLocalObservable.js\");\nObject.defineProperty(exports, \"useLocalObservable\", { enumerable: true, get: function () { return useLocalObservable_1.useLocalObservable; } });\nvar useLocalStore_1 = __webpack_require__(/*! ./useLocalStore */ \"./node_modules/mobx-react-lite/es/useLocalStore.js\");\nObject.defineProperty(exports, \"useLocalStore\", { enumerable: true, get: function () { return useLocalStore_1.useLocalStore; } });\nvar useAsObservableSource_1 = __webpack_require__(/*! ./useAsObservableSource */ \"./node_modules/mobx-react-lite/es/useAsObservableSource.js\");\nObject.defineProperty(exports, \"useAsObservableSource\", { enumerable: true, get: function () { return useAsObservableSource_1.useAsObservableSource; } });\nexports.clearTimers = (_a = observerFinalizationRegistry_1.observerFinalizationRegistry[\"finalizeAllImmediately\"]) !== null && _a !== void 0 ? _a : (function () { });\nfunction useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) {\n        baseComponentName = \"observed\";\n    }\n    if (true) {\n        (0, utils_1.useDeprecated)(\"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\");\n    }\n    return (0, useObserver_1.useObserver)(fn, baseComponentName);\n}\nexports.useObserver = useObserver;\nvar observerBatching_2 = __webpack_require__(/*! ./utils/observerBatching */ \"./node_modules/mobx-react-lite/es/utils/observerBatching.js\");\nObject.defineProperty(exports, \"isObserverBatched\", { enumerable: true, get: function () { return observerBatching_2.isObserverBatched; } });\nObject.defineProperty(exports, \"observerBatching\", { enumerable: true, get: function () { return observerBatching_2.observerBatching; } });\nfunction useStaticRendering(enable) {\n    if (true) {\n        console.warn(\"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\");\n    }\n    (0, staticRendering_1.enableStaticRendering)(enable);\n}\nexports.useStaticRendering = useStaticRendering;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/index.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/observer.js":
/*!*****************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/observer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.observer = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar staticRendering_1 = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\nvar useObserver_1 = __webpack_require__(/*! ./useObserver */ \"./node_modules/mobx-react-lite/es/useObserver.js\");\nvar warnObserverOptionsDeprecated = true;\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nvar ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof react_1.forwardRef === \"function\" && (0, react_1.forwardRef)(function (props) { return null; })[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof react_1.memo === \"function\" && (0, react_1.memo)(function (props) { return null; })[\"$$typeof\"];\n// n.b. base case is not used for actual typings or exported in the typing files\nfunction observer(baseComponent, \n// TODO remove in next major\noptions) {\n    var _a;\n    if ( true && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false;\n        console.warn(\"[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`\");\n    }\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\"[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.\");\n    }\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if ((0, staticRendering_1.isUsingStaticRendering)()) {\n        return baseComponent;\n    }\n    var useForwardRef = (_a = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a !== void 0 ? _a : false;\n    var render = baseComponent;\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true;\n        render = baseComponent[\"render\"];\n        if (typeof render !== \"function\") {\n            throw new Error(\"[mobx-react-lite] `render` property of ForwardRef was not a function\");\n        }\n    }\n    var observerComponent = function (props, ref) {\n        return (0, useObserver_1.useObserver)(function () { return render(props, ref); }, baseComponentName);\n    };\n    observerComponent.displayName = baseComponent.displayName;\n    Object.defineProperty(observerComponent, \"name\", {\n        value: baseComponent.name,\n        writable: true,\n        configurable: true\n    });\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if (baseComponent.contextTypes) {\n        ;\n        observerComponent.contextTypes = baseComponent.contextTypes;\n    }\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = (0, react_1.forwardRef)(observerComponent);\n    }\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = (0, react_1.memo)(observerComponent);\n    copyStaticProperties(baseComponent, observerComponent);\n    if (true) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set: function () {\n                var _a, _b;\n                throw new Error(\"[mobx-react-lite] `\".concat(this.displayName || ((_a = this.type) === null || _a === void 0 ? void 0 : _a.displayName) || ((_b = this.type) === null || _b === void 0 ? void 0 : _b.name) || \"Component\", \".contextTypes` must be set before applying `observer`.\"));\n            }\n        });\n    }\n    return observerComponent;\n}\nexports.observer = observer;\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/observer.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/staticRendering.js":
/*!************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/staticRendering.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isUsingStaticRendering = exports.enableStaticRendering = void 0;\nvar globalIsUsingStaticRendering = false;\nfunction enableStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nexports.enableStaticRendering = enableStaticRendering;\nfunction isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\nexports.isUsingStaticRendering = isUsingStaticRendering;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/staticRendering.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useAsObservableSource.js":
/*!******************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useAsObservableSource.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useAsObservableSource = void 0;\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m)\n        return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n            ar.push(r.value);\n    }\n    catch (error) {\n        e = { error: error };\n    }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"]))\n                m.call(i);\n        }\n        finally {\n            if (e)\n                throw e.error;\n        }\n    }\n    return ar;\n};\nvar utils_1 = __webpack_require__(/*! ./utils/utils */ \"./node_modules/mobx-react-lite/es/utils/utils.js\");\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nfunction useAsObservableSource(current) {\n    if (true)\n        (0, utils_1.useDeprecated)(\"[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.\");\n    var _a = __read((0, react_1.useState)(function () { return (0, mobx_1.observable)(current, {}, { deep: false }); }), 1), res = _a[0];\n    (0, mobx_1.runInAction)(function () {\n        Object.assign(res, current);\n    });\n    return res;\n}\nexports.useAsObservableSource = useAsObservableSource;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/useAsObservableSource.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useLocalObservable.js":
/*!***************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useLocalObservable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useLocalObservable = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nfunction useLocalObservable(initializer, annotations) {\n    return (0, react_1.useState)(function () { return (0, mobx_1.observable)(initializer(), annotations, { autoBind: true }); })[0];\n}\nexports.useLocalObservable = useLocalObservable;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/useLocalObservable.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useLocalStore.js":
/*!**********************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useLocalStore.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useLocalStore = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar utils_1 = __webpack_require__(/*! ./utils/utils */ \"./node_modules/mobx-react-lite/es/utils/utils.js\");\nvar useAsObservableSource_1 = __webpack_require__(/*! ./useAsObservableSource */ \"./node_modules/mobx-react-lite/es/useAsObservableSource.js\");\nfunction useLocalStore(initializer, current) {\n    if (true) {\n        (0, utils_1.useDeprecated)(\"[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.\");\n    }\n    var source = current && (0, useAsObservableSource_1.useAsObservableSource)(current);\n    return (0, react_1.useState)(function () { return (0, mobx_1.observable)(initializer(source), undefined, { autoBind: true }); })[0];\n}\nexports.useLocalStore = useLocalStore;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/useLocalStore.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useObserver.js":
/*!********************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useObserver.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useObserver = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar printDebugValue_1 = __webpack_require__(/*! ./utils/printDebugValue */ \"./node_modules/mobx-react-lite/es/utils/printDebugValue.js\");\nvar staticRendering_1 = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\nvar observerFinalizationRegistry_1 = __webpack_require__(/*! ./utils/observerFinalizationRegistry */ \"./node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js\");\nvar shim_1 = __webpack_require__(/*! use-sync-external-store/shim */ \"./node_modules/use-sync-external-store/shim/index.js\");\n// Required by SSR when hydrating #3669\nvar getServerSnapshot = function () { };\nfunction createReaction(adm) {\n    adm.reaction = new mobx_1.Reaction(\"observer\".concat(adm.name), function () {\n        var _a;\n        adm.stateVersion = Symbol();\n        // onStoreChange won't be available until the component \"mounts\".\n        // If state changes in between initial render and mount,\n        // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n        (_a = adm.onStoreChange) === null || _a === void 0 ? void 0 : _a.call(adm);\n    });\n}\nfunction useObserver(render, baseComponentName) {\n    if (baseComponentName === void 0) {\n        baseComponentName = \"observed\";\n    }\n    if ((0, staticRendering_1.isUsingStaticRendering)()) {\n        return render();\n    }\n    var admRef = react_1.default.useRef(null);\n    if (!admRef.current) {\n        // First render\n        var adm_1 = {\n            reaction: null,\n            onStoreChange: null,\n            stateVersion: Symbol(),\n            name: baseComponentName,\n            subscribe: function (onStoreChange) {\n                // Do NOT access admRef here!\n                observerFinalizationRegistry_1.observerFinalizationRegistry.unregister(adm_1);\n                adm_1.onStoreChange = onStoreChange;\n                if (!adm_1.reaction) {\n                    // We've lost our reaction and therefore all subscriptions, occurs when:\n                    // 1. Timer based finalization registry disposed reaction before component mounted.\n                    // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n                    // We have to recreate reaction and schedule re-render to recreate subscriptions,\n                    // even if state did not change.\n                    createReaction(adm_1);\n                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n                    // So we make sure that is not the case\n                    adm_1.stateVersion = Symbol();\n                }\n                return function () {\n                    var _a;\n                    // Do NOT access admRef here!\n                    adm_1.onStoreChange = null;\n                    (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n                    adm_1.reaction = null;\n                };\n            },\n            getSnapshot: function () {\n                // Do NOT access admRef here!\n                return adm_1.stateVersion;\n            }\n        };\n        admRef.current = adm_1;\n    }\n    var adm = admRef.current;\n    if (!adm.reaction) {\n        // First render or reaction was disposed by registry before subscribe\n        createReaction(adm);\n        // StrictMode/ConcurrentMode/Suspense may mean that our component is\n        // rendered and abandoned multiple times, so we need to track leaked\n        // Reactions.\n        observerFinalizationRegistry_1.observerFinalizationRegistry.register(admRef, adm, adm);\n    }\n    react_1.default.useDebugValue(adm.reaction, printDebugValue_1.printDebugValue);\n    (0, shim_1.useSyncExternalStore)(\n    // Both of these must be stable, otherwise it would keep resubscribing every render.\n    adm.subscribe, adm.getSnapshot, getServerSnapshot);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var renderResult;\n    var exception;\n    adm.reaction.track(function () {\n        try {\n            renderResult = render();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return renderResult;\n}\nexports.useObserver = useObserver;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/useObserver.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniversalFinalizationRegistry = exports.TimerBasedFinalizationRegistry = exports.REGISTRY_SWEEP_INTERVAL = exports.REGISTRY_FINALIZE_AFTER = void 0;\nexports.REGISTRY_FINALIZE_AFTER = 10000;\nexports.REGISTRY_SWEEP_INTERVAL = 10000;\nvar TimerBasedFinalizationRegistry = /** @class */ (function () {\n    function TimerBasedFinalizationRegistry(finalize) {\n        var _this = this;\n        Object.defineProperty(this, \"finalize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: finalize\n        });\n        Object.defineProperty(this, \"registrations\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"sweepTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Bound so it can be used directly as setTimeout callback.\n        Object.defineProperty(this, \"sweep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (maxAge) {\n                if (maxAge === void 0) {\n                    maxAge = exports.REGISTRY_FINALIZE_AFTER;\n                }\n                // cancel timeout so we can force sweep anytime\n                clearTimeout(_this.sweepTimeout);\n                _this.sweepTimeout = undefined;\n                var now = Date.now();\n                _this.registrations.forEach(function (registration, token) {\n                    if (now - registration.registeredAt >= maxAge) {\n                        _this.finalize(registration.value);\n                        _this.registrations.delete(token);\n                    }\n                });\n                if (_this.registrations.size > 0) {\n                    _this.scheduleSweep();\n                }\n            }\n        });\n        // Bound so it can be exported directly as clearTimers test utility.\n        Object.defineProperty(this, \"finalizeAllImmediately\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function () {\n                _this.sweep(0);\n            }\n        });\n    }\n    // Token is actually required with this impl\n    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, \"register\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (target, value, token) {\n            this.registrations.set(token, {\n                value: value,\n                registeredAt: Date.now()\n            });\n            this.scheduleSweep();\n        }\n    });\n    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, \"unregister\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (token) {\n            this.registrations.delete(token);\n        }\n    });\n    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, \"scheduleSweep\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this.sweepTimeout === undefined) {\n                this.sweepTimeout = setTimeout(this.sweep, exports.REGISTRY_SWEEP_INTERVAL);\n            }\n        }\n    });\n    return TimerBasedFinalizationRegistry;\n}());\nexports.TimerBasedFinalizationRegistry = TimerBasedFinalizationRegistry;\nexports.UniversalFinalizationRegistry = typeof FinalizationRegistry !== \"undefined\"\n    ? FinalizationRegistry\n    : TimerBasedFinalizationRegistry;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/assertEnvironment.js":
/*!********************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/assertEnvironment.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nif (!react_1.useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!mobx_1.makeObservable) {\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/assertEnvironment.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/observerBatching.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/observerBatching.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isObserverBatched = exports.observerBatching = exports.defaultNoopBatch = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nfunction defaultNoopBatch(callback) {\n    callback();\n}\nexports.defaultNoopBatch = defaultNoopBatch;\nfunction observerBatching(reactionScheduler) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch;\n        if (true) {\n            console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n        }\n    }\n    (0, mobx_1.configure)({ reactionScheduler: reactionScheduler });\n}\nexports.observerBatching = observerBatching;\nvar isObserverBatched = function () {\n    if (true) {\n        console.warn(\"[MobX] Deprecated\");\n    }\n    return true;\n};\nexports.isObserverBatched = isObserverBatched;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/observerBatching.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.observerFinalizationRegistry = void 0;\nvar UniversalFinalizationRegistry_1 = __webpack_require__(/*! ./UniversalFinalizationRegistry */ \"./node_modules/mobx-react-lite/es/utils/UniversalFinalizationRegistry.js\");\nexports.observerFinalizationRegistry = new UniversalFinalizationRegistry_1.UniversalFinalizationRegistry(function (adm) {\n    var _a;\n    (_a = adm.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n    adm.reaction = null;\n});\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/observerFinalizationRegistry.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/printDebugValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/printDebugValue.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.printDebugValue = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nfunction printDebugValue(v) {\n    return (0, mobx_1.getDependencyTree)(v);\n}\nexports.printDebugValue = printDebugValue;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/printDebugValue.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unstable_batchedUpdates = void 0;\nvar react_dom_1 = __webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\");\nObject.defineProperty(exports, \"unstable_batchedUpdates\", { enumerable: true, get: function () { return react_dom_1.unstable_batchedUpdates; } });\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js?");

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useDeprecated = void 0;\nvar deprecatedMessages = [];\nfunction useDeprecated(msg) {\n    if (!deprecatedMessages.includes(msg)) {\n        deprecatedMessages.push(msg);\n        console.warn(msg);\n    }\n}\nexports.useDeprecated = useDeprecated;\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react-lite/es/utils/utils.js?");

/***/ }),

/***/ "./node_modules/mobx-react/dist/mobxreact.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/mobx-react/dist/mobxreact.esm.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.observer = exports.inject = exports.disposeOnUnmount = exports.Provider = exports.PropTypes = exports.MobXProviderContext = exports.useStaticRendering = exports.useObserver = exports.useLocalStore = exports.useLocalObservable = exports.useAsObservableSource = exports.observerBatching = exports.isUsingStaticRendering = exports.enableStaticRendering = exports.Observer = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar mobx_react_lite_1 = __webpack_require__(/*! mobx-react-lite */ \"./node_modules/mobx-react-lite/es/index.js\");\nvar mobx_react_lite_2 = __webpack_require__(/*! mobx-react-lite */ \"./node_modules/mobx-react-lite/es/index.js\");\nObject.defineProperty(exports, \"Observer\", { enumerable: true, get: function () { return mobx_react_lite_2.Observer; } });\nObject.defineProperty(exports, \"enableStaticRendering\", { enumerable: true, get: function () { return mobx_react_lite_2.enableStaticRendering; } });\nObject.defineProperty(exports, \"isUsingStaticRendering\", { enumerable: true, get: function () { return mobx_react_lite_2.isUsingStaticRendering; } });\nObject.defineProperty(exports, \"observerBatching\", { enumerable: true, get: function () { return mobx_react_lite_2.observerBatching; } });\nObject.defineProperty(exports, \"useAsObservableSource\", { enumerable: true, get: function () { return mobx_react_lite_2.useAsObservableSource; } });\nObject.defineProperty(exports, \"useLocalObservable\", { enumerable: true, get: function () { return mobx_react_lite_2.useLocalObservable; } });\nObject.defineProperty(exports, \"useLocalStore\", { enumerable: true, get: function () { return mobx_react_lite_2.useLocalStore; } });\nObject.defineProperty(exports, \"useObserver\", { enumerable: true, get: function () { return mobx_react_lite_2.useObserver; } });\nObject.defineProperty(exports, \"useStaticRendering\", { enumerable: true, get: function () { return mobx_react_lite_2.useStaticRendering; } });\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for (var i = 0; i < keysA.length; i++) {\n        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    displayName: 1,\n    propTypes: 1\n};\nfunction copyStaticProperties(base, target) {\n    var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));\n    Object.getOwnPropertyNames(base).forEach(function (key) {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nvar mobxMixins = /*#__PURE__*/ Symbol(\"patchMixins\");\nvar mobxPatchedDefinition = /*#__PURE__*/ Symbol(\"patchedDefinition\");\nfunction getMixins(target, methodName) {\n    var mixins = target[mobxMixins] = target[mobxMixins] || {};\n    var methodMixins = mixins[methodName] = mixins[methodName] || {};\n    methodMixins.locks = methodMixins.locks || 0;\n    methodMixins.methods = methodMixins.methods || [];\n    return methodMixins;\n}\nfunction wrapper(realMethod, mixins) {\n    var _this = this;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n    }\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++;\n    try {\n        var retVal;\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args);\n        }\n        return retVal;\n    }\n    finally {\n        mixins.locks--;\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(function (mx) {\n                mx.apply(_this, args);\n            });\n        }\n    }\n}\nfunction wrapFunction(realMethod, mixins) {\n    var fn = function fn() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n        wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));\n    };\n    return fn;\n}\nfunction patch(target, methodName, mixinMethod) {\n    var mixins = getMixins(target, methodName);\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod);\n    }\n    var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return;\n    }\n    var originalMethod = target[methodName];\n    var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);\n    Object.defineProperty(target, methodName, newDefinition);\n}\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n    var _ref;\n    var wrappedFunc = wrapFunction(originalMethod, mixins);\n    return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get() {\n        return wrappedFunc;\n    }, _ref.set = function set(value) {\n        if (this === target) {\n            wrappedFunc = wrapFunction(value, mixins);\n        }\n        else {\n            // when it is an instance of the prototype/a child prototype patch that particular case again separately\n            // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n            // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n            // as the method for the instance\n            var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);\n            Object.defineProperty(this, methodName, newDefinition);\n        }\n    }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;\n}\nvar administrationSymbol = /*#__PURE__*/ Symbol(\"ObserverAdministration\");\nvar isMobXReactObserverSymbol = /*#__PURE__*/ Symbol(\"isMobXReactObserver\");\nvar observablePropDescriptors;\nif (true) {\n    observablePropDescriptors = {\n        props: /*#__PURE__*/ createObservablePropDescriptor(\"props\"),\n        state: /*#__PURE__*/ createObservablePropDescriptor(\"state\"),\n        context: /*#__PURE__*/ createObservablePropDescriptor(\"context\")\n    };\n}\nfunction getAdministration(component) {\n    var _component$administra;\n    // We create administration lazily, because we can't patch constructor\n    // and the exact moment of initialization partially depends on React internals.\n    // At the time of writing this, the first thing invoked is one of the observable getter/setter (state/props/context).\n    return (_component$administra = component[administrationSymbol]) != null ? _component$administra : component[administrationSymbol] = {\n        reaction: null,\n        mounted: false,\n        reactionInvalidatedBeforeMount: false,\n        forceUpdate: null,\n        name: getDisplayName(component.constructor),\n        state: undefined,\n        props: undefined,\n        context: undefined\n    };\n}\nfunction makeClassComponentObserver(componentClass) {\n    var prototype = componentClass.prototype;\n    if (componentClass[isMobXReactObserverSymbol]) {\n        var displayName = getDisplayName(componentClass);\n        throw new Error(\"The provided component class (\" + displayName + \") has already been declared as an observer component.\");\n    }\n    else {\n        componentClass[isMobXReactObserverSymbol] = true;\n    }\n    if (prototype.componentWillReact) {\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n    }\n    if (componentClass[\"__proto__\"] !== react_1.PureComponent) {\n        if (!prototype.shouldComponentUpdate) {\n            prototype.shouldComponentUpdate = observerSCU;\n        }\n        else if (prototype.shouldComponentUpdate !== observerSCU) {\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n        }\n    }\n    if (true) {\n        Object.defineProperties(prototype, observablePropDescriptors);\n    }\n    var originalRender = prototype.render;\n    if (typeof originalRender !== \"function\") {\n        var _displayName = getDisplayName(componentClass);\n        throw new Error(\"[mobx-react] class component (\" + _displayName + \") is missing `render` method.\" + \"\\n`observer` requires `render` being a function defined on prototype.\" + \"\\n`render = () => {}` or `render = function() {}` is not supported.\");\n    }\n    prototype.render = function () {\n        Object.defineProperty(this, \"render\", {\n            // There is no safe way to replace render, therefore it's forbidden.\n            configurable: false,\n            writable: false,\n            value: (0, mobx_react_lite_1.isUsingStaticRendering)() ? originalRender : createReactiveRender.call(this, originalRender)\n        });\n        return this.render();\n    };\n    var originalComponentDidMount = prototype.componentDidMount;\n    prototype.componentDidMount = function () {\n        var _this = this;\n        if ( true && this.componentDidMount !== Object.getPrototypeOf(this).componentDidMount) {\n            var _displayName2 = getDisplayName(componentClass);\n            throw new Error(\"[mobx-react] `observer(\" + _displayName2 + \").componentDidMount` must be defined on prototype.\" + \"\\n`componentDidMount = () => {}` or `componentDidMount = function() {}` is not supported.\");\n        }\n        // `componentDidMount` may not be called at all. React can abandon the instance after `render`.\n        // That's why we use finalization registry to dispose reaction created during render.\n        // Happens with `<Suspend>` see #3492\n        //\n        // `componentDidMount` can be called immediately after `componentWillUnmount` without calling `render` in between.\n        // Happens with `<StrictMode>`see #3395.\n        //\n        // If `componentDidMount` is called, it's guaranteed to run synchronously with render (similary to `useLayoutEffect`).\n        // Therefore we don't have to worry about external (observable) state being updated before mount (no state version checking).\n        //\n        // Things may change: \"In the future, React will provide a feature that lets components preserve state between unmounts\"\n        var admin = getAdministration(this);\n        admin.mounted = true;\n        // Component instance committed, prevent reaction disposal.\n        mobx_react_lite_1._observerFinalizationRegistry.unregister(this);\n        // We don't set forceUpdate before mount because it requires a reference to `this`,\n        // therefore `this` could NOT be garbage collected before mount,\n        // preventing reaction disposal by FinalizationRegistry and leading to memory leak.\n        // As an alternative we could have `admin.instanceRef = new WeakRef(this)`, but lets avoid it if possible.\n        admin.forceUpdate = function () {\n            return _this.forceUpdate();\n        };\n        if (!admin.reaction || admin.reactionInvalidatedBeforeMount) {\n            // Missing reaction:\n            // 1. Instance was unmounted (reaction disposed) and immediately remounted without running render #3395.\n            // 2. Reaction was disposed by finalization registry before mount. Shouldn't ever happen for class components:\n            // `componentDidMount` runs synchronously after render, but our registry are deferred (can't run in between).\n            // In any case we lost subscriptions to observables, so we have to create new reaction and re-render to resubscribe.\n            // The reaction will be created lazily by following render.\n            // Reaction invalidated before mount:\n            // 1. A descendant's `componenDidMount` invalidated it's parent #3730\n            admin.forceUpdate();\n        }\n        return originalComponentDidMount == null ? void 0 : originalComponentDidMount.apply(this, arguments);\n    };\n    // TODO@major Overly complicated \"patch\" is only needed to support the deprecated @disposeOnUnmount\n    patch(prototype, \"componentWillUnmount\", function () {\n        var _admin$reaction;\n        if ((0, mobx_react_lite_1.isUsingStaticRendering)()) {\n            return;\n        }\n        var admin = getAdministration(this);\n        (_admin$reaction = admin.reaction) == null ? void 0 : _admin$reaction.dispose();\n        admin.reaction = null;\n        admin.forceUpdate = null;\n        admin.mounted = false;\n        admin.reactionInvalidatedBeforeMount = false;\n    });\n    return componentClass;\n}\n// Generates a friendly name for debugging\nfunction getDisplayName(componentClass) {\n    return componentClass.displayName || componentClass.name || \"<component>\";\n}\nfunction createReactiveRender(originalRender) {\n    var boundOriginalRender = originalRender.bind(this);\n    var admin = getAdministration(this);\n    function reactiveRender() {\n        if (!admin.reaction) {\n            // Create reaction lazily to support re-mounting #3395\n            admin.reaction = createReaction(admin);\n            if (!admin.mounted) {\n                // React can abandon this instance and never call `componentDidMount`/`componentWillUnmount`,\n                // we have to make sure reaction will be disposed.\n                mobx_react_lite_1._observerFinalizationRegistry.register(this, admin, this);\n            }\n        }\n        var error = undefined;\n        var renderResult = undefined;\n        admin.reaction.track(function () {\n            try {\n                // TODO@major\n                // Optimization: replace with _allowStateChangesStart/End (not available in mobx@6.0.0)\n                renderResult = (0, mobx_1._allowStateChanges)(false, boundOriginalRender);\n            }\n            catch (e) {\n                error = e;\n            }\n        });\n        if (error) {\n            throw error;\n        }\n        return renderResult;\n    }\n    return reactiveRender;\n}\nfunction createReaction(admin) {\n    return new mobx_1.Reaction(admin.name + \".render()\", function () {\n        if (!admin.mounted) {\n            // This is neccessary to avoid react warning about calling forceUpdate on component that isn't mounted yet.\n            // This happens when component is abandoned after render - our reaction is already created and reacts to changes.\n            // `componenDidMount` runs synchronously after `render`, so unlike functional component, there is no delay during which the reaction could be invalidated.\n            // However `componentDidMount` runs AFTER it's descendants' `componentDidMount`, which CAN invalidate the reaction, see #3730. Therefore remember and forceUpdate on mount.\n            admin.reactionInvalidatedBeforeMount = true;\n            return;\n        }\n        try {\n            admin.forceUpdate == null ? void 0 : admin.forceUpdate();\n        }\n        catch (error) {\n            var _admin$reaction2;\n            (_admin$reaction2 = admin.reaction) == null ? void 0 : _admin$reaction2.dispose();\n            admin.reaction = null;\n        }\n    });\n}\nfunction observerSCU(nextProps, nextState) {\n    if ((0, mobx_react_lite_1.isUsingStaticRendering)()) {\n        console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true;\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps);\n}\nfunction createObservablePropDescriptor(key) {\n    return {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            var admin = getAdministration(this);\n            var derivation = (0, mobx_1._getGlobalState)().trackingDerivation;\n            if (derivation && derivation !== admin.reaction) {\n                throw new Error(\"[mobx-react] Cannot read \\\"\" + admin.name + \".\" + key + \"\\\" in a reactive context, as it isn't observable.\\n                    Please use component lifecycle method to copy the value into a local observable first.\\n                    See https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations\");\n            }\n            return admin[key];\n        },\n        set: function set(value) {\n            getAdministration(this)[key] = value;\n        }\n    };\n}\nfunction observer(component, context) {\n    if (context && context.kind !== \"class\") {\n        throw new Error(\"The @observer decorator can be used on classes only\");\n    }\n    if (component[\"isMobxInjector\"] === true) {\n        console.warn(\"Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`\");\n    }\n    if (Object.prototype.isPrototypeOf.call(react_1.Component, component) || Object.prototype.isPrototypeOf.call(react_1.PureComponent, component)) {\n        // Class component\n        return makeClassComponentObserver(component);\n    }\n    else {\n        // Function component\n        return (0, mobx_react_lite_1.observer)(component);\n    }\n}\nexports.observer = observer;\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null)\n        return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n            continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar _excluded = [\"children\"];\nvar MobXProviderContext = /*#__PURE__*/ react_1.default.createContext({});\nexports.MobXProviderContext = MobXProviderContext;\nfunction Provider(props) {\n    var children = props.children, stores = _objectWithoutPropertiesLoose(props, _excluded);\n    var parentValue = react_1.default.useContext(MobXProviderContext);\n    var mutableProviderRef = react_1.default.useRef(_extends({}, parentValue, stores));\n    var value = mutableProviderRef.current;\n    if (true) {\n        var newValue = _extends({}, value, stores); // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) {\n            throw new Error(\"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\");\n        }\n    }\n    return react_1.default.createElement(MobXProviderContext.Provider, {\n        value: value\n    }, children);\n}\nexports.Provider = Provider;\nProvider.displayName = \"MobXProvider\";\n/**\n * Store Injection\n */\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n    // Support forward refs\n    var Injector = react_1.default.forwardRef(function (props, ref) {\n        var newProps = _extends({}, props);\n        var context = react_1.default.useContext(MobXProviderContext);\n        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});\n        if (ref) {\n            newProps.ref = ref;\n        }\n        return react_1.default.createElement(component, newProps);\n    });\n    if (makeReactive)\n        Injector = observer(Injector);\n    Injector[\"isMobxInjector\"] = true; // assigned late to suppress observer warning\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, Injector);\n    Injector[\"wrappedComponent\"] = component;\n    Injector.displayName = getInjectName(component, injectNames);\n    return Injector;\n}\nfunction getInjectName(component, injectNames) {\n    var displayName;\n    var componentName = component.displayName || component.name || component.constructor && component.constructor.name || \"Component\";\n    if (injectNames)\n        displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\";\n    else\n        displayName = \"inject(\" + componentName + \")\";\n    return displayName;\n}\nfunction grabStoresByName(storeNames) {\n    return function (baseStores, nextProps) {\n        storeNames.forEach(function (storeName) {\n            if (storeName in nextProps // prefer props over stores\n            )\n                return;\n            if (!(storeName in baseStores))\n                throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n            nextProps[storeName] = baseStores[storeName];\n        });\n        return nextProps;\n    };\n}\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nfunction inject() {\n    for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        storeNames[_key] = arguments[_key];\n    }\n    if (typeof arguments[0] === \"function\") {\n        var grabStoresFn = arguments[0];\n        return function (componentClass) {\n            return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);\n        };\n    }\n    else {\n        return function (componentClass) {\n            return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join(\"-\"), false);\n        };\n    }\n}\nexports.inject = inject;\nvar reactMajorVersion = /*#__PURE__*/ Number.parseInt(/*#__PURE__*/ react_1.default.version.split(\".\")[0]);\nvar warnedAboutDisposeOnUnmountDeprecated = false;\nvar protoStoreKey = /*#__PURE__*/ Symbol(\"disposeOnUnmountProto\");\nvar instStoreKey = /*#__PURE__*/ Symbol(\"disposeOnUnmountInst\");\nfunction runDisposersOnWillUnmount() {\n    var _this = this;\n    [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function (propKeyOrFunction) {\n        var prop = typeof propKeyOrFunction === \"string\" ? _this[propKeyOrFunction] : propKeyOrFunction;\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop))\n                prop.map(function (f) {\n                    return f();\n                });\n            else\n                prop();\n        }\n    });\n}\n/**\n * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.\n */\nfunction disposeOnUnmount(target, propertyKeyOrFunction) {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(function (fn) {\n            return disposeOnUnmount(target, fn);\n        });\n    }\n    if (!warnedAboutDisposeOnUnmountDeprecated) {\n        if (reactMajorVersion >= 18) {\n            console.error(\"[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.\");\n        }\n        else {\n            console.warn(\"[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher.\");\n        }\n        warnedAboutDisposeOnUnmountDeprecated = true;\n    }\n    var c = Object.getPrototypeOf(target).constructor;\n    var c2 = Object.getPrototypeOf(target.constructor);\n    // Special case for react-hot-loader\n    var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));\n    if (!(c === react_1.default.Component || c === react_1.default.PureComponent || c2 === react_1.default.Component || c2 === react_1.default.PureComponent || c3 === react_1.default.Component || c3 === react_1.default.PureComponent)) {\n        throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n    }\n    if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\" && !Array.isArray(propertyKeyOrFunction)) {\n        throw new Error(\"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\");\n    }\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    var isDecorator = typeof propertyKeyOrFunction === \"string\";\n    // add property key / function we want run (disposed) to the store\n    var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];\n    var store = isDecorator ?\n        // decorators are added to the prototype store\n        target[protoStoreKey] || (target[protoStoreKey] = []) :\n        // functions are added to the instance store\n        target[instStoreKey] || (target[instStoreKey] = []);\n    store.push(propertyKeyOrFunction);\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount);\n    }\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction;\n    }\n}\nexports.disposeOnUnmount = disposeOnUnmount;\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validator) {\n    function checkType(isRequired, props, propName, componentName, location, propFullName) {\n        for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n            rest[_key - 6] = arguments[_key];\n        }\n        return (0, mobx_1.untracked)(function () {\n            componentName = componentName || \"<<anonymous>>\";\n            propFullName = propFullName || propName;\n            if (props[propName] == null) {\n                if (isRequired) {\n                    var actual = props[propName] === null ? \"null\" : \"undefined\";\n                    return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n                }\n                return null;\n            }\n            else {\n                // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n                return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));\n            }\n        });\n    }\n    var chainedCheckType = checkType.bind(null, false);\n    // Add isRequired to satisfy Requirable\n    chainedCheckType.isRequired = checkType.bind(null, true);\n    return chainedCheckType;\n}\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true;\n    }\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true;\n    }\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true;\n    }\n    return false;\n}\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n        return \"array\";\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\";\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\";\n    }\n    return propType;\n}\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    var propType = getPropType(propValue);\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\";\n        }\n        else if (propValue instanceof RegExp) {\n            return \"regexp\";\n        }\n    }\n    return propType;\n}\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        return (0, mobx_1.untracked)(function () {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase())\n                    return null;\n            }\n            var mobxChecker;\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = mobx_1.isObservableArray;\n                    break;\n                case \"Object\":\n                    mobxChecker = mobx_1.isObservableObject;\n                    break;\n                case \"Map\":\n                    mobxChecker = mobx_1.isObservableMap;\n                    break;\n                default:\n                    throw new Error(\"Unexpected mobxType: \" + mobxType);\n            }\n            var propValue = props[propName];\n            if (!mobxChecker(propValue)) {\n                var preciseType = getPreciseType(propValue);\n                var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n                return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n            }\n            return null;\n        });\n    });\n}\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n            rest[_key2 - 5] = arguments[_key2];\n        }\n        return (0, mobx_1.untracked)(function () {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n            }\n            else {\n                var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName, location, propFullName);\n                if (error instanceof Error)\n                    return error;\n                var propValue = props[propName];\n                for (var i = 0; i < propValue.length; i++) {\n                    error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n                    if (error instanceof Error)\n                        return error;\n                }\n                return null;\n            }\n        });\n    });\n}\nvar observableArray = /*#__PURE__*/ createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = /*#__PURE__*/ createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = /*#__PURE__*/ createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = /*#__PURE__*/ createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = /*#__PURE__*/ createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = /*#__PURE__*/ createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = /*#__PURE__*/ createObservableTypeCheckerCreator(true, \"Object\");\nvar PropTypes = {\n    observableArray: observableArray,\n    observableArrayOf: observableArrayOf,\n    observableMap: observableMap,\n    observableObject: observableObject,\n    arrayOrObservableArray: arrayOrObservableArray,\n    arrayOrObservableArrayOf: arrayOrObservableArrayOf,\n    objectOrObservableObject: objectOrObservableObject\n};\nexports.PropTypes = PropTypes;\nif (!react_1.Component) {\n    throw new Error(\"mobx-react requires React to be available\");\n}\nif (!mobx_1.observable) {\n    throw new Error(\"mobx-react requires mobx to be available\");\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react/dist/mobxreact.esm.js?");

/***/ }),

/***/ "./node_modules/mobx/dist/mobx.esm.js":
/*!********************************************!*\
  !*** ./node_modules/mobx/dist/mobx.esm.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeObservable = exports.makeAutoObservable = exports.keys = exports.isObservableSet = exports.isObservableProp = exports.isObservableObject = exports.isObservableMap = exports.isObservableArray = exports.isObservable = exports.isFlowCancellationError = exports.isFlow = exports.isComputedProp = exports.isComputed = exports.isBoxedObservable = exports.isAction = exports.intercept = exports.has = exports.getObserverTree = exports.getDependencyTree = exports.getDebugName = exports.getAtom = exports.get = exports.flowResult = exports.flow = exports.extendObservable = exports.entries = exports.defineProperty = exports.createAtom = exports.configure = exports.computed = exports.comparer = exports.autorun = exports.action = exports._startAction = exports._resetGlobalState = exports._isComputingDerivation = exports._interceptReads = exports._getGlobalState = exports._getAdministration = exports._endAction = exports._autoAction = exports._allowStateReadsStart = exports._allowStateReadsEnd = exports._allowStateChangesInsideComputed = exports._allowStateChanges = exports.Reaction = exports.ObservableSet = exports.ObservableMap = exports.FlowCancellationError = exports.$mobx = void 0;\nexports.when = exports.values = exports.untracked = exports.transaction = exports.trace = exports.toJS = exports.spy = exports.set = exports.runInAction = exports.remove = exports.reaction = exports.ownKeys = exports.override = exports.onReactionError = exports.onBecomeUnobserved = exports.onBecomeObserved = exports.observe = exports.observable = void 0;\nvar niceErrors = {\n    0: \"Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'\",\n    1: function _(annotationType, key) {\n        return \"Cannot apply '\" + annotationType + \"' to '\" + key.toString() + \"': Field not found.\";\n    },\n    /*\n    2(prop) {\n        return `invalid decorator for '${prop.toString()}'`\n    },\n    3(prop) {\n        return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`\n    },\n    4(prop) {\n        return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`\n    },\n    */\n    5: \"'keys()' can only be used on observable objects, arrays, sets and maps\",\n    6: \"'values()' can only be used on observable objects, arrays, sets and maps\",\n    7: \"'entries()' can only be used on observable objects, arrays and maps\",\n    8: \"'set()' can only be used on observable objects, arrays and maps\",\n    9: \"'remove()' can only be used on observable objects, arrays and maps\",\n    10: \"'has()' can only be used on observable objects, arrays and maps\",\n    11: \"'get()' can only be used on observable objects, arrays and maps\",\n    12: \"Invalid annotation\",\n    13: \"Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n    14: \"Intercept handlers should return nothing or a change object\",\n    15: \"Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n    16: \"Modification exception: the internal structure of an observable array was changed.\",\n    17: function _(index, length) {\n        return \"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + length;\n    },\n    18: \"mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js\",\n    19: function _(other) {\n        return \"Cannot initialize from classes that inherit from Map: \" + other.constructor.name;\n    },\n    20: function _(other) {\n        return \"Cannot initialize map from \" + other;\n    },\n    21: function _(dataStructure) {\n        return \"Cannot convert to map from '\" + dataStructure + \"'\";\n    },\n    22: \"mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js\",\n    23: \"It is not possible to get index atoms from arrays\",\n    24: function _(thing) {\n        return \"Cannot obtain administration from \" + thing;\n    },\n    25: function _(property, name) {\n        return \"the entry '\" + property + \"' does not exist in the observable map '\" + name + \"'\";\n    },\n    26: \"please specify a property\",\n    27: function _(property, name) {\n        return \"no observable property '\" + property.toString() + \"' found on the observable object '\" + name + \"'\";\n    },\n    28: function _(thing) {\n        return \"Cannot obtain atom from \" + thing;\n    },\n    29: \"Expecting some object\",\n    30: \"invalid action stack. did you forget to finish an action?\",\n    31: \"missing option for computed: get\",\n    32: function _(name, derivation) {\n        return \"Cycle detected in computation \" + name + \": \" + derivation;\n    },\n    33: function _(name) {\n        return \"The setter of computed value '\" + name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\";\n    },\n    34: function _(name) {\n        return \"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\";\n    },\n    35: \"There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`\",\n    36: \"isolateGlobalState should be called before MobX is running any reactions\",\n    37: function _(method) {\n        return \"[mobx] `observableArray.\" + method + \"()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice().\" + method + \"()` instead\";\n    },\n    38: \"'ownKeys()' can only be used on observable objects\",\n    39: \"'defineProperty()' can only be used on observable objects\"\n};\nvar errors =  true ? niceErrors : undefined;\nfunction die(error) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n    }\n    if (true) {\n        var e = typeof error === \"string\" ? error : errors[error];\n        if (typeof e === \"function\")\n            e = e.apply(null, args);\n        throw new Error(\"[MobX] \" + e);\n    }\n    throw new Error(typeof error === \"number\" ? \"[MobX] minified error nr: \" + error + (args.length ? \" \" + args.map(String).join(\",\") : \"\") + \". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts\" : \"[MobX] \" + error);\n}\nvar mockGlobal = {};\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return mockGlobal;\n}\n// We shorten anything used > 5 times\nvar assign = Object.assign;\nvar getDescriptor = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar objectPrototype = Object.prototype;\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nvar EMPTY_OBJECT = {};\nObject.freeze(EMPTY_OBJECT);\nvar hasProxy = typeof Proxy !== \"undefined\";\nvar plainObjectString = /*#__PURE__*/ Object.toString();\nfunction assertProxies() {\n    if (!hasProxy) {\n        die( true ? \"`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`\" : undefined);\n    }\n}\nfunction warnAboutProxyRequirement(msg) {\n    if ( true && globalState.verifyProxies) {\n        die(\"MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to \" + msg);\n    }\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\n/**\n * Makes sure that the provided function is invoked at most once.\n */\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) {\n            return;\n        }\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() { };\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\nfunction isStringish(value) {\n    var t = typeof value;\n    switch (t) {\n        case \"string\":\n        case \"symbol\":\n        case \"number\":\n            return true;\n    }\n    return false;\n}\nfunction isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nfunction isPlainObject(value) {\n    if (!isObject(value)) {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n        return true;\n    }\n    var protoConstructor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    return typeof protoConstructor === \"function\" && protoConstructor.toString() === plainObjectString;\n}\n// https://stackoverflow.com/a/37865170\nfunction isGenerator(obj) {\n    var constructor = obj == null ? void 0 : obj.constructor;\n    if (!constructor) {\n        return false;\n    }\n    if (\"GeneratorFunction\" === constructor.name || \"GeneratorFunction\" === constructor.displayName) {\n        return true;\n    }\n    return false;\n}\nfunction addHiddenProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction createInstanceofPredicate(name, theClass) {\n    var propName = \"isMobX\" + name;\n    theClass.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isES6Map(thing) {\n    return thing instanceof Map;\n}\nfunction isES6Set(thing) {\n    return thing instanceof Set;\n}\nvar hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== \"undefined\";\n/**\n * Returns the following: own enumerable keys and symbols.\n */\nfunction getPlainObjectKeys(object) {\n    var keys = Object.keys(object);\n    // Not supported in IE, so there are not going to be symbol props anyway...\n    if (!hasGetOwnPropertySymbols) {\n        return keys;\n    }\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (!symbols.length) {\n        return keys;\n    }\n    return [].concat(keys, symbols.filter(function (s) {\n        return objectPrototype.propertyIsEnumerable.call(object, s);\n    }));\n}\n// From Immer utils\n// Returns all own keys, including non-enumerable and symbolic\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : /* istanbul ignore next */ Object.getOwnPropertyNames;\nfunction stringifyKey(key) {\n    if (typeof key === \"string\") {\n        return key;\n    }\n    if (typeof key === \"symbol\") {\n        return key.toString();\n    }\n    return new String(key).toString();\n}\nfunction toPrimitive(value) {\n    return value === null ? null : typeof value === \"object\" ? \"\" + value : value;\n}\nfunction hasProp(target, prop) {\n    return objectPrototype.hasOwnProperty.call(target, prop);\n}\n// From Immer utils\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n    // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n    var res = {};\n    // Note: without polyfill for ownKeys, symbols won't be picked up\n    ownKeys(target).forEach(function (key) {\n        res[key] = getDescriptor(target, key);\n    });\n    return res;\n};\nfunction _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n            descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n        _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o)\n        return;\n    if (typeof o === \"string\")\n        return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor)\n        n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\")\n        return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n        return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length)\n        len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++)\n        arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it)\n        return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it)\n            o = it;\n        var i = 0;\n        return function () {\n            if (i >= o.length)\n                return {\n                    done: true\n                };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null)\n        return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\")\n            return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nvar storedAnnotationsSymbol = /*#__PURE__*/ Symbol(\"mobx-stored-annotations\");\n/**\n * Creates a function that acts as\n * - decorator\n * - annotation object\n */\nfunction createDecoratorAnnotation(annotation) {\n    function decorator(target, property) {\n        if (is20223Decorator(property)) {\n            return annotation.decorate_20223_(target, property);\n        }\n        else {\n            storeAnnotation(target, property, annotation);\n        }\n    }\n    return Object.assign(decorator, annotation);\n}\n/**\n * Stores annotation to prototype,\n * so it can be inspected later by `makeObservable` called from constructor\n */\nfunction storeAnnotation(prototype, key, annotation) {\n    if (!hasProp(prototype, storedAnnotationsSymbol)) {\n        addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));\n    }\n    // @override must override something\n    if ( true && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {\n        var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n        die(\"'\" + fieldName + \"' is decorated with 'override', \" + \"but no such decorated member was found on prototype.\");\n    }\n    // Cannot re-decorate\n    assertNotDecorated(prototype, annotation, key);\n    // Ignore override\n    if (!isOverride(annotation)) {\n        prototype[storedAnnotationsSymbol][key] = annotation;\n    }\n}\nfunction assertNotDecorated(prototype, annotation, key) {\n    if ( true && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {\n        var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n        var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;\n        var requestedAnnotationType = annotation.annotationType_;\n        die(\"Cannot apply '@\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already decorated with '@\" + currentAnnotationType + \"'.\") + \"\\nRe-decorating fields is not allowed.\" + \"\\nUse '@override' decorator for methods overridden by subclass.\");\n    }\n}\n/**\n * Collects annotations from prototypes and stores them on target (instance)\n */\nfunction collectStoredAnnotations(target) {\n    if (!hasProp(target, storedAnnotationsSymbol)) {\n        // if (__DEV__ && !target[storedAnnotationsSymbol]) {\n        //     die(\n        //         `No annotations were passed to makeObservable, but no decorated members have been found either`\n        //     )\n        // }\n        // We need a copy as we will remove annotation from the list once it's applied.\n        addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));\n    }\n    return target[storedAnnotationsSymbol];\n}\nfunction is20223Decorator(context) {\n    return typeof context == \"object\" && typeof context[\"kind\"] == \"string\";\n}\nfunction assert20223DecoratorType(context, types) {\n    if ( true && !types.includes(context.kind)) {\n        die(\"The decorator applied to '\" + String(context.name) + \"' cannot be used on a \" + context.kind + \" element\");\n    }\n}\nvar $mobx = /*#__PURE__*/ Symbol(\"mobx administration\");\nexports.$mobx = $mobx;\nvar Atom = /*#__PURE__*/ function () {\n    // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed\n    /**\n     * Create a new atom. For debugging purposes it is recommended to give it a name.\n     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\n     */\n    function Atom(name_) {\n        if (name_ === void 0) {\n            name_ =  true ? \"Atom@\" + getNextId() : undefined;\n        }\n        this.name_ = void 0;\n        this.isPendingUnobservation_ = false;\n        this.isBeingObserved_ = false;\n        this.observers_ = new Set();\n        this.diffValue_ = 0;\n        this.lastAccessedBy_ = 0;\n        this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;\n        this.onBOL = void 0;\n        this.onBUOL = void 0;\n        this.name_ = name_;\n    }\n    // onBecomeObservedListeners\n    var _proto = Atom.prototype;\n    _proto.onBO = function onBO() {\n        if (this.onBOL) {\n            this.onBOL.forEach(function (listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.onBUO = function onBUO() {\n        if (this.onBUOL) {\n            this.onBUOL.forEach(function (listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.reportObserved = function reportObserved$1() {\n        return reportObserved(this);\n    };\n    _proto.reportChanged = function reportChanged() {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    _proto.toString = function toString() {\n        return this.name_;\n    };\n    return Atom;\n}();\nvar isAtom = /*#__PURE__*/ createInstanceofPredicate(\"Atom\", Atom);\nfunction createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n    if (onBecomeObservedHandler === void 0) {\n        onBecomeObservedHandler = noop;\n    }\n    if (onBecomeUnobservedHandler === void 0) {\n        onBecomeUnobservedHandler = noop;\n    }\n    var atom = new Atom(name);\n    // default `noop` listener will not initialize the hook Set\n    if (onBecomeObservedHandler !== noop) {\n        onBecomeObserved(atom, onBecomeObservedHandler);\n    }\n    if (onBecomeUnobservedHandler !== noop) {\n        onBecomeUnobserved(atom, onBecomeUnobservedHandler);\n    }\n    return atom;\n}\nexports.createAtom = createAtom;\nfunction identityComparer(a, b) {\n    return a === b;\n}\nfunction structuralComparer(a, b) {\n    return deepEqual(a, b);\n}\nfunction shallowComparer(a, b) {\n    return deepEqual(a, b, 1);\n}\nfunction defaultComparer(a, b) {\n    if (Object.is) {\n        return Object.is(a, b);\n    }\n    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;\n}\nvar comparer = {\n    identity: identityComparer,\n    structural: structuralComparer,\n    \"default\": defaultComparer,\n    shallow: shallowComparer\n};\nexports.comparer = comparer;\nfunction deepEnhancer(v, _, name) {\n    // it is an observable already, done\n    if (isObservable(v)) {\n        return v;\n    }\n    // something that can be converted and mutated?\n    if (Array.isArray(v)) {\n        return observable.array(v, {\n            name: name\n        });\n    }\n    if (isPlainObject(v)) {\n        return observable.object(v, undefined, {\n            name: name\n        });\n    }\n    if (isES6Map(v)) {\n        return observable.map(v, {\n            name: name\n        });\n    }\n    if (isES6Set(v)) {\n        return observable.set(v, {\n            name: name\n        });\n    }\n    if (typeof v === \"function\" && !isAction(v) && !isFlow(v)) {\n        if (isGenerator(v)) {\n            return flow(v);\n        }\n        else {\n            return autoAction(name, v);\n        }\n    }\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (v === undefined || v === null) {\n        return v;\n    }\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {\n        return v;\n    }\n    if (Array.isArray(v)) {\n        return observable.array(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isPlainObject(v)) {\n        return observable.object(v, undefined, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isES6Map(v)) {\n        return observable.map(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (isES6Set(v)) {\n        return observable.set(v, {\n            name: name,\n            deep: false\n        });\n    }\n    if (true) {\n        die(\"The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets\");\n    }\n}\nfunction referenceEnhancer(newValue) {\n    // never turn into an observable\n    return newValue;\n}\nfunction refStructEnhancer(v, oldValue) {\n    if ( true && isObservable(v)) {\n        die(\"observable.struct should not be used with observable values\");\n    }\n    if (deepEqual(v, oldValue)) {\n        return oldValue;\n    }\n    return v;\n}\nvar OVERRIDE = \"override\";\nvar override = /*#__PURE__*/ createDecoratorAnnotation({\n    annotationType_: OVERRIDE,\n    make_: make_,\n    extend_: extend_,\n    decorate_20223_: decorate_20223_\n});\nexports.override = override;\nfunction isOverride(annotation) {\n    return annotation.annotationType_ === OVERRIDE;\n}\nfunction make_(adm, key) {\n    // Must not be plain object\n    if ( true && adm.isPlainObject_) {\n        die(\"Cannot apply '\" + this.annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + this.annotationType_ + \"' cannot be used on plain objects.\"));\n    }\n    // Must override something\n    if ( true && !hasProp(adm.appliedAnnotations_, key)) {\n        die(\"'\" + adm.name_ + \".\" + key.toString() + \"' is annotated with '\" + this.annotationType_ + \"', \" + \"but no such annotated member was found on prototype.\");\n    }\n    return 0 /* MakeResult.Cancel */;\n}\nfunction extend_(adm, key, descriptor, proxyTrap) {\n    die(\"'\" + this.annotationType_ + \"' can only be used with 'makeObservable'\");\n}\nfunction decorate_20223_(desc, context) {\n    console.warn(\"'\" + this.annotationType_ + \"' cannot be used with decorators - this is a no-op\");\n}\nfunction createActionAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$1,\n        extend_: extend_$1,\n        decorate_20223_: decorate_20223_$1\n    };\n}\nfunction make_$1(adm, key, descriptor, source) {\n    var _this$options_;\n    // bound\n    if ((_this$options_ = this.options_) != null && _this$options_.bound) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 1 /* MakeResult.Break */;\n    }\n    // own\n    if (source === adm.target_) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 2 /* MakeResult.Continue */;\n    }\n    // prototype\n    if (isAction(descriptor.value)) {\n        // A prototype could have been annotated already by other constructor,\n        // rest of the proto chain must be annotated already\n        return 1 /* MakeResult.Break */;\n    }\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);\n    defineProperty(source, key, actionDescriptor);\n    return 2 /* MakeResult.Continue */;\n}\nfunction extend_$1(adm, key, descriptor, proxyTrap) {\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);\n    return adm.defineProperty_(key, actionDescriptor, proxyTrap);\n}\nfunction decorate_20223_$1(mthd, context) {\n    if (true) {\n        assert20223DecoratorType(context, [\"method\", \"field\"]);\n    }\n    var kind = context.kind, name = context.name, addInitializer = context.addInitializer;\n    var ann = this;\n    var _createAction = function _createAction(m) {\n        var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;\n        return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);\n    };\n    // Backwards/Legacy behavior, expects makeObservable(this)\n    if (kind == \"field\") {\n        addInitializer(function () {\n            storeAnnotation(this, name, ann);\n        });\n        return;\n    }\n    if (kind == \"method\") {\n        var _this$options_2;\n        if (!isAction(mthd)) {\n            mthd = _createAction(mthd);\n        }\n        if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {\n            addInitializer(function () {\n                var self = this;\n                var bound = self[name].bind(self);\n                bound.isMobxAction = true;\n                self[name] = bound;\n            });\n        }\n        return mthd;\n    }\n    die(\"Cannot apply '\" + ann.annotationType_ + \"' to '\" + String(name) + \"' (kind: \" + kind + \"):\" + (\"\\n'\" + ann.annotationType_ + \"' can only be used on properties with a function value.\"));\n}\nfunction assertActionDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var value = _ref2.value;\n    if ( true && !isFunction(value)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a function value.\"));\n    }\n}\nfunction createActionDescriptor(adm, annotation, key, descriptor, \n// provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;\n    if (safeDescriptors === void 0) {\n        safeDescriptors = globalState.safeDescriptors;\n    }\n    assertActionDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {\n        var _adm$proxy_;\n        value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return {\n        value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, \n        // https://github.com/mobxjs/mobx/discussions/3140\n        (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),\n        // Non-configurable for classes\n        // prevents accidental field redefinition in subclass\n        configurable: safeDescriptors ? adm.isPlainObject_ : true,\n        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n        enumerable: false,\n        // Non-obsevable, therefore non-writable\n        // Also prevents rewriting in subclass constructor\n        writable: safeDescriptors ? false : true\n    };\n}\nfunction createFlowAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$2,\n        extend_: extend_$2,\n        decorate_20223_: decorate_20223_$2\n    };\n}\nfunction make_$2(adm, key, descriptor, source) {\n    var _this$options_;\n    // own\n    if (source === adm.target_) {\n        return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 2 /* MakeResult.Continue */;\n    }\n    // prototype\n    // bound - must annotate protos to support super.flow()\n    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {\n        if (this.extend_(adm, key, descriptor, false) === null) {\n            return 0 /* MakeResult.Cancel */;\n        }\n    }\n    if (isFlow(descriptor.value)) {\n        // A prototype could have been annotated already by other constructor,\n        // rest of the proto chain must be annotated already\n        return 1 /* MakeResult.Break */;\n    }\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);\n    defineProperty(source, key, flowDescriptor);\n    return 2 /* MakeResult.Continue */;\n}\nfunction extend_$2(adm, key, descriptor, proxyTrap) {\n    var _this$options_2;\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);\n    return adm.defineProperty_(key, flowDescriptor, proxyTrap);\n}\nfunction decorate_20223_$2(mthd, context) {\n    var _this$options_3;\n    if (true) {\n        assert20223DecoratorType(context, [\"method\"]);\n    }\n    var name = context.name, addInitializer = context.addInitializer;\n    if (!isFlow(mthd)) {\n        mthd = flow(mthd);\n    }\n    if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {\n        addInitializer(function () {\n            var self = this;\n            var bound = self[name].bind(self);\n            bound.isMobXFlow = true;\n            self[name] = bound;\n        });\n    }\n    return mthd;\n}\nfunction assertFlowDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var value = _ref2.value;\n    if ( true && !isFunction(value)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a generator function value.\"));\n    }\n}\nfunction createFlowDescriptor(adm, annotation, key, descriptor, bound, \n// provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n    if (safeDescriptors === void 0) {\n        safeDescriptors = globalState.safeDescriptors;\n    }\n    assertFlowDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    // In case of flow.bound, the descriptor can be from already annotated prototype\n    if (!isFlow(value)) {\n        value = flow(value);\n    }\n    if (bound) {\n        var _adm$proxy_;\n        // We do not keep original function around, so we bind the existing flow\n        value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n        // This is normally set by `flow`, but `bind` returns new function...\n        value.isMobXFlow = true;\n    }\n    return {\n        value: value,\n        // Non-configurable for classes\n        // prevents accidental field redefinition in subclass\n        configurable: safeDescriptors ? adm.isPlainObject_ : true,\n        // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n        enumerable: false,\n        // Non-obsevable, therefore non-writable\n        // Also prevents rewriting in subclass constructor\n        writable: safeDescriptors ? false : true\n    };\n}\nfunction createComputedAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$3,\n        extend_: extend_$3,\n        decorate_20223_: decorate_20223_$3\n    };\n}\nfunction make_$3(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 1 /* MakeResult.Break */;\n}\nfunction extend_$3(adm, key, descriptor, proxyTrap) {\n    assertComputedDescriptor(adm, this, key, descriptor);\n    return adm.defineComputedProperty_(key, _extends({}, this.options_, {\n        get: descriptor.get,\n        set: descriptor.set\n    }), proxyTrap);\n}\nfunction decorate_20223_$3(get, context) {\n    if (true) {\n        assert20223DecoratorType(context, [\"getter\"]);\n    }\n    var ann = this;\n    var key = context.name, addInitializer = context.addInitializer;\n    addInitializer(function () {\n        var adm = asObservableObject(this)[$mobx];\n        var options = _extends({}, ann.options_, {\n            get: get,\n            context: this\n        });\n        options.name || (options.name =  true ? adm.name_ + \".\" + key.toString() : undefined);\n        adm.values_.set(key, new ComputedValue(options));\n    });\n    return function () {\n        return this[$mobx].getObservablePropValue_(key);\n    };\n}\nfunction assertComputedDescriptor(adm, _ref, key, _ref2) {\n    var annotationType_ = _ref.annotationType_;\n    var get = _ref2.get;\n    if ( true && !get) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on getter(+setter) properties.\"));\n    }\n}\nfunction createObservableAnnotation(name, options) {\n    return {\n        annotationType_: name,\n        options_: options,\n        make_: make_$4,\n        extend_: extend_$4,\n        decorate_20223_: decorate_20223_$4\n    };\n}\nfunction make_$4(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 /* MakeResult.Cancel */ : 1 /* MakeResult.Break */;\n}\nfunction extend_$4(adm, key, descriptor, proxyTrap) {\n    var _this$options_$enhanc, _this$options_;\n    assertObservableDescriptor(adm, this, key, descriptor);\n    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);\n}\nfunction decorate_20223_$4(desc, context) {\n    if (true) {\n        if (context.kind === \"field\") {\n            throw die(\"Please use `@observable accessor \" + String(context.name) + \"` instead of `@observable \" + String(context.name) + \"`\");\n        }\n        assert20223DecoratorType(context, [\"accessor\"]);\n    }\n    var ann = this;\n    var kind = context.kind, name = context.name;\n    // The laziness here is not ideal... It's a workaround to how 2022.3 Decorators are implemented:\n    //   `addInitializer` callbacks are executed _before_ any accessors are defined (instead of the ideal-for-us right after each).\n    //   This means that, if we were to do our stuff in an `addInitializer`, we'd attempt to read a private slot\n    //   before it has been initialized. The runtime doesn't like that and throws a `Cannot read private member\n    //   from an object whose class did not declare it` error.\n    // TODO: it seems that this will not be required anymore in the final version of the spec\n    // See TODO: link\n    var initializedObjects = new WeakSet();\n    function initializeObservable(target, value) {\n        var _ann$options_$enhance, _ann$options_;\n        var adm = asObservableObject(target)[$mobx];\n        var observable = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer,  true ? adm.name_ + \".\" + name.toString() : undefined, false);\n        adm.values_.set(name, observable);\n        initializedObjects.add(target);\n    }\n    if (kind == \"accessor\") {\n        return {\n            get: function get() {\n                if (!initializedObjects.has(this)) {\n                    initializeObservable(this, desc.get.call(this));\n                }\n                return this[$mobx].getObservablePropValue_(name);\n            },\n            set: function set(value) {\n                if (!initializedObjects.has(this)) {\n                    initializeObservable(this, value);\n                }\n                return this[$mobx].setObservablePropValue_(name, value);\n            },\n            init: function init(value) {\n                if (!initializedObjects.has(this)) {\n                    initializeObservable(this, value);\n                }\n                return value;\n            }\n        };\n    }\n    return;\n}\nfunction assertObservableDescriptor(adm, _ref, key, descriptor) {\n    var annotationType_ = _ref.annotationType_;\n    if ( true && !(\"value\" in descriptor)) {\n        die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' cannot be used on getter/setter properties\"));\n    }\n}\nvar AUTO = \"true\";\nvar autoAnnotation = /*#__PURE__*/ createAutoAnnotation();\nfunction createAutoAnnotation(options) {\n    return {\n        annotationType_: AUTO,\n        options_: options,\n        make_: make_$5,\n        extend_: extend_$5,\n        decorate_20223_: decorate_20223_$5\n    };\n}\nfunction make_$5(adm, key, descriptor, source) {\n    var _this$options_3, _this$options_4;\n    // getter -> computed\n    if (descriptor.get) {\n        return computed.make_(adm, key, descriptor, source);\n    }\n    // lone setter -> action setter\n    if (descriptor.set) {\n        // TODO make action applicable to setter and delegate to action.make_\n        var set = createAction(key.toString(), descriptor.set);\n        // own\n        if (source === adm.target_) {\n            return adm.defineProperty_(key, {\n                configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n                set: set\n            }) === null ? 0 /* MakeResult.Cancel */ : 2 /* MakeResult.Continue */;\n        }\n        // proto\n        defineProperty(source, key, {\n            configurable: true,\n            set: set\n        });\n        return 2 /* MakeResult.Continue */;\n    }\n    // function on proto -> autoAction/flow\n    if (source !== adm.target_ && typeof descriptor.value === \"function\") {\n        var _this$options_2;\n        if (isGenerator(descriptor.value)) {\n            var _this$options_;\n            var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;\n            return flowAnnotation.make_(adm, key, descriptor, source);\n        }\n        var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;\n        return actionAnnotation.make_(adm, key, descriptor, source);\n    }\n    // other -> observable\n    // Copy props from proto as well, see test:\n    // \"decorate should work with Object.create\"\n    var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;\n    // if function respect autoBind option\n    if (typeof descriptor.value === \"function\" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {\n        var _adm$proxy_;\n        descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return observableAnnotation.make_(adm, key, descriptor, source);\n}\nfunction extend_$5(adm, key, descriptor, proxyTrap) {\n    var _this$options_5, _this$options_6;\n    // getter -> computed\n    if (descriptor.get) {\n        return computed.extend_(adm, key, descriptor, proxyTrap);\n    }\n    // lone setter -> action setter\n    if (descriptor.set) {\n        // TODO make action applicable to setter and delegate to action.extend_\n        return adm.defineProperty_(key, {\n            configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n            set: createAction(key.toString(), descriptor.set)\n        }, proxyTrap);\n    }\n    // other -> observable\n    // if function respect autoBind option\n    if (typeof descriptor.value === \"function\" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {\n        var _adm$proxy_2;\n        descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);\n    }\n    var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;\n    return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);\n}\nfunction decorate_20223_$5(desc, context) {\n    die(\"'\" + this.annotationType_ + \"' cannot be used as a decorator\");\n}\nvar OBSERVABLE = \"observable\";\nvar OBSERVABLE_REF = \"observable.ref\";\nvar OBSERVABLE_SHALLOW = \"observable.shallow\";\nvar OBSERVABLE_STRUCT = \"observable.struct\";\n// Predefined bags of create observable options, to avoid allocating temporarily option objects\n// in the majority of cases\nvar defaultCreateObservableOptions = {\n    deep: true,\n    name: undefined,\n    defaultDecorator: undefined,\n    proxy: true\n};\nObject.freeze(defaultCreateObservableOptions);\nfunction asCreateObservableOptions(thing) {\n    return thing || defaultCreateObservableOptions;\n}\nvar observableAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE);\nvar observableRefAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_REF, {\n    enhancer: referenceEnhancer\n});\nvar observableShallowAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_SHALLOW, {\n    enhancer: shallowEnhancer\n});\nvar observableStructAnnotation = /*#__PURE__*/ createObservableAnnotation(OBSERVABLE_STRUCT, {\n    enhancer: refStructEnhancer\n});\nvar observableDecoratorAnnotation = /*#__PURE__*/ createDecoratorAnnotation(observableAnnotation);\nfunction getEnhancerFromOptions(options) {\n    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);\n}\nfunction getAnnotationFromOptions(options) {\n    var _options$defaultDecor;\n    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;\n}\nfunction getEnhancerFromAnnotation(annotation) {\n    var _annotation$options_$, _annotation$options_;\n    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;\n}\n/**\n * Turns an object, array or function into a reactive structure.\n * @param v the value which should become observable.\n */\nfunction createObservable(v, arg2, arg3) {\n    // @observable someProp; (2022.3 Decorators)\n    if (is20223Decorator(arg2)) {\n        return observableAnnotation.decorate_20223_(v, arg2);\n    }\n    // @observable someProp;\n    if (isStringish(arg2)) {\n        storeAnnotation(v, arg2, observableAnnotation);\n        return;\n    }\n    // already observable - ignore\n    if (isObservable(v)) {\n        return v;\n    }\n    // plain object\n    if (isPlainObject(v)) {\n        return observable.object(v, arg2, arg3);\n    }\n    // Array\n    if (Array.isArray(v)) {\n        return observable.array(v, arg2);\n    }\n    // Map\n    if (isES6Map(v)) {\n        return observable.map(v, arg2);\n    }\n    // Set\n    if (isES6Set(v)) {\n        return observable.set(v, arg2);\n    }\n    // other object - ignore\n    if (typeof v === \"object\" && v !== null) {\n        return v;\n    }\n    // anything else\n    return observable.box(v, arg2);\n}\nassign(createObservable, observableDecoratorAnnotation);\nvar observableFactories = {\n    box: function box(value, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);\n    },\n    array: function array(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    map: function map(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    set: function set(initialValues, options) {\n        var o = asCreateObservableOptions(options);\n        return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    object: function object(props, decorators, options) {\n        return initObservable(function () {\n            return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);\n        });\n    },\n    ref: /*#__PURE__*/ createDecoratorAnnotation(observableRefAnnotation),\n    shallow: /*#__PURE__*/ createDecoratorAnnotation(observableShallowAnnotation),\n    deep: observableDecoratorAnnotation,\n    struct: /*#__PURE__*/ createDecoratorAnnotation(observableStructAnnotation)\n};\n// eslint-disable-next-line\nvar observable = /*#__PURE__*/ assign(createObservable, observableFactories);\nexports.observable = observable;\nvar COMPUTED = \"computed\";\nvar COMPUTED_STRUCT = \"computed.struct\";\nvar computedAnnotation = /*#__PURE__*/ createComputedAnnotation(COMPUTED);\nvar computedStructAnnotation = /*#__PURE__*/ createComputedAnnotation(COMPUTED_STRUCT, {\n    equals: comparer.structural\n});\n/**\n * Decorator for class properties: @computed get value() { return expr; }.\n * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;\n */\nvar computed = function computed(arg1, arg2) {\n    if (is20223Decorator(arg2)) {\n        // @computed (2022.3 Decorators)\n        return computedAnnotation.decorate_20223_(arg1, arg2);\n    }\n    if (isStringish(arg2)) {\n        // @computed\n        return storeAnnotation(arg1, arg2, computedAnnotation);\n    }\n    if (isPlainObject(arg1)) {\n        // @computed({ options })\n        return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));\n    }\n    // computed(expr, options?)\n    if (true) {\n        if (!isFunction(arg1)) {\n            die(\"First argument to `computed` should be an expression.\");\n        }\n        if (isFunction(arg2)) {\n            die(\"A setter as second argument is no longer supported, use `{ set: fn }` option instead\");\n        }\n    }\n    var opts = isPlainObject(arg2) ? arg2 : {};\n    opts.get = arg1;\n    opts.name || (opts.name = arg1.name || \"\"); /* for generated name */\n    return new ComputedValue(opts);\n};\nexports.computed = computed;\nObject.assign(computed, computedAnnotation);\ncomputed.struct = /*#__PURE__*/ createDecoratorAnnotation(computedStructAnnotation);\nvar _getDescriptor$config, _getDescriptor;\n// we don't use globalState for these in order to avoid possible issues with multiple\n// mobx versions\nvar currentActionId = 0;\nvar nextActionId = 1;\nvar isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/ getDescriptor(function () { }, \"name\")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;\n// we can safely recycle this object\nvar tmpNameDescriptor = {\n    value: \"action\",\n    configurable: true,\n    writable: false,\n    enumerable: false\n};\nfunction createAction(actionName, fn, autoAction, ref) {\n    if (autoAction === void 0) {\n        autoAction = false;\n    }\n    if (true) {\n        if (!isFunction(fn)) {\n            die(\"`action` can only be invoked on functions\");\n        }\n        if (typeof actionName !== \"string\" || !actionName) {\n            die(\"actions should have valid names, got: '\" + actionName + \"'\");\n        }\n    }\n    function res() {\n        return executeAction(actionName, autoAction, fn, ref || this, arguments);\n    }\n    res.isMobxAction = true;\n    res.toString = function () {\n        return fn.toString();\n    };\n    if (isFunctionNameConfigurable) {\n        tmpNameDescriptor.value = actionName;\n        defineProperty(res, \"name\", tmpNameDescriptor);\n    }\n    return res;\n}\nfunction executeAction(actionName, canRunAsDerivation, fn, scope, args) {\n    var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);\n    try {\n        return fn.apply(scope, args);\n    }\n    catch (err) {\n        runInfo.error_ = err;\n        throw err;\n    }\n    finally {\n        _endAction(runInfo);\n    }\n}\nfunction _startAction(actionName, canRunAsDerivation, \n// true for autoAction\nscope, args) {\n    var notifySpy_ =  true && isSpyEnabled() && !!actionName;\n    var startTime_ = 0;\n    if ( true && notifySpy_) {\n        startTime_ = Date.now();\n        var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;\n        spyReportStart({\n            type: ACTION,\n            name: actionName,\n            object: scope,\n            arguments: flattenedArgs\n        });\n    }\n    var prevDerivation_ = globalState.trackingDerivation;\n    var runAsAction = !canRunAsDerivation || !prevDerivation_;\n    startBatch();\n    var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow\n    if (runAsAction) {\n        untrackedStart();\n        prevAllowStateChanges_ = allowStateChangesStart(true);\n    }\n    var prevAllowStateReads_ = allowStateReadsStart(true);\n    var runInfo = {\n        runAsAction_: runAsAction,\n        prevDerivation_: prevDerivation_,\n        prevAllowStateChanges_: prevAllowStateChanges_,\n        prevAllowStateReads_: prevAllowStateReads_,\n        notifySpy_: notifySpy_,\n        startTime_: startTime_,\n        actionId_: nextActionId++,\n        parentActionId_: currentActionId\n    };\n    currentActionId = runInfo.actionId_;\n    return runInfo;\n}\nexports._startAction = _startAction;\nfunction _endAction(runInfo) {\n    if (currentActionId !== runInfo.actionId_) {\n        die(30);\n    }\n    currentActionId = runInfo.parentActionId_;\n    if (runInfo.error_ !== undefined) {\n        globalState.suppressReactionErrors = true;\n    }\n    allowStateChangesEnd(runInfo.prevAllowStateChanges_);\n    allowStateReadsEnd(runInfo.prevAllowStateReads_);\n    endBatch();\n    if (runInfo.runAsAction_) {\n        untrackedEnd(runInfo.prevDerivation_);\n    }\n    if ( true && runInfo.notifySpy_) {\n        spyReportEnd({\n            time: Date.now() - runInfo.startTime_\n        });\n    }\n    globalState.suppressReactionErrors = false;\n}\nexports._endAction = _endAction;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    try {\n        return func();\n    }\n    finally {\n        allowStateChangesEnd(prev);\n    }\n}\nexports._allowStateChanges = allowStateChanges;\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar _Symbol$toPrimitive;\nvar CREATE = \"create\";\n_Symbol$toPrimitive = Symbol.toPrimitive;\nvar ObservableValue = /*#__PURE__*/ function (_Atom) {\n    _inheritsLoose(ObservableValue, _Atom);\n    function ObservableValue(value, enhancer, name_, notifySpy, equals) {\n        var _this;\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableValue@\" + getNextId() : undefined;\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        if (equals === void 0) {\n            equals = comparer[\"default\"];\n        }\n        _this = _Atom.call(this, name_) || this;\n        _this.enhancer = void 0;\n        _this.name_ = void 0;\n        _this.equals = void 0;\n        _this.hasUnreportedChange_ = false;\n        _this.interceptors_ = void 0;\n        _this.changeListeners_ = void 0;\n        _this.value_ = void 0;\n        _this.dehancer = void 0;\n        _this.enhancer = enhancer;\n        _this.name_ = name_;\n        _this.equals = equals;\n        _this.value_ = enhancer(value, undefined, name_);\n        if ( true && notifySpy && isSpyEnabled()) {\n            // only notify spy if this is a stand-alone observable\n            spyReport({\n                type: CREATE,\n                object: _assertThisInitialized(_this),\n                observableKind: \"value\",\n                debugObjectName: _this.name_,\n                newValue: \"\" + _this.value_\n            });\n        }\n        return _this;\n    }\n    var _proto = ObservableValue.prototype;\n    _proto.dehanceValue = function dehanceValue(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.set = function set(newValue) {\n        var oldValue = this.value_;\n        newValue = this.prepareNewValue_(newValue);\n        if (newValue !== globalState.UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if ( true && notifySpy) {\n                spyReportStart({\n                    type: UPDATE,\n                    object: this,\n                    observableKind: \"value\",\n                    debugObjectName: this.name_,\n                    newValue: newValue,\n                    oldValue: oldValue\n                });\n            }\n            this.setNewValue_(newValue);\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n    };\n    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this,\n                type: UPDATE,\n                newValue: newValue\n            });\n            if (!change) {\n                return globalState.UNCHANGED;\n            }\n            newValue = change.newValue;\n        }\n        // apply modifier\n        newValue = this.enhancer(newValue, this.value_, this.name_);\n        return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;\n    };\n    _proto.setNewValue_ = function setNewValue_(newValue) {\n        var oldValue = this.value_;\n        this.value_ = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: UPDATE,\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    _proto.get = function get() {\n        this.reportObserved();\n        return this.dehanceValue(this.value_);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if (fireImmediately) {\n            listener({\n                observableKind: \"value\",\n                debugObjectName: this.name_,\n                object: this,\n                type: UPDATE,\n                newValue: this.value_,\n                oldValue: undefined\n            });\n        }\n        return registerListener(this, listener);\n    };\n    _proto.raw = function raw() {\n        // used by MST ot get undehanced value\n        return this.value_;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.get();\n    };\n    _proto.toString = function toString() {\n        return this.name_ + \"[\" + this.value_ + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n        return toPrimitive(this.get());\n    };\n    _proto[_Symbol$toPrimitive] = function () {\n        return this.valueOf();\n    };\n    return ObservableValue;\n}(Atom);\nvar isObservableValue = /*#__PURE__*/ createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nvar _Symbol$toPrimitive$1;\n/**\n * A node in the state dependency root that observes other nodes, and can be observed itself.\n *\n * ComputedValue will remember the result of the computation for the duration of the batch, or\n * while being observed.\n *\n * During this time it will recompute only when one of its direct dependencies changed,\n * but only when it is being accessed with `ComputedValue.get()`.\n *\n * Implementation description:\n * 1. First time it's being accessed it will compute and remember result\n *    give back remembered result until 2. happens\n * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.\n * 3. When it's being accessed, recompute if any shallow dependency changed.\n *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.\n *    go to step 2. either way\n *\n * If at any point it's outside batch and it isn't observed: reset everything and go to 1.\n */\n_Symbol$toPrimitive$1 = Symbol.toPrimitive;\nvar ComputedValue = /*#__PURE__*/ function () {\n    // nodes we are looking at. Our value depends on these nodes\n    // during tracking it's an array with new observed observers\n    // to check for cycles\n    // N.B: unminified as it is used by MST\n    /**\n     * Create a new computed value based on a function expression.\n     *\n     * The `name` property is for debug purposes only.\n     *\n     * The `equals` property specifies the comparer function to use to determine if a newly produced\n     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`\n     * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.\n     * Structural comparison can be convenient if you always produce a new aggregated object and\n     * don't want to notify observers if it is structurally the same.\n     * This is useful for working with vectors, mouse coordinates etc.\n     */\n    function ComputedValue(options) {\n        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n        this.observing_ = [];\n        this.newObserving_ = null;\n        this.isBeingObserved_ = false;\n        this.isPendingUnobservation_ = false;\n        this.observers_ = new Set();\n        this.diffValue_ = 0;\n        this.runId_ = 0;\n        this.lastAccessedBy_ = 0;\n        this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n        this.unboundDepsCount_ = 0;\n        this.value_ = new CaughtException(null);\n        this.name_ = void 0;\n        this.triggeredBy_ = void 0;\n        this.isComputing_ = false;\n        this.isRunningSetter_ = false;\n        this.derivation = void 0;\n        this.setter_ = void 0;\n        this.isTracing_ = TraceMode.NONE;\n        this.scope_ = void 0;\n        this.equals_ = void 0;\n        this.requiresReaction_ = void 0;\n        this.keepAlive_ = void 0;\n        this.onBOL = void 0;\n        this.onBUOL = void 0;\n        if (!options.get) {\n            die(31);\n        }\n        this.derivation = options.get;\n        this.name_ = options.name || ( true ? \"ComputedValue@\" + getNextId() : undefined);\n        if (options.set) {\n            this.setter_ = createAction( true ? this.name_ + \"-setter\" : undefined, options.set);\n        }\n        this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer[\"default\"]);\n        this.scope_ = options.context;\n        this.requiresReaction_ = options.requiresReaction;\n        this.keepAlive_ = !!options.keepAlive;\n    }\n    var _proto = ComputedValue.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n        propagateMaybeChanged(this);\n    };\n    _proto.onBO = function onBO() {\n        if (this.onBOL) {\n            this.onBOL.forEach(function (listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.onBUO = function onBUO() {\n        if (this.onBUOL) {\n            this.onBUOL.forEach(function (listener) {\n                return listener();\n            });\n        }\n    };\n    _proto.get = function get() {\n        if (this.isComputing_) {\n            die(32, this.name_, this.derivation);\n        }\n        if (globalState.inBatch === 0 &&\n            // !globalState.trackingDerivatpion &&\n            this.observers_.size === 0 && !this.keepAlive_) {\n            if (shouldCompute(this)) {\n                this.warnAboutUntrackedRead_();\n                startBatch(); // See perf test 'computed memoization'\n                this.value_ = this.computeValue_(false);\n                endBatch();\n            }\n        }\n        else {\n            reportObserved(this);\n            if (shouldCompute(this)) {\n                var prevTrackingContext = globalState.trackingContext;\n                if (this.keepAlive_ && !prevTrackingContext) {\n                    globalState.trackingContext = this;\n                }\n                if (this.trackAndCompute()) {\n                    propagateChangeConfirmed(this);\n                }\n                globalState.trackingContext = prevTrackingContext;\n            }\n        }\n        var result = this.value_;\n        if (isCaughtException(result)) {\n            throw result.cause;\n        }\n        return result;\n    };\n    _proto.set = function set(value) {\n        if (this.setter_) {\n            if (this.isRunningSetter_) {\n                die(33, this.name_);\n            }\n            this.isRunningSetter_ = true;\n            try {\n                this.setter_.call(this.scope_, value);\n            }\n            finally {\n                this.isRunningSetter_ = false;\n            }\n        }\n        else {\n            die(34, this.name_);\n        }\n    };\n    _proto.trackAndCompute = function trackAndCompute() {\n        // N.B: unminified as it is used by MST\n        var oldValue = this.value_;\n        var wasSuspended = /* see #1208 */ this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;\n        var newValue = this.computeValue_(true);\n        var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);\n        if (changed) {\n            this.value_ = newValue;\n            if ( true && isSpyEnabled()) {\n                spyReport({\n                    observableKind: \"computed\",\n                    debugObjectName: this.name_,\n                    object: this.scope_,\n                    type: \"update\",\n                    oldValue: oldValue,\n                    newValue: newValue\n                });\n            }\n        }\n        return changed;\n    };\n    _proto.computeValue_ = function computeValue_(track) {\n        this.isComputing_ = true;\n        // don't allow state changes during computation\n        var prev = allowStateChangesStart(false);\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope_);\n        }\n        else {\n            if (globalState.disableErrorBoundaries === true) {\n                res = this.derivation.call(this.scope_);\n            }\n            else {\n                try {\n                    res = this.derivation.call(this.scope_);\n                }\n                catch (e) {\n                    res = new CaughtException(e);\n                }\n            }\n        }\n        allowStateChangesEnd(prev);\n        this.isComputing_ = false;\n        return res;\n    };\n    _proto.suspend_ = function suspend_() {\n        if (!this.keepAlive_) {\n            clearObserving(this);\n            this.value_ = undefined; // don't hold on to computed value!\n            if ( true && this.isTracing_ !== TraceMode.NONE) {\n                console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' was suspended and it will recompute on the next access.\");\n            }\n        }\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    observableKind: \"computed\",\n                    debugObjectName: _this.name_,\n                    type: UPDATE,\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {\n        if (false) {}\n        if (this.isTracing_ !== TraceMode.NONE) {\n            console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n        }\n        if (typeof this.requiresReaction_ === \"boolean\" ? this.requiresReaction_ : globalState.computedRequiresReaction) {\n            console.warn(\"[mobx] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n        }\n    };\n    _proto.toString = function toString() {\n        return this.name_ + \"[\" + this.derivation.toString() + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n        return toPrimitive(this.get());\n    };\n    _proto[_Symbol$toPrimitive$1] = function () {\n        return this.valueOf();\n    };\n    return ComputedValue;\n}();\nvar isComputedValue = /*#__PURE__*/ createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState_;\n(function (IDerivationState_) {\n    // before being run or (outside batch and not being observed)\n    // at this point derivation is not holding any data about dependency tree\n    IDerivationState_[IDerivationState_[\"NOT_TRACKING_\"] = -1] = \"NOT_TRACKING_\";\n    // no shallow dependency changed since last computation\n    // won't recalculate derivation\n    // this is what makes mobx fast\n    IDerivationState_[IDerivationState_[\"UP_TO_DATE_\"] = 0] = \"UP_TO_DATE_\";\n    // some deep dependency changed, but don't know if shallow dependency changed\n    // will require to check first if UP_TO_DATE or POSSIBLY_STALE\n    // currently only ComputedValue will propagate POSSIBLY_STALE\n    //\n    // having this state is second big optimization:\n    // don't have to recompute on every dependency change, but only when it's needed\n    IDerivationState_[IDerivationState_[\"POSSIBLY_STALE_\"] = 1] = \"POSSIBLY_STALE_\";\n    // A shallow dependency has changed since last computation and the derivation\n    // will need to recompute when it's needed next.\n    IDerivationState_[IDerivationState_[\"STALE_\"] = 2] = \"STALE_\";\n})(IDerivationState_ || (IDerivationState_ = {}));\nvar TraceMode;\n(function (TraceMode) {\n    TraceMode[TraceMode[\"NONE\"] = 0] = \"NONE\";\n    TraceMode[TraceMode[\"LOG\"] = 1] = \"LOG\";\n    TraceMode[TraceMode[\"BREAK\"] = 2] = \"BREAK\";\n})(TraceMode || (TraceMode = {}));\nvar CaughtException = function CaughtException(cause) {\n    this.cause = void 0;\n    this.cause = cause;\n    // Empty\n};\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\n/**\n * Finds out whether any dependency of the derivation has actually changed.\n * If dependenciesState is 1 then it will recalculate dependencies,\n * if any dependency changed it will propagate it by changing dependenciesState to 2.\n *\n * By iterating over the dependencies in the same order that they were reported and\n * stopping on the first change, all the recalculations are only called for ComputedValues\n * that will be tracked by derivation. That is because we assume that if the first x\n * dependencies of the derivation doesn't change then the derivation should run the same way\n * up until accessing x-th dependency.\n */\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState_) {\n        case IDerivationState_.UP_TO_DATE_:\n            return false;\n        case IDerivationState_.NOT_TRACKING_:\n        case IDerivationState_.STALE_:\n            return true;\n        case IDerivationState_.POSSIBLY_STALE_:\n            {\n                // state propagation can occur outside of action/reactive context #2195\n                var prevAllowStateReads = allowStateReadsStart(true);\n                var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.\n                var obs = derivation.observing_, l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        if (globalState.disableErrorBoundaries) {\n                            obj.get();\n                        }\n                        else {\n                            try {\n                                obj.get();\n                            }\n                            catch (e) {\n                                // we are not interested in the value *or* exception at this moment, but if there is one, notify all\n                                untrackedEnd(prevUntracked);\n                                allowStateReadsEnd(prevAllowStateReads);\n                                return true;\n                            }\n                        }\n                        // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.\n                        // and `derivation` is an observer of `obj`\n                        // invariantShouldCompute(derivation)\n                        if (derivation.dependenciesState_ === IDerivationState_.STALE_) {\n                            untrackedEnd(prevUntracked);\n                            allowStateReadsEnd(prevAllowStateReads);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                allowStateReadsEnd(prevAllowStateReads);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null; // filter out actions inside computations\n}\nexports._isComputingDerivation = isComputingDerivation;\nfunction checkIfStateModificationsAreAllowed(atom) {\n    if (false) {}\n    var hasObservers = atom.observers_.size > 0;\n    // Should not be possible to change observed state outside strict mode, except during initialization, see #563\n    if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === \"always\")) {\n        console.warn(\"[MobX] \" + (globalState.enforceActions ? \"Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: \" : \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: \") + atom.name_);\n    }\n}\nfunction checkIfStateReadsAreAllowed(observable) {\n    if ( true && !globalState.allowStateReads && globalState.observableRequiresReaction) {\n        console.warn(\"[mobx] Observable '\" + observable.name_ + \"' being read outside a reactive context.\");\n    }\n}\n/**\n * Executes the provided function `f` and tracks which observables are being accessed.\n * The tracking information is stored on the `derivation` object and the derivation is registered\n * as observer of any of the accessed observables.\n */\nfunction trackDerivedFunction(derivation, f, context) {\n    var prevAllowStateReads = allowStateReadsStart(true);\n    // pre allocate array allocation + room for variation in deps\n    // array will be trimmed by bindDependencies\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving_ = new Array(derivation.observing_.length + 100);\n    derivation.unboundDepsCount_ = 0;\n    derivation.runId_ = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    globalState.inBatch++;\n    var result;\n    if (globalState.disableErrorBoundaries === true) {\n        result = f.call(context);\n    }\n    else {\n        try {\n            result = f.call(context);\n        }\n        catch (e) {\n            result = new CaughtException(e);\n        }\n    }\n    globalState.inBatch--;\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    warnAboutDerivationWithoutDependencies(derivation);\n    allowStateReadsEnd(prevAllowStateReads);\n    return result;\n}\nfunction warnAboutDerivationWithoutDependencies(derivation) {\n    if (false) {}\n    if (derivation.observing_.length !== 0) {\n        return;\n    }\n    if (typeof derivation.requiresObservable_ === \"boolean\" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {\n        console.warn(\"[mobx] Derivation '\" + derivation.name_ + \"' is created/updated without reading any observable value.\");\n    }\n}\n/**\n * diffs newObserving with observing.\n * update observing to be newObserving with unique observables\n * notify observers that become observed/unobserved\n */\nfunction bindDependencies(derivation) {\n    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\");\n    var prevObserving = derivation.observing_;\n    var observing = derivation.observing_ = derivation.newObserving_;\n    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;\n    // Go through all new observables and check diffValue: (this list can contain duplicates):\n    //   0: first occurrence, change to 1 and keep it\n    //   1: extra occurrence, drop it\n    var i0 = 0, l = derivation.unboundDepsCount_;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue_ === 0) {\n            dep.diffValue_ = 1;\n            if (i0 !== i) {\n                observing[i0] = dep;\n            }\n            i0++;\n        }\n        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,\n        // not hitting the condition\n        if (dep.dependenciesState_ > lowestNewObservingDerivationState) {\n            lowestNewObservingDerivationState = dep.dependenciesState_;\n        }\n    }\n    observing.length = i0;\n    derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)\n    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)\n    //   0: it's not in new observables, unobserve it\n    //   1: it keeps being observed, don't want to notify it. change to 0\n    l = prevObserving.length;\n    while (l--) {\n        var _dep = prevObserving[l];\n        if (_dep.diffValue_ === 0) {\n            removeObserver(_dep, derivation);\n        }\n        _dep.diffValue_ = 0;\n    }\n    // Go through all new observables and check diffValue: (now it should be unique)\n    //   0: it was set to 0 in last loop. don't need to do anything.\n    //   1: it wasn't observed, let's observe it. set back to 0\n    while (i0--) {\n        var _dep2 = observing[i0];\n        if (_dep2.diffValue_ === 1) {\n            _dep2.diffValue_ = 0;\n            addObserver(_dep2, derivation);\n        }\n    }\n    // Some new observed derivations may become stale during this derivation computation\n    // so they have had no chance to propagate staleness (#916)\n    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {\n        derivation.dependenciesState_ = lowestNewObservingDerivationState;\n        derivation.onBecomeStale_();\n    }\n}\nfunction clearObserving(derivation) {\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR clearObserving should be called only inside batch\");\n    var obs = derivation.observing_;\n    derivation.observing_ = [];\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }\n    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    try {\n        return action();\n    }\n    finally {\n        untrackedEnd(prev);\n    }\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction allowStateReadsStart(allowStateReads) {\n    var prev = globalState.allowStateReads;\n    globalState.allowStateReads = allowStateReads;\n    return prev;\n}\nexports._allowStateReadsStart = allowStateReadsStart;\nfunction allowStateReadsEnd(prev) {\n    globalState.allowStateReads = prev;\n}\nexports._allowStateReadsEnd = allowStateReadsEnd;\n/**\n * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0\n *\n */\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n        return;\n    }\n    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;\n    var obs = derivation.observing_;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n    }\n}\n/**\n * These values will persist if global state is reset\n */\nvar persistentKeys = [\"mobxGuid\", \"spyListeners\", \"enforceActions\", \"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"allowStateReads\", \"disableErrorBoundaries\", \"runId\", \"UNCHANGED\", \"useProxies\"];\nvar MobXGlobals = function MobXGlobals() {\n    this.version = 6;\n    this.UNCHANGED = {};\n    this.trackingDerivation = null;\n    this.trackingContext = null;\n    this.runId = 0;\n    this.mobxGuid = 0;\n    this.inBatch = 0;\n    this.pendingUnobservations = [];\n    this.pendingReactions = [];\n    this.isRunningReactions = false;\n    this.allowStateChanges = false;\n    this.allowStateReads = true;\n    this.enforceActions = true;\n    this.spyListeners = [];\n    this.globalReactionErrorHandlers = [];\n    this.computedRequiresReaction = false;\n    this.reactionRequiresObservable = false;\n    this.observableRequiresReaction = false;\n    this.disableErrorBoundaries = false;\n    this.suppressReactionErrors = false;\n    this.useProxies = true;\n    this.verifyProxies = false;\n    this.safeDescriptors = true;\n};\nvar canMergeGlobalState = true;\nvar isolateCalled = false;\nvar globalState = /*#__PURE__*/ function () {\n    var global = /*#__PURE__*/ getGlobal();\n    if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) {\n        canMergeGlobalState = false;\n    }\n    if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) {\n        canMergeGlobalState = false;\n    }\n    if (!canMergeGlobalState) {\n        // Because this is a IIFE we need to let isolateCalled a chance to change\n        // so we run it after the event loop completed at least 1 iteration\n        setTimeout(function () {\n            if (!isolateCalled) {\n                die(35);\n            }\n        }, 1);\n        return new MobXGlobals();\n    }\n    else if (global.__mobxGlobals) {\n        global.__mobxInstanceCount += 1;\n        if (!global.__mobxGlobals.UNCHANGED) {\n            global.__mobxGlobals.UNCHANGED = {};\n        } // make merge backward compatible\n        return global.__mobxGlobals;\n    }\n    else {\n        global.__mobxInstanceCount = 1;\n        return global.__mobxGlobals = /*#__PURE__*/ new MobXGlobals();\n    }\n}();\nfunction isolateGlobalState() {\n    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {\n        die(36);\n    }\n    isolateCalled = true;\n    if (canMergeGlobalState) {\n        var global = getGlobal();\n        if (--global.__mobxInstanceCount === 0) {\n            global.__mobxGlobals = undefined;\n        }\n        globalState = new MobXGlobals();\n    }\n}\nfunction getGlobalState() {\n    return globalState;\n}\nexports._getGlobalState = getGlobalState;\n/**\n * For testing purposes only; this will break the internal state of existing observables,\n * but can be used to get back at a stable state after throwing errors\n */\nfunction resetGlobalState() {\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) {\n            globalState[key] = defaultGlobals[key];\n        }\n    }\n    globalState.allowStateChanges = !globalState.enforceActions;\n}\nexports._resetGlobalState = resetGlobalState;\nfunction hasObservers(observable) {\n    return observable.observers_ && observable.observers_.size > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers_;\n}\n// function invariantObservers(observable: IObservable) {\n//     const list = observable.observers\n//     const map = observable.observersIndexes\n//     const l = list.length\n//     for (let i = 0; i < l; i++) {\n//         const id = list[i].__mapid\n//         if (i) {\n//             invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\") // for performance\n//         } else {\n//             invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldn't be held in map.\") // for performance\n//         }\n//     }\n//     invariant(\n//         list.length === 0 || Object.keys(map).length === list.length - 1,\n//         \"INTERNAL ERROR there is no junk in map\"\n//     )\n// }\nfunction addObserver(observable, node) {\n    // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\");\n    // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\");\n    // invariantObservers(observable);\n    observable.observers_.add(node);\n    if (observable.lowestObserverState_ > node.dependenciesState_) {\n        observable.lowestObserverState_ = node.dependenciesState_;\n    }\n    // invariantObservers(observable);\n    // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didn't add node\");\n}\nfunction removeObserver(observable, node) {\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\");\n    // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\");\n    // invariantObservers(observable);\n    observable.observers_[\"delete\"](node);\n    if (observable.observers_.size === 0) {\n        // deleting last observer\n        queueForUnobservation(observable);\n    }\n    // invariantObservers(observable);\n    // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\");\n}\nfunction queueForUnobservation(observable) {\n    if (observable.isPendingUnobservation_ === false) {\n        // invariant(observable._observers.length === 0, \"INTERNAL ERROR, should only queue for unobservation unobserved observables\");\n        observable.isPendingUnobservation_ = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\n/**\n * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.\n * During a batch `onBecomeUnobserved` will be called at most once per observable.\n * Avoids unnecessary recalculations.\n */\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        // the batch is actually about to finish, all unobserving should happen here.\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable = list[i];\n            observable.isPendingUnobservation_ = false;\n            if (observable.observers_.size === 0) {\n                if (observable.isBeingObserved_) {\n                    // if this observable had reactive observers, trigger the hooks\n                    observable.isBeingObserved_ = false;\n                    observable.onBUO();\n                }\n                if (observable instanceof ComputedValue) {\n                    // computed values are automatically teared down when the last observer leaves\n                    // this process happens recursively, this computed might be the last observabe of another, etc..\n                    observable.suspend_();\n                }\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    checkIfStateReadsAreAllowed(observable);\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        /**\n         * Simple optimization, give each derivation run an unique id (runId)\n         * Check if last time this observable was accessed the same runId is used\n         * if this is the case, the relation is already known\n         */\n        if (derivation.runId_ !== observable.lastAccessedBy_) {\n            observable.lastAccessedBy_ = derivation.runId_;\n            // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...\n            derivation.newObserving_[derivation.unboundDepsCount_++] = observable;\n            if (!observable.isBeingObserved_ && globalState.trackingContext) {\n                observable.isBeingObserved_ = true;\n                observable.onBO();\n            }\n        }\n        return observable.isBeingObserved_;\n    }\n    else if (observable.observers_.size === 0 && globalState.inBatch > 0) {\n        queueForUnobservation(observable);\n    }\n    return false;\n}\n// function invariantLOS(observable: IObservable, msg: string) {\n//     // it's expensive so better not run it in produciton. but temporarily helpful for testing\n//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)\n//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`\n//     throw new Error(\n//         \"lowestObserverState is wrong for \" +\n//             msg +\n//             \" because \" +\n//             min +\n//             \" < \" +\n//             observable.lowestObserverState\n//     )\n// }\n/**\n * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly\n * It will propagate changes to observers from previous run\n * It's hard or maybe impossible (with reasonable perf) to get it right with current approach\n * Hopefully self reruning autoruns aren't a feature people should depend on\n * Also most basic use cases should be ok\n */\n// Called by Atom when its value changes\nfunction propagateChanged(observable) {\n    // invariantLOS(observable, \"changed start\");\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    // Ideally we use for..of here, but the downcompiled version is really slow...\n    observable.observers_.forEach(function (d) {\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n            if ( true && d.isTracing_ !== TraceMode.NONE) {\n                logTraceInfo(d, observable);\n            }\n            d.onBecomeStale_();\n        }\n        d.dependenciesState_ = IDerivationState_.STALE_;\n    });\n    // invariantLOS(observable, \"changed end\");\n}\n// Called by ComputedValue when it recalculate and its value changed\nfunction propagateChangeConfirmed(observable) {\n    // invariantLOS(observable, \"confirmed start\");\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    observable.observers_.forEach(function (d) {\n        if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {\n            d.dependenciesState_ = IDerivationState_.STALE_;\n            if ( true && d.isTracing_ !== TraceMode.NONE) {\n                logTraceInfo(d, observable);\n            }\n        }\n        else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.\n        ) {\n            observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n        }\n    });\n    // invariantLOS(observable, \"confirmed end\");\n}\n// Used by computed when its dependency changed, but we don't wan't to immediately recompute.\nfunction propagateMaybeChanged(observable) {\n    // invariantLOS(observable, \"maybe start\");\n    if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {\n        return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;\n    observable.observers_.forEach(function (d) {\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n            d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;\n            d.onBecomeStale_();\n        }\n    });\n    // invariantLOS(observable, \"maybe end\");\n}\nfunction logTraceInfo(derivation, observable) {\n    console.log(\"[mobx.trace] '\" + derivation.name_ + \"' is invalidated due to a change in: '\" + observable.name_ + \"'\");\n    if (derivation.isTracing_ === TraceMode.BREAK) {\n        var lines = [];\n        printDepTree(getDependencyTree(derivation), lines, 1);\n        // prettier-ignore\n        new Function(\"debugger;\\n/*\\nTracing '\" + derivation.name_ + \"'\\n\\nYou are entering this break point because derivation '\" + derivation.name_ + \"' is being traced and '\" + observable.name_ + \"' is now forcing it to update.\\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\\n\\n\" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\\//g, \"/\") : \"\") + \"\\n\\nThe dependencies for this derivation are:\\n\\n\" + lines.join(\"\\n\") + \"\\n*/\\n    \")();\n    }\n}\nfunction printDepTree(tree, lines, depth) {\n    if (lines.length >= 1000) {\n        lines.push(\"(and many more)\");\n        return;\n    }\n    lines.push(\"\" + \"\\t\".repeat(depth - 1) + tree.name);\n    if (tree.dependencies) {\n        tree.dependencies.forEach(function (child) {\n            return printDepTree(child, lines, depth + 1);\n        });\n    }\n}\nvar Reaction = /*#__PURE__*/ function () {\n    // nodes we are looking at. Our value depends on these nodes\n    function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {\n        if (name_ === void 0) {\n            name_ =  true ? \"Reaction@\" + getNextId() : undefined;\n        }\n        this.name_ = void 0;\n        this.onInvalidate_ = void 0;\n        this.errorHandler_ = void 0;\n        this.requiresObservable_ = void 0;\n        this.observing_ = [];\n        this.newObserving_ = [];\n        this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n        this.diffValue_ = 0;\n        this.runId_ = 0;\n        this.unboundDepsCount_ = 0;\n        this.isDisposed_ = false;\n        this.isScheduled_ = false;\n        this.isTrackPending_ = false;\n        this.isRunning_ = false;\n        this.isTracing_ = TraceMode.NONE;\n        this.name_ = name_;\n        this.onInvalidate_ = onInvalidate_;\n        this.errorHandler_ = errorHandler_;\n        this.requiresObservable_ = requiresObservable_;\n    }\n    var _proto = Reaction.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n        this.schedule_();\n    };\n    _proto.schedule_ = function schedule_() {\n        if (!this.isScheduled_) {\n            this.isScheduled_ = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    _proto.isScheduled = function isScheduled() {\n        return this.isScheduled_;\n    };\n    _proto.runReaction_ = function runReaction_() {\n        if (!this.isDisposed_) {\n            startBatch();\n            this.isScheduled_ = false;\n            var prev = globalState.trackingContext;\n            globalState.trackingContext = this;\n            if (shouldCompute(this)) {\n                this.isTrackPending_ = true;\n                try {\n                    this.onInvalidate_();\n                    if ( true && this.isTrackPending_ && isSpyEnabled()) {\n                        // onInvalidate didn't trigger track right away..\n                        spyReport({\n                            name: this.name_,\n                            type: \"scheduled-reaction\"\n                        });\n                    }\n                }\n                catch (e) {\n                    this.reportExceptionInDerivation_(e);\n                }\n            }\n            globalState.trackingContext = prev;\n            endBatch();\n        }\n    };\n    _proto.track = function track(fn) {\n        if (this.isDisposed_) {\n            return;\n            // console.warn(\"Reaction already disposed\") // Note: Not a warning / error in mobx 4 either\n        }\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if ( true && notify) {\n            startTime = Date.now();\n            spyReportStart({\n                name: this.name_,\n                type: \"reaction\"\n            });\n        }\n        this.isRunning_ = true;\n        var prevReaction = globalState.trackingContext; // reactions could create reactions...\n        globalState.trackingContext = this;\n        var result = trackDerivedFunction(this, fn, undefined);\n        globalState.trackingContext = prevReaction;\n        this.isRunning_ = false;\n        this.isTrackPending_ = false;\n        if (this.isDisposed_) {\n            // disposed during last run. Clean up everything that was bound after the dispose call.\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) {\n            this.reportExceptionInDerivation_(result.cause);\n        }\n        if ( true && notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {\n        var _this = this;\n        if (this.errorHandler_) {\n            this.errorHandler_(error, this);\n            return;\n        }\n        if (globalState.disableErrorBoundaries) {\n            throw error;\n        }\n        var message =  true ? \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this + \"'\" : undefined;\n        if (!globalState.suppressReactionErrors) {\n            console.error(message, error);\n            /** If debugging brought you here, please, read the above message :-). Tnx! */\n        }\n        else if (true) {\n            console.warn(\"[mobx] (error in reaction '\" + this.name_ + \"' suppressed, fix error of causing action below)\");\n        } // prettier-ignore\n        if ( true && isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                name: this.name_,\n                message: message,\n                error: \"\" + error\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    _proto.dispose = function dispose() {\n        if (!this.isDisposed_) {\n            this.isDisposed_ = true;\n            if (!this.isRunning_) {\n                // if disposed while running, clean up later. Maybe not optimal, but rare case\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    _proto.getDisposer_ = function getDisposer_(abortSignal) {\n        var _this2 = this;\n        var dispose = function dispose() {\n            _this2.dispose();\n            abortSignal == null ? void 0 : abortSignal.removeEventListener == null ? void 0 : abortSignal.removeEventListener(\"abort\", dispose);\n        };\n        abortSignal == null ? void 0 : abortSignal.addEventListener == null ? void 0 : abortSignal.addEventListener(\"abort\", dispose);\n        dispose[$mobx] = this;\n        return dispose;\n    };\n    _proto.toString = function toString() {\n        return \"Reaction[\" + this.name_ + \"]\";\n    };\n    _proto.trace = function trace$1(enterBreakPoint) {\n        if (enterBreakPoint === void 0) {\n            enterBreakPoint = false;\n        }\n        trace(this, enterBreakPoint);\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) {\n            globalState.globalReactionErrorHandlers.splice(idx, 1);\n        }\n    };\n}\nexports.onReactionError = onReactionError;\n/**\n * Magic number alert!\n * Defines within how many times a reaction is allowed to re-trigger itself\n * until it is assumed that this is gonna be a never ending loop...\n */\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    // Trampolining, if runReactions are already running, new reactions will be picked up\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) {\n        return;\n    }\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    // While running reactions, new reactions might be triggered.\n    // Hence we work with two variables and check whether\n    // we converge to no remaining reactions after a while.\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error( true ? \"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]) : undefined);\n            allReactions.splice(0); // clear reactions\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction_();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = /*#__PURE__*/ createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return  true && !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (false) {} // dead code elimination can do the rest\n    if (!globalState.spyListeners.length) {\n        return;\n    }\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    if (false) {}\n    var change = _extends({}, event, {\n        spyReportStart: true\n    });\n    spyReport(change);\n}\nvar END_EVENT = {\n    type: \"report-end\",\n    spyReportEnd: true\n};\nfunction spyReportEnd(change) {\n    if (false) {}\n    if (change) {\n        spyReport(_extends({}, change, {\n            type: \"report-end\",\n            spyReportEnd: true\n        }));\n    }\n    else {\n        spyReport(END_EVENT);\n    }\n}\nfunction spy(listener) {\n    if (false) {}\n    else {\n        globalState.spyListeners.push(listener);\n        return once(function () {\n            globalState.spyListeners = globalState.spyListeners.filter(function (l) {\n                return l !== listener;\n            });\n        });\n    }\n}\nexports.spy = spy;\nvar ACTION = \"action\";\nvar ACTION_BOUND = \"action.bound\";\nvar AUTOACTION = \"autoAction\";\nvar AUTOACTION_BOUND = \"autoAction.bound\";\nvar DEFAULT_ACTION_NAME = \"<unnamed action>\";\nvar actionAnnotation = /*#__PURE__*/ createActionAnnotation(ACTION);\nvar actionBoundAnnotation = /*#__PURE__*/ createActionAnnotation(ACTION_BOUND, {\n    bound: true\n});\nvar autoActionAnnotation = /*#__PURE__*/ createActionAnnotation(AUTOACTION, {\n    autoAction: true\n});\nvar autoActionBoundAnnotation = /*#__PURE__*/ createActionAnnotation(AUTOACTION_BOUND, {\n    autoAction: true,\n    bound: true\n});\nfunction createActionFactory(autoAction) {\n    var res = function action(arg1, arg2) {\n        // action(fn() {})\n        if (isFunction(arg1)) {\n            return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);\n        }\n        // action(\"name\", fn() {})\n        if (isFunction(arg2)) {\n            return createAction(arg1, arg2, autoAction);\n        }\n        // @action (2022.3 Decorators)\n        if (is20223Decorator(arg2)) {\n            return (autoAction ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);\n        }\n        // @action\n        if (isStringish(arg2)) {\n            return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);\n        }\n        // action(\"name\") & @action(\"name\")\n        if (isStringish(arg1)) {\n            return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {\n                name: arg1,\n                autoAction: autoAction\n            }));\n        }\n        if (true) {\n            die(\"Invalid arguments for `action`\");\n        }\n    };\n    return res;\n}\nvar action = /*#__PURE__*/ createActionFactory(false);\nexports.action = action;\nObject.assign(action, actionAnnotation);\nvar autoAction = /*#__PURE__*/ createActionFactory(true);\nexports._autoAction = autoAction;\nObject.assign(autoAction, autoActionAnnotation);\naction.bound = /*#__PURE__*/ createDecoratorAnnotation(actionBoundAnnotation);\nautoAction.bound = /*#__PURE__*/ createDecoratorAnnotation(autoActionBoundAnnotation);\nfunction runInAction(fn) {\n    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);\n}\nexports._allowStateChangesInsideComputed = runInAction;\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return isFunction(thing) && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\n/**\n * Creates a named reactive view and keeps it alive, so that the view is always\n * updated if one of the dependencies changes, even when the view is not further used by something else.\n * @param view The reactive view\n * @returns disposer function, which can be used to stop the view from being updated in the future.\n */\nfunction autorun(view, opts) {\n    var _opts$name, _opts, _opts2, _opts2$signal, _opts3;\n    if (opts === void 0) {\n        opts = EMPTY_OBJECT;\n    }\n    if (true) {\n        if (!isFunction(view)) {\n            die(\"Autorun expects a function as first argument\");\n        }\n        if (isAction(view)) {\n            die(\"Autorun does not accept actions since actions are untrackable\");\n        }\n    }\n    var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  true ? view.name || \"Autorun@\" + getNextId() : undefined;\n    var runSync = !opts.scheduler && !opts.delay;\n    var reaction;\n    if (runSync) {\n        // normal autorun\n        reaction = new Reaction(name, function () {\n            this.track(reactionRunner);\n        }, opts.onError, opts.requiresObservable);\n    }\n    else {\n        var scheduler = createSchedulerFromOptions(opts);\n        // debounced autorun\n        var isScheduled = false;\n        reaction = new Reaction(name, function () {\n            if (!isScheduled) {\n                isScheduled = true;\n                scheduler(function () {\n                    isScheduled = false;\n                    if (!reaction.isDisposed_) {\n                        reaction.track(reactionRunner);\n                    }\n                });\n            }\n        }, opts.onError, opts.requiresObservable);\n    }\n    function reactionRunner() {\n        view(reaction);\n    }\n    if (!((_opts2 = opts) != null && (_opts2$signal = _opts2.signal) != null && _opts2$signal.aborted)) {\n        reaction.schedule_();\n    }\n    return reaction.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);\n}\nexports.autorun = autorun;\nvar run = function run(f) {\n    return f();\n};\nfunction createSchedulerFromOptions(opts) {\n    return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {\n        return setTimeout(f, opts.delay);\n    } : run;\n}\nfunction reaction(expression, effect, opts) {\n    var _opts$name2, _opts4, _opts4$signal, _opts5;\n    if (opts === void 0) {\n        opts = EMPTY_OBJECT;\n    }\n    if (true) {\n        if (!isFunction(expression) || !isFunction(effect)) {\n            die(\"First and second argument to reaction should be functions\");\n        }\n        if (!isPlainObject(opts)) {\n            die(\"Third argument of reactions should be an object\");\n        }\n    }\n    var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  true ? \"Reaction@\" + getNextId() : undefined;\n    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);\n    var runSync = !opts.scheduler && !opts.delay;\n    var scheduler = createSchedulerFromOptions(opts);\n    var firstTime = true;\n    var isScheduled = false;\n    var value;\n    var oldValue;\n    var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer[\"default\"];\n    var r = new Reaction(name, function () {\n        if (firstTime || runSync) {\n            reactionRunner();\n        }\n        else if (!isScheduled) {\n            isScheduled = true;\n            scheduler(reactionRunner);\n        }\n    }, opts.onError, opts.requiresObservable);\n    function reactionRunner() {\n        isScheduled = false;\n        if (r.isDisposed_) {\n            return;\n        }\n        var changed = false;\n        r.track(function () {\n            var nextValue = allowStateChanges(false, function () {\n                return expression(r);\n            });\n            changed = firstTime || !equals(value, nextValue);\n            oldValue = value;\n            value = nextValue;\n        });\n        if (firstTime && opts.fireImmediately) {\n            effectAction(value, oldValue, r);\n        }\n        else if (!firstTime && changed) {\n            effectAction(value, oldValue, r);\n        }\n        firstTime = false;\n    }\n    if (!((_opts4 = opts) != null && (_opts4$signal = _opts4.signal) != null && _opts4$signal.aborted)) {\n        r.schedule_();\n    }\n    return r.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);\n}\nexports.reaction = reaction;\nfunction wrapErrorHandler(errorHandler, baseFn) {\n    return function () {\n        try {\n            return baseFn.apply(this, arguments);\n        }\n        catch (e) {\n            errorHandler.call(this, e);\n        }\n    };\n}\nvar ON_BECOME_OBSERVED = \"onBO\";\nvar ON_BECOME_UNOBSERVED = \"onBUO\";\nfunction onBecomeObserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);\n}\nexports.onBecomeObserved = onBecomeObserved;\nfunction onBecomeUnobserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);\n}\nexports.onBecomeUnobserved = onBecomeUnobserved;\nfunction interceptHook(hook, thing, arg2, arg3) {\n    var atom = typeof arg3 === \"function\" ? getAtom(thing, arg2) : getAtom(thing);\n    var cb = isFunction(arg3) ? arg3 : arg2;\n    var listenersKey = hook + \"L\";\n    if (atom[listenersKey]) {\n        atom[listenersKey].add(cb);\n    }\n    else {\n        atom[listenersKey] = new Set([cb]);\n    }\n    return function () {\n        var hookListeners = atom[listenersKey];\n        if (hookListeners) {\n            hookListeners[\"delete\"](cb);\n            if (hookListeners.size === 0) {\n                delete atom[listenersKey];\n            }\n        }\n    };\n}\nvar NEVER = \"never\";\nvar ALWAYS = \"always\";\nvar OBSERVED = \"observed\";\n// const IF_AVAILABLE = \"ifavailable\"\nfunction configure(options) {\n    if (options.isolateGlobalState === true) {\n        isolateGlobalState();\n    }\n    var useProxies = options.useProxies, enforceActions = options.enforceActions;\n    if (useProxies !== undefined) {\n        globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== \"undefined\";\n    }\n    if (useProxies === \"ifavailable\") {\n        globalState.verifyProxies = true;\n    }\n    if (enforceActions !== undefined) {\n        var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;\n        globalState.enforceActions = ea;\n        globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;\n    }\n    [\"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"disableErrorBoundaries\", \"safeDescriptors\"].forEach(function (key) {\n        if (key in options) {\n            globalState[key] = !!options[key];\n        }\n    });\n    globalState.allowStateReads = !globalState.observableRequiresReaction;\n    if ( true && globalState.disableErrorBoundaries === true) {\n        console.warn(\"WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.\");\n    }\n    if (options.reactionScheduler) {\n        setReactionScheduler(options.reactionScheduler);\n    }\n}\nexports.configure = configure;\nfunction extendObservable(target, properties, annotations, options) {\n    if (true) {\n        if (arguments.length > 4) {\n            die(\"'extendObservable' expected 2-4 arguments\");\n        }\n        if (typeof target !== \"object\") {\n            die(\"'extendObservable' expects an object as first argument\");\n        }\n        if (isObservableMap(target)) {\n            die(\"'extendObservable' should not be used on maps, use map.merge instead\");\n        }\n        if (!isPlainObject(properties)) {\n            die(\"'extendObservable' only accepts plain objects as second argument\");\n        }\n        if (isObservable(properties) || isObservable(annotations)) {\n            die(\"Extending an object with another observable (object) is not supported\");\n        }\n    }\n    // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)\n    var descriptors = getOwnPropertyDescriptors(properties);\n    initObservable(function () {\n        var adm = asObservableObject(target, options)[$mobx];\n        ownKeys(descriptors).forEach(function (key) {\n            adm.extend_(key, descriptors[key], \n            // must pass \"undefined\" for { key: undefined }\n            !annotations ? true : key in annotations ? annotations[key] : true);\n        });\n    });\n    return target;\n}\nexports.extendObservable = extendObservable;\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nexports.getDependencyTree = getDependencyTree;\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name_\n    };\n    if (node.observing_ && node.observing_.length > 0) {\n        result.dependencies = unique(node.observing_).map(nodeToDependencyTree);\n    }\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nexports.getObserverTree = getObserverTree;\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name_\n    };\n    if (hasObservers(node)) {\n        result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);\n    }\n    return result;\n}\nfunction unique(list) {\n    return Array.from(new Set(list));\n}\nvar generatorId = 0;\nfunction FlowCancellationError() {\n    this.message = \"FLOW_CANCELLED\";\n}\nexports.FlowCancellationError = FlowCancellationError;\nFlowCancellationError.prototype = /*#__PURE__*/ Object.create(Error.prototype);\nfunction isFlowCancellationError(error) {\n    return error instanceof FlowCancellationError;\n}\nexports.isFlowCancellationError = isFlowCancellationError;\nvar flowAnnotation = /*#__PURE__*/ createFlowAnnotation(\"flow\");\nvar flowBoundAnnotation = /*#__PURE__*/ createFlowAnnotation(\"flow.bound\", {\n    bound: true\n});\nvar flow = /*#__PURE__*/ Object.assign(function flow(arg1, arg2) {\n    // @flow (2022.3 Decorators)\n    if (is20223Decorator(arg2)) {\n        return flowAnnotation.decorate_20223_(arg1, arg2);\n    }\n    // @flow\n    if (isStringish(arg2)) {\n        return storeAnnotation(arg1, arg2, flowAnnotation);\n    }\n    // flow(fn)\n    if ( true && arguments.length !== 1) {\n        die(\"Flow expects single argument with generator function\");\n    }\n    var generator = arg1;\n    var name = generator.name || \"<unnamed flow>\";\n    // Implementation based on https://github.com/tj/co/blob/master/index.js\n    var res = function res() {\n        var ctx = this;\n        var args = arguments;\n        var runId = ++generatorId;\n        var gen = action(name + \" - runid: \" + runId + \" - init\", generator).apply(ctx, args);\n        var rejector;\n        var pendingPromise = undefined;\n        var promise = new Promise(function (resolve, reject) {\n            var stepId = 0;\n            rejector = reject;\n            function onFulfilled(res) {\n                pendingPromise = undefined;\n                var ret;\n                try {\n                    ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen.next).call(gen, res);\n                }\n                catch (e) {\n                    return reject(e);\n                }\n                next(ret);\n            }\n            function onRejected(err) {\n                pendingPromise = undefined;\n                var ret;\n                try {\n                    ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen[\"throw\"]).call(gen, err);\n                }\n                catch (e) {\n                    return reject(e);\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (isFunction(ret == null ? void 0 : ret.then)) {\n                    // an async iterator\n                    ret.then(next, reject);\n                    return;\n                }\n                if (ret.done) {\n                    return resolve(ret.value);\n                }\n                pendingPromise = Promise.resolve(ret.value);\n                return pendingPromise.then(onFulfilled, onRejected);\n            }\n            onFulfilled(undefined); // kick off the process\n        });\n        promise.cancel = action(name + \" - runid: \" + runId + \" - cancel\", function () {\n            try {\n                if (pendingPromise) {\n                    cancelPromise(pendingPromise);\n                }\n                // Finally block can return (or yield) stuff..\n                var _res = gen[\"return\"](undefined);\n                // eat anything that promise would do, it's cancelled!\n                var yieldedPromise = Promise.resolve(_res.value);\n                yieldedPromise.then(noop, noop);\n                cancelPromise(yieldedPromise); // maybe it can be cancelled :)\n                // reject our original promise\n                rejector(new FlowCancellationError());\n            }\n            catch (e) {\n                rejector(e); // there could be a throwing finally block\n            }\n        });\n        return promise;\n    };\n    res.isMobXFlow = true;\n    return res;\n}, flowAnnotation);\nexports.flow = flow;\nflow.bound = /*#__PURE__*/ createDecoratorAnnotation(flowBoundAnnotation);\nfunction cancelPromise(promise) {\n    if (isFunction(promise.cancel)) {\n        promise.cancel();\n    }\n}\nfunction flowResult(result) {\n    return result; // just tricking TypeScript :)\n}\nexports.flowResult = flowResult;\nfunction isFlow(fn) {\n    return (fn == null ? void 0 : fn.isMobXFlow) === true;\n}\nexports.isFlow = isFlow;\nfunction interceptReads(thing, propOrHandler, handler) {\n    var target;\n    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {\n        target = getAdministration(thing);\n    }\n    else if (isObservableObject(thing)) {\n        if ( true && !isStringish(propOrHandler)) {\n            return die(\"InterceptReads can only be used with a specific property, not with an object in general\");\n        }\n        target = getAdministration(thing, propOrHandler);\n    }\n    else if (true) {\n        return die(\"Expected observable map, object or array as first array\");\n    }\n    if ( true && target.dehancer !== undefined) {\n        return die(\"An intercept reader was already established\");\n    }\n    target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler;\n    return function () {\n        target.dehancer = undefined;\n    };\n}\nexports._interceptReads = interceptReads;\nfunction intercept(thing, propOrHandler, handler) {\n    if (isFunction(handler)) {\n        return interceptProperty(thing, propOrHandler, handler);\n    }\n    else {\n        return interceptInterceptable(thing, propOrHandler);\n    }\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept_(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept_(handler);\n}\nfunction _isComputed(value, property) {\n    if (property === undefined) {\n        return isComputedValue(value);\n    }\n    if (isObservableObject(value) === false) {\n        return false;\n    }\n    if (!value[$mobx].values_.has(property)) {\n        return false;\n    }\n    var atom = getAtom(value, property);\n    return isComputedValue(atom);\n}\nfunction isComputed(value) {\n    if ( true && arguments.length > 1) {\n        return die(\"isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property\");\n    }\n    return _isComputed(value);\n}\nexports.isComputed = isComputed;\nfunction isComputedProp(value, propName) {\n    if ( true && !isStringish(propName)) {\n        return die(\"isComputed expected a property name as second argument\");\n    }\n    return _isComputed(value, propName);\n}\nexports.isComputedProp = isComputedProp;\nfunction _isObservable(value, property) {\n    if (!value) {\n        return false;\n    }\n    if (property !== undefined) {\n        if ( true && (isObservableMap(value) || isObservableArray(value))) {\n            return die(\"isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n        }\n        if (isObservableObject(value)) {\n            return value[$mobx].values_.has(property);\n        }\n        return false;\n    }\n    // For first check, see #701\n    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nfunction isObservable(value) {\n    if ( true && arguments.length !== 1) {\n        die(\"isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property\");\n    }\n    return _isObservable(value);\n}\nexports.isObservable = isObservable;\nfunction isObservableProp(value, propName) {\n    if ( true && !isStringish(propName)) {\n        return die(\"expected a property name as second argument\");\n    }\n    return _isObservable(value, propName);\n}\nexports.isObservableProp = isObservableProp;\nfunction keys(obj) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].keys_();\n    }\n    if (isObservableMap(obj) || isObservableSet(obj)) {\n        return Array.from(obj.keys());\n    }\n    if (isObservableArray(obj)) {\n        return obj.map(function (_, index) {\n            return index;\n        });\n    }\n    die(5);\n}\nexports.keys = keys;\nfunction values(obj) {\n    if (isObservableObject(obj)) {\n        return keys(obj).map(function (key) {\n            return obj[key];\n        });\n    }\n    if (isObservableMap(obj)) {\n        return keys(obj).map(function (key) {\n            return obj.get(key);\n        });\n    }\n    if (isObservableSet(obj)) {\n        return Array.from(obj.values());\n    }\n    if (isObservableArray(obj)) {\n        return obj.slice();\n    }\n    die(6);\n}\nexports.values = values;\nfunction entries(obj) {\n    if (isObservableObject(obj)) {\n        return keys(obj).map(function (key) {\n            return [key, obj[key]];\n        });\n    }\n    if (isObservableMap(obj)) {\n        return keys(obj).map(function (key) {\n            return [key, obj.get(key)];\n        });\n    }\n    if (isObservableSet(obj)) {\n        return Array.from(obj.entries());\n    }\n    if (isObservableArray(obj)) {\n        return obj.map(function (key, index) {\n            return [index, key];\n        });\n    }\n    die(7);\n}\nexports.entries = entries;\nfunction set(obj, key, value) {\n    if (arguments.length === 2 && !isObservableSet(obj)) {\n        startBatch();\n        var _values = key;\n        try {\n            for (var _key in _values) {\n                set(obj, _key, _values[_key]);\n            }\n        }\n        finally {\n            endBatch();\n        }\n        return;\n    }\n    if (isObservableObject(obj)) {\n        obj[$mobx].set_(key, value);\n    }\n    else if (isObservableMap(obj)) {\n        obj.set(key, value);\n    }\n    else if (isObservableSet(obj)) {\n        obj.add(key);\n    }\n    else if (isObservableArray(obj)) {\n        if (typeof key !== \"number\") {\n            key = parseInt(key, 10);\n        }\n        if (key < 0) {\n            die(\"Invalid index: '\" + key + \"'\");\n        }\n        startBatch();\n        if (key >= obj.length) {\n            obj.length = key + 1;\n        }\n        obj[key] = value;\n        endBatch();\n    }\n    else {\n        die(8);\n    }\n}\nexports.set = set;\nfunction remove(obj, key) {\n    if (isObservableObject(obj)) {\n        obj[$mobx].delete_(key);\n    }\n    else if (isObservableMap(obj)) {\n        obj[\"delete\"](key);\n    }\n    else if (isObservableSet(obj)) {\n        obj[\"delete\"](key);\n    }\n    else if (isObservableArray(obj)) {\n        if (typeof key !== \"number\") {\n            key = parseInt(key, 10);\n        }\n        obj.splice(key, 1);\n    }\n    else {\n        die(9);\n    }\n}\nexports.remove = remove;\nfunction has(obj, key) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].has_(key);\n    }\n    else if (isObservableMap(obj)) {\n        return obj.has(key);\n    }\n    else if (isObservableSet(obj)) {\n        return obj.has(key);\n    }\n    else if (isObservableArray(obj)) {\n        return key >= 0 && key < obj.length;\n    }\n    die(10);\n}\nexports.has = has;\nfunction get(obj, key) {\n    if (!has(obj, key)) {\n        return undefined;\n    }\n    if (isObservableObject(obj)) {\n        return obj[$mobx].get_(key);\n    }\n    else if (isObservableMap(obj)) {\n        return obj.get(key);\n    }\n    else if (isObservableArray(obj)) {\n        return obj[key];\n    }\n    die(11);\n}\nexports.get = get;\nfunction apiDefineProperty(obj, key, descriptor) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].defineProperty_(key, descriptor);\n    }\n    die(39);\n}\nexports.defineProperty = apiDefineProperty;\nfunction apiOwnKeys(obj) {\n    if (isObservableObject(obj)) {\n        return obj[$mobx].ownKeys_();\n    }\n    die(38);\n}\nexports.ownKeys = apiOwnKeys;\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (isFunction(cbOrFire)) {\n        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n    }\n    else {\n        return observeObservable(thing, propOrCb, cbOrFire);\n    }\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe_(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe_(listener, fireImmediately);\n}\nfunction cache(map, key, value) {\n    map.set(key, value);\n    return value;\n}\nfunction toJSHelper(source, __alreadySeen) {\n    if (source == null || typeof source !== \"object\" || source instanceof Date || !isObservable(source)) {\n        return source;\n    }\n    if (isObservableValue(source) || isComputedValue(source)) {\n        return toJSHelper(source.get(), __alreadySeen);\n    }\n    if (__alreadySeen.has(source)) {\n        return __alreadySeen.get(source);\n    }\n    if (isObservableArray(source)) {\n        var res = cache(__alreadySeen, source, new Array(source.length));\n        source.forEach(function (value, idx) {\n            res[idx] = toJSHelper(value, __alreadySeen);\n        });\n        return res;\n    }\n    if (isObservableSet(source)) {\n        var _res = cache(__alreadySeen, source, new Set());\n        source.forEach(function (value) {\n            _res.add(toJSHelper(value, __alreadySeen));\n        });\n        return _res;\n    }\n    if (isObservableMap(source)) {\n        var _res2 = cache(__alreadySeen, source, new Map());\n        source.forEach(function (value, key) {\n            _res2.set(key, toJSHelper(value, __alreadySeen));\n        });\n        return _res2;\n    }\n    else {\n        // must be observable object\n        var _res3 = cache(__alreadySeen, source, {});\n        apiOwnKeys(source).forEach(function (key) {\n            if (objectPrototype.propertyIsEnumerable.call(source, key)) {\n                _res3[key] = toJSHelper(source[key], __alreadySeen);\n            }\n        });\n        return _res3;\n    }\n}\n/**\n * Recursively converts an observable to it's non-observable native counterpart.\n * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.\n * Computed and other non-enumerable properties are completely ignored.\n * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.\n */\nfunction toJS(source, options) {\n    if ( true && options) {\n        die(\"toJS no longer supports options\");\n    }\n    return toJSHelper(source, new Map());\n}\nexports.toJS = toJS;\nfunction trace() {\n    if (false) {}\n    var enterBreakPoint = false;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n    if (typeof args[args.length - 1] === \"boolean\") {\n        enterBreakPoint = args.pop();\n    }\n    var derivation = getAtomFromArgs(args);\n    if (!derivation) {\n        return die(\"'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly\");\n    }\n    if (derivation.isTracing_ === TraceMode.NONE) {\n        console.log(\"[mobx.trace] '\" + derivation.name_ + \"' tracing enabled\");\n    }\n    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;\n}\nexports.trace = trace;\nfunction getAtomFromArgs(args) {\n    switch (args.length) {\n        case 0:\n            return globalState.trackingDerivation;\n        case 1:\n            return getAtom(args[0]);\n        case 2:\n            return getAtom(args[0], args[1]);\n    }\n}\n/**\n * During a transaction no views are updated until the end of the transaction.\n * The transaction will be run synchronously nonetheless.\n *\n * @param action a function that updates some reactive state\n * @returns any value that was returned by the 'action' parameter.\n */\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    startBatch();\n    try {\n        return action.apply(thisArg);\n    }\n    finally {\n        endBatch();\n    }\n}\nexports.transaction = transaction;\nfunction when(predicate, arg1, arg2) {\n    if (arguments.length === 1 || arg1 && typeof arg1 === \"object\") {\n        return whenPromise(predicate, arg1);\n    }\n    return _when(predicate, arg1, arg2 || {});\n}\nexports.when = when;\nfunction _when(predicate, effect, opts) {\n    var timeoutHandle;\n    if (typeof opts.timeout === \"number\") {\n        var error = new Error(\"WHEN_TIMEOUT\");\n        timeoutHandle = setTimeout(function () {\n            if (!disposer[$mobx].isDisposed_) {\n                disposer();\n                if (opts.onError) {\n                    opts.onError(error);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }, opts.timeout);\n    }\n    opts.name =  true ? opts.name || \"When@\" + getNextId() : undefined;\n    var effectAction = createAction( true ? opts.name + \"-effect\" : undefined, effect);\n    // eslint-disable-next-line\n    var disposer = autorun(function (r) {\n        // predicate should not change state\n        var cond = allowStateChanges(false, predicate);\n        if (cond) {\n            r.dispose();\n            if (timeoutHandle) {\n                clearTimeout(timeoutHandle);\n            }\n            effectAction();\n        }\n    }, opts);\n    return disposer;\n}\nfunction whenPromise(predicate, opts) {\n    var _opts$signal;\n    if ( true && opts && opts.onError) {\n        return die(\"the options 'onError' and 'promise' cannot be combined\");\n    }\n    if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {\n        return Object.assign(Promise.reject(new Error(\"WHEN_ABORTED\")), {\n            cancel: function cancel() {\n                return null;\n            }\n        });\n    }\n    var cancel;\n    var abort;\n    var res = new Promise(function (resolve, reject) {\n        var _opts$signal2;\n        var disposer = _when(predicate, resolve, _extends({}, opts, {\n            onError: reject\n        }));\n        cancel = function cancel() {\n            disposer();\n            reject(new Error(\"WHEN_CANCELLED\"));\n        };\n        abort = function abort() {\n            disposer();\n            reject(new Error(\"WHEN_ABORTED\"));\n        };\n        opts == null ? void 0 : (_opts$signal2 = opts.signal) == null ? void 0 : _opts$signal2.addEventListener == null ? void 0 : _opts$signal2.addEventListener(\"abort\", abort);\n    })[\"finally\"](function () {\n        var _opts$signal3;\n        return opts == null ? void 0 : (_opts$signal3 = opts.signal) == null ? void 0 : _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener(\"abort\", abort);\n    });\n    res.cancel = cancel;\n    return res;\n}\nfunction getAdm(target) {\n    return target[$mobx];\n}\n// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,\n// and skip either the internal values map, or the base object with its property descriptors!\nvar objectProxyTraps = {\n    has: function has(target, name) {\n        if ( true && globalState.trackingDerivation) {\n            warnAboutProxyRequirement(\"detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.\");\n        }\n        return getAdm(target).has_(name);\n    },\n    get: function get(target, name) {\n        return getAdm(target).get_(name);\n    },\n    set: function set(target, name, value) {\n        var _getAdm$set_;\n        if (!isStringish(name)) {\n            return false;\n        }\n        if ( true && !getAdm(target).values_.has(name)) {\n            warnAboutProxyRequirement(\"add a new observable property through direct assignment. Use 'set' from 'mobx' instead.\");\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;\n    },\n    deleteProperty: function deleteProperty(target, name) {\n        var _getAdm$delete_;\n        if (true) {\n            warnAboutProxyRequirement(\"delete properties from an observable object. Use 'remove' from 'mobx' instead.\");\n        }\n        if (!isStringish(name)) {\n            return false;\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;\n    },\n    defineProperty: function defineProperty(target, name, descriptor) {\n        var _getAdm$definePropert;\n        if (true) {\n            warnAboutProxyRequirement(\"define property on an observable object. Use 'defineProperty' from 'mobx' instead.\");\n        }\n        // null (intercepted) -> true (success)\n        return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;\n    },\n    ownKeys: function ownKeys(target) {\n        if ( true && globalState.trackingDerivation) {\n            warnAboutProxyRequirement(\"iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.\");\n        }\n        return getAdm(target).ownKeys_();\n    },\n    preventExtensions: function preventExtensions(target) {\n        die(13);\n    }\n};\nfunction asDynamicObservableObject(target, options) {\n    var _target$$mobx, _target$$mobx$proxy_;\n    assertProxies();\n    target = asObservableObject(target, options);\n    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);\n}\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) {\n            interceptors.splice(idx, 1);\n        }\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950\n        var interceptors = [].concat(interceptable.interceptors_ || []);\n        for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            if (change && !change.type) {\n                die(14);\n            }\n            if (!change) {\n                break;\n            }\n        }\n        return change;\n    }\n    finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) {\n            listeners.splice(idx, 1);\n        }\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners_;\n    if (!listeners) {\n        return;\n    }\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction makeObservable(target, annotations, options) {\n    initObservable(function () {\n        var _annotations;\n        var adm = asObservableObject(target, options)[$mobx];\n        if ( true && annotations && target[storedAnnotationsSymbol]) {\n            die(\"makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.\");\n        }\n        // Default to decorators\n        (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);\n        // Annotate\n        ownKeys(annotations).forEach(function (key) {\n            return adm.make_(key, annotations[key]);\n        });\n    });\n    return target;\n}\nexports.makeObservable = makeObservable;\n// proto[keysSymbol] = new Set<PropertyKey>()\nvar keysSymbol = /*#__PURE__*/ Symbol(\"mobx-keys\");\nfunction makeAutoObservable(target, overrides, options) {\n    if (true) {\n        if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {\n            die(\"'makeAutoObservable' can only be used for classes that don't have a superclass\");\n        }\n        if (isObservableObject(target)) {\n            die(\"makeAutoObservable can only be used on objects not already made observable\");\n        }\n    }\n    // Optimization: avoid visiting protos\n    // Assumes that annotation.make_/.extend_ works the same for plain objects\n    if (isPlainObject(target)) {\n        return extendObservable(target, target, overrides, options);\n    }\n    initObservable(function () {\n        var adm = asObservableObject(target, options)[$mobx];\n        // Optimization: cache keys on proto\n        // Assumes makeAutoObservable can be called only once per object and can't be used in subclass\n        if (!target[keysSymbol]) {\n            var proto = Object.getPrototypeOf(target);\n            var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));\n            keys[\"delete\"](\"constructor\");\n            keys[\"delete\"]($mobx);\n            addHiddenProp(proto, keysSymbol, keys);\n        }\n        target[keysSymbol].forEach(function (key) {\n            return adm.make_(key, \n            // must pass \"undefined\" for { key: undefined }\n            !overrides ? true : key in overrides ? overrides[key] : true);\n        });\n    });\n    return target;\n}\nexports.makeAutoObservable = makeAutoObservable;\nvar SPLICE = \"splice\";\nvar UPDATE = \"update\";\nvar MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859\nvar arrayTraps = {\n    get: function get(target, name) {\n        var adm = target[$mobx];\n        if (name === $mobx) {\n            return adm;\n        }\n        if (name === \"length\") {\n            return adm.getArrayLength_();\n        }\n        if (typeof name === \"string\" && !isNaN(name)) {\n            return adm.get_(parseInt(name));\n        }\n        if (hasProp(arrayExtensions, name)) {\n            return arrayExtensions[name];\n        }\n        return target[name];\n    },\n    set: function set(target, name, value) {\n        var adm = target[$mobx];\n        if (name === \"length\") {\n            adm.setArrayLength_(value);\n        }\n        if (typeof name === \"symbol\" || isNaN(name)) {\n            target[name] = value;\n        }\n        else {\n            // numeric string\n            adm.set_(parseInt(name), value);\n        }\n        return true;\n    },\n    preventExtensions: function preventExtensions() {\n        die(15);\n    }\n};\nvar ObservableArrayAdministration = /*#__PURE__*/ function () {\n    // this is the prop that gets proxied, so can't replace it!\n    function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {\n        if (name === void 0) {\n            name =  true ? \"ObservableArray@\" + getNextId() : undefined;\n        }\n        this.owned_ = void 0;\n        this.legacyMode_ = void 0;\n        this.atom_ = void 0;\n        this.values_ = [];\n        this.interceptors_ = void 0;\n        this.changeListeners_ = void 0;\n        this.enhancer_ = void 0;\n        this.dehancer = void 0;\n        this.proxy_ = void 0;\n        this.lastKnownLength_ = 0;\n        this.owned_ = owned_;\n        this.legacyMode_ = legacyMode_;\n        this.atom_ = new Atom(name);\n        this.enhancer_ = function (newV, oldV) {\n            return enhancer(newV, oldV,  true ? name + \"[..]\" : undefined);\n        };\n    }\n    var _proto = ObservableArrayAdministration.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.dehanceValues_ = function dehanceValues_(values) {\n        if (this.dehancer !== undefined && values.length > 0) {\n            return values.map(this.dehancer);\n        }\n        return values;\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                observableKind: \"array\",\n                object: this.proxy_,\n                debugObjectName: this.atom_.name_,\n                type: \"splice\",\n                index: 0,\n                added: this.values_.slice(),\n                addedCount: this.values_.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    _proto.getArrayLength_ = function getArrayLength_() {\n        this.atom_.reportObserved();\n        return this.values_.length;\n    };\n    _proto.setArrayLength_ = function setArrayLength_(newLength) {\n        if (typeof newLength !== \"number\" || isNaN(newLength) || newLength < 0) {\n            die(\"Out of range: \" + newLength);\n        }\n        var currentLength = this.values_.length;\n        if (newLength === currentLength) {\n            return;\n        }\n        else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            } // No Array.fill everywhere...\n            this.spliceWithArray_(currentLength, 0, newItems);\n        }\n        else {\n            this.spliceWithArray_(newLength, currentLength - newLength);\n        }\n    };\n    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {\n        if (oldLength !== this.lastKnownLength_) {\n            die(16);\n        }\n        this.lastKnownLength_ += delta;\n        if (this.legacyMode_ && delta > 0) {\n            reserveArrayBuffer(oldLength + delta + 1);\n        }\n    };\n    _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom_);\n        var length = this.values_.length;\n        if (index === undefined) {\n            index = 0;\n        }\n        else if (index > length) {\n            index = length;\n        }\n        else if (index < 0) {\n            index = Math.max(0, length + index);\n        }\n        if (arguments.length === 1) {\n            deleteCount = length - index;\n        }\n        else if (deleteCount === undefined || deleteCount === null) {\n            deleteCount = 0;\n        }\n        else {\n            deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        }\n        if (newItems === undefined) {\n            newItems = EMPTY_ARRAY;\n        }\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.proxy_,\n                type: SPLICE,\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) {\n                return EMPTY_ARRAY;\n            }\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {\n            return _this.enhancer_(v, undefined);\n        });\n        if (this.legacyMode_ || \"development\" !== \"production\") {\n            var lengthDelta = newItems.length - deleteCount;\n            this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified\n        }\n        var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) {\n            this.notifyArraySplice_(index, newItems, res);\n        }\n        return this.dehanceValues_(res);\n    };\n    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            var _this$values_;\n            return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));\n        }\n        else {\n            // The items removed by the splice\n            var res = this.values_.slice(index, index + deleteCount);\n            // The items that that should remain at the end of the array\n            var oldItems = this.values_.slice(index + deleteCount);\n            // New length is the previous length + addition count - deletion count\n            this.values_.length += newItems.length - deleteCount;\n            for (var i = 0; i < newItems.length; i++) {\n                this.values_[index + i] = newItems[i];\n            }\n            for (var _i = 0; _i < oldItems.length; _i++) {\n                this.values_[index + newItems.length + _i] = oldItems[_i];\n            }\n            return res;\n        }\n    };\n    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {\n        var notifySpy = !this.owned_ && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"array\",\n            object: this.proxy_,\n            type: UPDATE,\n            debugObjectName: this.atom_.name_,\n            index: index,\n            newValue: newValue,\n            oldValue: oldValue\n        } : null;\n        // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't\n        // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        }\n        this.atom_.reportChanged();\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {\n        var notifySpy = !this.owned_ && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"array\",\n            object: this.proxy_,\n            debugObjectName: this.atom_.name_,\n            type: SPLICE,\n            index: index,\n            removed: removed,\n            added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        }\n        this.atom_.reportChanged();\n        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.get_ = function get_(index) {\n        if (this.legacyMode_ && index >= this.values_.length) {\n            console.warn( true ? \"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + this.values_.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\" : undefined);\n            return undefined;\n        }\n        this.atom_.reportObserved();\n        return this.dehanceValue_(this.values_[index]);\n    };\n    _proto.set_ = function set_(index, newValue) {\n        var values = this.values_;\n        if (this.legacyMode_ && index > values.length) {\n            // out of bounds\n            die(17, index, values.length);\n        }\n        if (index < values.length) {\n            // update at index in range\n            checkIfStateModificationsAreAllowed(this.atom_);\n            var oldValue = values[index];\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    type: UPDATE,\n                    object: this.proxy_,\n                    index: index,\n                    newValue: newValue\n                });\n                if (!change) {\n                    return;\n                }\n                newValue = change.newValue;\n            }\n            newValue = this.enhancer_(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                this.notifyArrayChildUpdate_(index, newValue, oldValue);\n            }\n        }\n        else {\n            // For out of bound index, we don't create an actual sparse array,\n            // but rather fill the holes with undefined (same as setArrayLength_).\n            // This could be considered a bug.\n            var newItems = new Array(index + 1 - values.length);\n            for (var i = 0; i < newItems.length - 1; i++) {\n                newItems[i] = undefined;\n            } // No Array.fill everywhere...\n            newItems[newItems.length - 1] = newValue;\n            this.spliceWithArray_(values.length, 0, newItems);\n        }\n    };\n    return ObservableArrayAdministration;\n}();\nfunction createObservableArray(initialValues, enhancer, name, owned) {\n    if (name === void 0) {\n        name =  true ? \"ObservableArray@\" + getNextId() : undefined;\n    }\n    if (owned === void 0) {\n        owned = false;\n    }\n    assertProxies();\n    return initObservable(function () {\n        var adm = new ObservableArrayAdministration(name, enhancer, owned, false);\n        addHiddenFinalProp(adm.values_, $mobx, adm);\n        var proxy = new Proxy(adm.values_, arrayTraps);\n        adm.proxy_ = proxy;\n        if (initialValues && initialValues.length) {\n            adm.spliceWithArray_(0, 0, initialValues);\n        }\n        return proxy;\n    });\n}\n// eslint-disable-next-line\nvar arrayExtensions = {\n    clear: function clear() {\n        return this.splice(0);\n    },\n    replace: function replace(newItems) {\n        var adm = this[$mobx];\n        return adm.spliceWithArray_(0, adm.values_.length, newItems);\n    },\n    // Used by JSON.stringify\n    toJSON: function toJSON() {\n        return this.slice();\n    },\n    /*\n     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)\n     * since these functions alter the inner structure of the array, the have side effects.\n     * Because the have side effects, they should not be used in computed function,\n     * and for that reason the do not call dependencyState.notifyObserved\n     */\n    splice: function splice(index, deleteCount) {\n        for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n            newItems[_key - 2] = arguments[_key];\n        }\n        var adm = this[$mobx];\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return adm.spliceWithArray_(index);\n            case 2:\n                return adm.spliceWithArray_(index, deleteCount);\n        }\n        return adm.spliceWithArray_(index, deleteCount, newItems);\n    },\n    spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {\n        return this[$mobx].spliceWithArray_(index, deleteCount, newItems);\n    },\n    push: function push() {\n        var adm = this[$mobx];\n        for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            items[_key2] = arguments[_key2];\n        }\n        adm.spliceWithArray_(adm.values_.length, 0, items);\n        return adm.values_.length;\n    },\n    pop: function pop() {\n        return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];\n    },\n    shift: function shift() {\n        return this.splice(0, 1)[0];\n    },\n    unshift: function unshift() {\n        var adm = this[$mobx];\n        for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            items[_key3] = arguments[_key3];\n        }\n        adm.spliceWithArray_(0, 0, items);\n        return adm.values_.length;\n    },\n    reverse: function reverse() {\n        // reverse by default mutates in place before returning the result\n        // which makes it both a 'derivation' and a 'mutation'.\n        if (globalState.trackingDerivation) {\n            die(37, \"reverse\");\n        }\n        this.replace(this.slice().reverse());\n        return this;\n    },\n    sort: function sort() {\n        // sort by default mutates in place before returning the result\n        // which goes against all good practices. Let's not change the array in place!\n        if (globalState.trackingDerivation) {\n            die(37, \"sort\");\n        }\n        var copy = this.slice();\n        copy.sort.apply(copy, arguments);\n        this.replace(copy);\n        return this;\n    },\n    remove: function remove(value) {\n        var adm = this[$mobx];\n        var idx = adm.dehanceValues_(adm.values_).indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    }\n};\n/**\n * Wrap function from prototype\n * Without this, everything works as well, but this works\n * faster as everything works on unproxied values\n */\naddArrayExtension(\"at\", simpleFunc);\naddArrayExtension(\"concat\", simpleFunc);\naddArrayExtension(\"flat\", simpleFunc);\naddArrayExtension(\"includes\", simpleFunc);\naddArrayExtension(\"indexOf\", simpleFunc);\naddArrayExtension(\"join\", simpleFunc);\naddArrayExtension(\"lastIndexOf\", simpleFunc);\naddArrayExtension(\"slice\", simpleFunc);\naddArrayExtension(\"toString\", simpleFunc);\naddArrayExtension(\"toLocaleString\", simpleFunc);\naddArrayExtension(\"toSorted\", simpleFunc);\naddArrayExtension(\"toSpliced\", simpleFunc);\naddArrayExtension(\"with\", simpleFunc);\n// map\naddArrayExtension(\"every\", mapLikeFunc);\naddArrayExtension(\"filter\", mapLikeFunc);\naddArrayExtension(\"find\", mapLikeFunc);\naddArrayExtension(\"findIndex\", mapLikeFunc);\naddArrayExtension(\"findLast\", mapLikeFunc);\naddArrayExtension(\"findLastIndex\", mapLikeFunc);\naddArrayExtension(\"flatMap\", mapLikeFunc);\naddArrayExtension(\"forEach\", mapLikeFunc);\naddArrayExtension(\"map\", mapLikeFunc);\naddArrayExtension(\"some\", mapLikeFunc);\naddArrayExtension(\"toReversed\", mapLikeFunc);\n// reduce\naddArrayExtension(\"reduce\", reduceLikeFunc);\naddArrayExtension(\"reduceRight\", reduceLikeFunc);\nfunction addArrayExtension(funcName, funcFactory) {\n    if (typeof Array.prototype[funcName] === \"function\") {\n        arrayExtensions[funcName] = funcFactory(funcName);\n    }\n}\n// Report and delegate to dehanced array\nfunction simpleFunc(funcName) {\n    return function () {\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n}\n// Make sure callbacks recieve correct array arg #2326\nfunction mapLikeFunc(funcName) {\n    return function (callback, thisArg) {\n        var _this2 = this;\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        return dehancedValues[funcName](function (element, index) {\n            return callback.call(thisArg, element, index, _this2);\n        });\n    };\n}\n// Make sure callbacks recieve correct array arg #2326\nfunction reduceLikeFunc(funcName) {\n    return function () {\n        var _this3 = this;\n        var adm = this[$mobx];\n        adm.atom_.reportObserved();\n        var dehancedValues = adm.dehanceValues_(adm.values_);\n        // #2432 - reduce behavior depends on arguments.length\n        var callback = arguments[0];\n        arguments[0] = function (accumulator, currentValue, index) {\n            return callback(accumulator, currentValue, index, _this3);\n        };\n        return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n}\nvar isObservableArrayAdministration = /*#__PURE__*/ createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);\n}\nexports.isObservableArray = isObservableArray;\nvar _Symbol$iterator, _Symbol$toStringTag;\nvar ObservableMapMarker = {};\nvar ADD = \"add\";\nvar DELETE = \"delete\";\n// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54\n// But: https://github.com/mobxjs/mobx/issues/1556\n_Symbol$iterator = Symbol.iterator;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar ObservableMap = /*#__PURE__*/ function () {\n    // hasMap, not hashMap >-).\n    function ObservableMap(initialData, enhancer_, name_) {\n        var _this = this;\n        if (enhancer_ === void 0) {\n            enhancer_ = deepEnhancer;\n        }\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableMap@\" + getNextId() : undefined;\n        }\n        this.enhancer_ = void 0;\n        this.name_ = void 0;\n        this[$mobx] = ObservableMapMarker;\n        this.data_ = void 0;\n        this.hasMap_ = void 0;\n        this.keysAtom_ = void 0;\n        this.interceptors_ = void 0;\n        this.changeListeners_ = void 0;\n        this.dehancer = void 0;\n        this.enhancer_ = enhancer_;\n        this.name_ = name_;\n        if (!isFunction(Map)) {\n            die(18);\n        }\n        initObservable(function () {\n            _this.keysAtom_ = createAtom( true ? _this.name_ + \".keys()\" : undefined);\n            _this.data_ = new Map();\n            _this.hasMap_ = new Map();\n            if (initialData) {\n                _this.merge(initialData);\n            }\n        });\n    }\n    var _proto = ObservableMap.prototype;\n    _proto.has_ = function has_(key) {\n        return this.data_.has(key);\n    };\n    _proto.has = function has(key) {\n        var _this2 = this;\n        if (!globalState.trackingDerivation) {\n            return this.has_(key);\n        }\n        var entry = this.hasMap_.get(key);\n        if (!entry) {\n            var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : undefined, false);\n            this.hasMap_.set(key, newEntry);\n            onBecomeUnobserved(newEntry, function () {\n                return _this2.hasMap_[\"delete\"](key);\n            });\n        }\n        return entry.get();\n    };\n    _proto.set = function set(key, value) {\n        var hasKey = this.has_(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? UPDATE : ADD,\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) {\n                return this;\n            }\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this.updateValue_(key, value);\n        }\n        else {\n            this.addValue_(key, value);\n        }\n        return this;\n    };\n    _proto[\"delete\"] = function _delete(key) {\n        var _this3 = this;\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: DELETE,\n                object: this,\n                name: key\n            });\n            if (!change) {\n                return false;\n            }\n        }\n        if (this.has_(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change = notify || notifySpy ? {\n                observableKind: \"map\",\n                debugObjectName: this.name_,\n                type: DELETE,\n                object: this,\n                oldValue: this.data_.get(key).value_,\n                name: key\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(_change);\n            } // TODO fix type\n            transaction(function () {\n                var _this3$hasMap_$get;\n                _this3.keysAtom_.reportChanged();\n                (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);\n                var observable = _this3.data_.get(key);\n                observable.setNewValue_(undefined);\n                _this3.data_[\"delete\"](key);\n            });\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n            return true;\n        }\n        return false;\n    };\n    _proto.updateValue_ = function updateValue_(key, newValue) {\n        var observable = this.data_.get(key);\n        newValue = observable.prepareNewValue_(newValue);\n        if (newValue !== globalState.UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                observableKind: \"map\",\n                debugObjectName: this.name_,\n                type: UPDATE,\n                object: this,\n                oldValue: observable.value_,\n                name: key,\n                newValue: newValue\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(change);\n            } // TODO fix type\n            observable.setNewValue_(newValue);\n            if (notify) {\n                notifyListeners(this, change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n    };\n    _proto.addValue_ = function addValue_(key, newValue) {\n        var _this4 = this;\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        transaction(function () {\n            var _this4$hasMap_$get;\n            var observable = new ObservableValue(newValue, _this4.enhancer_,  true ? _this4.name_ + \".\" + stringifyKey(key) : undefined, false);\n            _this4.data_.set(key, observable);\n            newValue = observable.value_; // value might have been changed\n            (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);\n            _this4.keysAtom_.reportChanged();\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            observableKind: \"map\",\n            debugObjectName: this.name_,\n            type: ADD,\n            object: this,\n            name: key,\n            newValue: newValue\n        } : null;\n        if ( true && notifySpy) {\n            spyReportStart(change);\n        } // TODO fix type\n        if (notify) {\n            notifyListeners(this, change);\n        }\n        if ( true && notifySpy) {\n            spyReportEnd();\n        }\n    };\n    _proto.get = function get(key) {\n        if (this.has(key)) {\n            return this.dehanceValue_(this.data_.get(key).get());\n        }\n        return this.dehanceValue_(undefined);\n    };\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.keys = function keys() {\n        this.keysAtom_.reportObserved();\n        return this.data_.keys();\n    };\n    _proto.values = function values() {\n        var self = this;\n        var keys = this.keys();\n        return makeIterable({\n            next: function next() {\n                var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;\n                return {\n                    done: done,\n                    value: done ? undefined : self.get(value)\n                };\n            }\n        });\n    };\n    _proto.entries = function entries() {\n        var self = this;\n        var keys = this.keys();\n        return makeIterable({\n            next: function next() {\n                var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;\n                return {\n                    done: done,\n                    value: done ? undefined : [value, self.get(value)]\n                };\n            }\n        });\n    };\n    _proto[_Symbol$iterator] = function () {\n        return this.entries();\n    };\n    _proto.forEach = function forEach(callback, thisArg) {\n        for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {\n            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];\n            callback.call(thisArg, value, key, this);\n        }\n    };\n    _proto.merge = function merge(other) {\n        var _this5 = this;\n        if (isObservableMap(other)) {\n            other = new Map(other);\n        }\n        transaction(function () {\n            if (isPlainObject(other)) {\n                getPlainObjectKeys(other).forEach(function (key) {\n                    return _this5.set(key, other[key]);\n                });\n            }\n            else if (Array.isArray(other)) {\n                other.forEach(function (_ref) {\n                    var key = _ref[0], value = _ref[1];\n                    return _this5.set(key, value);\n                });\n            }\n            else if (isES6Map(other)) {\n                if (other.constructor !== Map) {\n                    die(19, other);\n                }\n                other.forEach(function (value, key) {\n                    return _this5.set(key, value);\n                });\n            }\n            else if (other !== null && other !== undefined) {\n                die(20, other);\n            }\n        });\n        return this;\n    };\n    _proto.clear = function clear() {\n        var _this6 = this;\n        transaction(function () {\n            untracked(function () {\n                for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done;) {\n                    var key = _step2.value;\n                    _this6[\"delete\"](key);\n                }\n            });\n        });\n    };\n    _proto.replace = function replace(values) {\n        var _this7 = this;\n        // Implementation requirements:\n        // - respect ordering of replacement map\n        // - allow interceptors to run and potentially prevent individual operations\n        // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)\n        // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)\n        // - note that result map may differ from replacement map due to the interceptors\n        transaction(function () {\n            // Convert to map so we can do quick key lookups\n            var replacementMap = convertToMap(values);\n            var orderedData = new Map();\n            // Used for optimization\n            var keysReportChangedCalled = false;\n            // Delete keys that don't exist in replacement map\n            // if the key deletion is prevented by interceptor\n            // add entry at the beginning of the result map\n            for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {\n                var key = _step3.value;\n                // Concurrently iterating/deleting keys\n                // iterator should handle this correctly\n                if (!replacementMap.has(key)) {\n                    var deleted = _this7[\"delete\"](key);\n                    // Was the key removed?\n                    if (deleted) {\n                        // _keysAtom.reportChanged() was already called\n                        keysReportChangedCalled = true;\n                    }\n                    else {\n                        // Delete prevented by interceptor\n                        var value = _this7.data_.get(key);\n                        orderedData.set(key, value);\n                    }\n                }\n            }\n            // Merge entries\n            for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {\n                var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];\n                // We will want to know whether a new key is added\n                var keyExisted = _this7.data_.has(_key);\n                // Add or update value\n                _this7.set(_key, _value);\n                // The addition could have been prevent by interceptor\n                if (_this7.data_.has(_key)) {\n                    // The update could have been prevented by interceptor\n                    // and also we want to preserve existing values\n                    // so use value from _data map (instead of replacement map)\n                    var _value2 = _this7.data_.get(_key);\n                    orderedData.set(_key, _value2);\n                    // Was a new key added?\n                    if (!keyExisted) {\n                        // _keysAtom.reportChanged() was already called\n                        keysReportChangedCalled = true;\n                    }\n                }\n            }\n            // Check for possible key order change\n            if (!keysReportChangedCalled) {\n                if (_this7.data_.size !== orderedData.size) {\n                    // If size differs, keys are definitely modified\n                    _this7.keysAtom_.reportChanged();\n                }\n                else {\n                    var iter1 = _this7.data_.keys();\n                    var iter2 = orderedData.keys();\n                    var next1 = iter1.next();\n                    var next2 = iter2.next();\n                    while (!next1.done) {\n                        if (next1.value !== next2.value) {\n                            _this7.keysAtom_.reportChanged();\n                            break;\n                        }\n                        next1 = iter1.next();\n                        next2 = iter2.next();\n                    }\n                }\n            }\n            // Use correctly ordered map\n            _this7.data_ = orderedData;\n        });\n        return this;\n    };\n    _proto.toString = function toString() {\n        return \"[object ObservableMap]\";\n    };\n    _proto.toJSON = function toJSON() {\n        return Array.from(this);\n    };\n    /**\n     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\n     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\n     * for callback details\n     */\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support fireImmediately=true in combination with maps.\");\n        }\n        return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _createClass(ObservableMap, [{\n            key: \"size\",\n            get: function get() {\n                this.keysAtom_.reportObserved();\n                return this.data_.size;\n            }\n        }, {\n            key: _Symbol$toStringTag,\n            get: function get() {\n                return \"Map\";\n            }\n        }]);\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\n// eslint-disable-next-line\nvar isObservableMap = /*#__PURE__*/ createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nfunction convertToMap(dataStructure) {\n    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {\n        return dataStructure;\n    }\n    else if (Array.isArray(dataStructure)) {\n        return new Map(dataStructure);\n    }\n    else if (isPlainObject(dataStructure)) {\n        var map = new Map();\n        for (var key in dataStructure) {\n            map.set(key, dataStructure[key]);\n        }\n        return map;\n    }\n    else {\n        return die(21, dataStructure);\n    }\n}\nvar _Symbol$iterator$1, _Symbol$toStringTag$1;\nvar ObservableSetMarker = {};\n_Symbol$iterator$1 = Symbol.iterator;\n_Symbol$toStringTag$1 = Symbol.toStringTag;\nvar ObservableSet = /*#__PURE__*/ function () {\n    function ObservableSet(initialData, enhancer, name_) {\n        var _this = this;\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name_ === void 0) {\n            name_ =  true ? \"ObservableSet@\" + getNextId() : undefined;\n        }\n        this.name_ = void 0;\n        this[$mobx] = ObservableSetMarker;\n        this.data_ = new Set();\n        this.atom_ = void 0;\n        this.changeListeners_ = void 0;\n        this.interceptors_ = void 0;\n        this.dehancer = void 0;\n        this.enhancer_ = void 0;\n        this.name_ = name_;\n        if (!isFunction(Set)) {\n            die(22);\n        }\n        this.enhancer_ = function (newV, oldV) {\n            return enhancer(newV, oldV, name_);\n        };\n        initObservable(function () {\n            _this.atom_ = createAtom(_this.name_);\n            if (initialData) {\n                _this.replace(initialData);\n            }\n        });\n    }\n    var _proto = ObservableSet.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n        if (this.dehancer !== undefined) {\n            return this.dehancer(value);\n        }\n        return value;\n    };\n    _proto.clear = function clear() {\n        var _this2 = this;\n        transaction(function () {\n            untracked(function () {\n                for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done;) {\n                    var value = _step.value;\n                    _this2[\"delete\"](value);\n                }\n            });\n        });\n    };\n    _proto.forEach = function forEach(callbackFn, thisArg) {\n        for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {\n            var value = _step2.value;\n            callbackFn.call(thisArg, value, value, this);\n        }\n    };\n    _proto.add = function add(value) {\n        var _this3 = this;\n        checkIfStateModificationsAreAllowed(this.atom_);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: ADD,\n                object: this,\n                newValue: value\n            });\n            if (!change) {\n                return this;\n            }\n            // ideally, value = change.value would be done here, so that values can be\n            // changed by interceptor. Same applies for other Set and Map api's.\n        }\n        if (!this.has(value)) {\n            transaction(function () {\n                _this3.data_.add(_this3.enhancer_(value, undefined));\n                _this3.atom_.reportChanged();\n            });\n            var notifySpy =  true && isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change = notify || notifySpy ? {\n                observableKind: \"set\",\n                debugObjectName: this.name_,\n                type: ADD,\n                object: this,\n                newValue: value\n            } : null;\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportStart(_change);\n            }\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportEnd();\n            }\n        }\n        return this;\n    };\n    _proto[\"delete\"] = function _delete(value) {\n        var _this4 = this;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: DELETE,\n                object: this,\n                oldValue: value\n            });\n            if (!change) {\n                return false;\n            }\n        }\n        if (this.has(value)) {\n            var notifySpy =  true && isSpyEnabled();\n            var notify = hasListeners(this);\n            var _change2 = notify || notifySpy ? {\n                observableKind: \"set\",\n                debugObjectName: this.name_,\n                type: DELETE,\n                object: this,\n                oldValue: value\n            } : null;\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportStart(_change2);\n            }\n            transaction(function () {\n                _this4.atom_.reportChanged();\n                _this4.data_[\"delete\"](value);\n            });\n            if (notify) {\n                notifyListeners(this, _change2);\n            }\n            if (notifySpy && \"development\" !== \"production\") {\n                spyReportEnd();\n            }\n            return true;\n        }\n        return false;\n    };\n    _proto.has = function has(value) {\n        this.atom_.reportObserved();\n        return this.data_.has(this.dehanceValue_(value));\n    };\n    _proto.entries = function entries() {\n        var nextIndex = 0;\n        var keys = Array.from(this.keys());\n        var values = Array.from(this.values());\n        return makeIterable({\n            next: function next() {\n                var index = nextIndex;\n                nextIndex += 1;\n                return index < values.length ? {\n                    value: [keys[index], values[index]],\n                    done: false\n                } : {\n                    done: true\n                };\n            }\n        });\n    };\n    _proto.keys = function keys() {\n        return this.values();\n    };\n    _proto.values = function values() {\n        this.atom_.reportObserved();\n        var self = this;\n        var nextIndex = 0;\n        var observableValues = Array.from(this.data_.values());\n        return makeIterable({\n            next: function next() {\n                return nextIndex < observableValues.length ? {\n                    value: self.dehanceValue_(observableValues[nextIndex++]),\n                    done: false\n                } : {\n                    done: true\n                };\n            }\n        });\n    };\n    _proto.replace = function replace(other) {\n        var _this5 = this;\n        if (isObservableSet(other)) {\n            other = new Set(other);\n        }\n        transaction(function () {\n            if (Array.isArray(other)) {\n                _this5.clear();\n                other.forEach(function (value) {\n                    return _this5.add(value);\n                });\n            }\n            else if (isES6Set(other)) {\n                _this5.clear();\n                other.forEach(function (value) {\n                    return _this5.add(value);\n                });\n            }\n            else if (other !== null && other !== undefined) {\n                die(\"Cannot initialize set from \" + other);\n            }\n        });\n        return this;\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n        // ... 'fireImmediately' could also be true?\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support fireImmediately=true in combination with sets.\");\n        }\n        return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.toJSON = function toJSON() {\n        return Array.from(this);\n    };\n    _proto.toString = function toString() {\n        return \"[object ObservableSet]\";\n    };\n    _proto[_Symbol$iterator$1] = function () {\n        return this.values();\n    };\n    _createClass(ObservableSet, [{\n            key: \"size\",\n            get: function get() {\n                this.atom_.reportObserved();\n                return this.data_.size;\n            }\n        }, {\n            key: _Symbol$toStringTag$1,\n            get: function get() {\n                return \"Set\";\n            }\n        }]);\n    return ObservableSet;\n}();\nexports.ObservableSet = ObservableSet;\n// eslint-disable-next-line\nvar isObservableSet = /*#__PURE__*/ createInstanceofPredicate(\"ObservableSet\", ObservableSet);\nexports.isObservableSet = isObservableSet;\nvar descriptorCache = /*#__PURE__*/ Object.create(null);\nvar REMOVE = \"remove\";\nvar ObservableObjectAdministration = /*#__PURE__*/ function () {\n    function ObservableObjectAdministration(target_, values_, name_, \n    // Used anytime annotation is not explicitely provided\n    defaultAnnotation_) {\n        if (values_ === void 0) {\n            values_ = new Map();\n        }\n        if (defaultAnnotation_ === void 0) {\n            defaultAnnotation_ = autoAnnotation;\n        }\n        this.target_ = void 0;\n        this.values_ = void 0;\n        this.name_ = void 0;\n        this.defaultAnnotation_ = void 0;\n        this.keysAtom_ = void 0;\n        this.changeListeners_ = void 0;\n        this.interceptors_ = void 0;\n        this.proxy_ = void 0;\n        this.isPlainObject_ = void 0;\n        this.appliedAnnotations_ = void 0;\n        this.pendingKeys_ = void 0;\n        this.target_ = target_;\n        this.values_ = values_;\n        this.name_ = name_;\n        this.defaultAnnotation_ = defaultAnnotation_;\n        this.keysAtom_ = new Atom( true ? this.name_ + \".keys\" : undefined);\n        // Optimization: we use this frequently\n        this.isPlainObject_ = isPlainObject(this.target_);\n        if ( true && !isAnnotation(this.defaultAnnotation_)) {\n            die(\"defaultAnnotation must be valid annotation\");\n        }\n        if (true) {\n            // Prepare structure for tracking which fields were already annotated\n            this.appliedAnnotations_ = {};\n        }\n    }\n    var _proto = ObservableObjectAdministration.prototype;\n    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {\n        return this.values_.get(key).get();\n    };\n    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {\n        var observable = this.values_.get(key);\n        if (observable instanceof ComputedValue) {\n            observable.set(newValue);\n            return true;\n        }\n        // intercept\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: UPDATE,\n                object: this.proxy_ || this.target_,\n                name: key,\n                newValue: newValue\n            });\n            if (!change) {\n                return null;\n            }\n            newValue = change.newValue;\n        }\n        newValue = observable.prepareNewValue_(newValue);\n        // notify spy & observers\n        if (newValue !== globalState.UNCHANGED) {\n            var notify = hasListeners(this);\n            var notifySpy =  true && isSpyEnabled();\n            var _change = notify || notifySpy ? {\n                type: UPDATE,\n                observableKind: \"object\",\n                debugObjectName: this.name_,\n                object: this.proxy_ || this.target_,\n                oldValue: observable.value_,\n                name: key,\n                newValue: newValue\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(_change);\n            }\n            observable.setNewValue_(newValue);\n            if (notify) {\n                notifyListeners(this, _change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n        return true;\n    };\n    _proto.get_ = function get_(key) {\n        if (globalState.trackingDerivation && !hasProp(this.target_, key)) {\n            // Key doesn't exist yet, subscribe for it in case it's added later\n            this.has_(key);\n        }\n        return this.target_[key];\n    };\n    _proto.set_ = function set_(key, value, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        // Don't use .has(key) - we care about own\n        if (hasProp(this.target_, key)) {\n            // Existing prop\n            if (this.values_.has(key)) {\n                // Observable (can be intercepted)\n                return this.setObservablePropValue_(key, value);\n            }\n            else if (proxyTrap) {\n                // Non-observable - proxy\n                return Reflect.set(this.target_, key, value);\n            }\n            else {\n                // Non-observable\n                this.target_[key] = value;\n                return true;\n            }\n        }\n        else {\n            // New prop\n            return this.extend_(key, {\n                value: value,\n                enumerable: true,\n                writable: true,\n                configurable: true\n            }, this.defaultAnnotation_, proxyTrap);\n        }\n    };\n    _proto.has_ = function has_(key) {\n        if (!globalState.trackingDerivation) {\n            // Skip key subscription outside derivation\n            return key in this.target_;\n        }\n        this.pendingKeys_ || (this.pendingKeys_ = new Map());\n        var entry = this.pendingKeys_.get(key);\n        if (!entry) {\n            entry = new ObservableValue(key in this.target_, referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : undefined, false);\n            this.pendingKeys_.set(key, entry);\n        }\n        return entry.get();\n    };\n    _proto.make_ = function make_(key, annotation) {\n        if (annotation === true) {\n            annotation = this.defaultAnnotation_;\n        }\n        if (annotation === false) {\n            return;\n        }\n        assertAnnotable(this, annotation, key);\n        if (!(key in this.target_)) {\n            var _this$target_$storedA;\n            // Throw on missing key, except for decorators:\n            // Decorator annotations are collected from whole prototype chain.\n            // When called from super() some props may not exist yet.\n            // However we don't have to worry about missing prop,\n            // because the decorator must have been applied to something.\n            if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {\n                return; // will be annotated by subclass constructor\n            }\n            else {\n                die(1, annotation.annotationType_, this.name_ + \".\" + key.toString());\n            }\n        }\n        var source = this.target_;\n        while (source && source !== objectPrototype) {\n            var descriptor = getDescriptor(source, key);\n            if (descriptor) {\n                var outcome = annotation.make_(this, key, descriptor, source);\n                if (outcome === 0 /* MakeResult.Cancel */) {\n                    return;\n                }\n                if (outcome === 1 /* MakeResult.Break */) {\n                    break;\n                }\n            }\n            source = Object.getPrototypeOf(source);\n        }\n        recordAnnotationApplied(this, annotation, key);\n    };\n    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        if (annotation === true) {\n            annotation = this.defaultAnnotation_;\n        }\n        if (annotation === false) {\n            return this.defineProperty_(key, descriptor, proxyTrap);\n        }\n        assertAnnotable(this, annotation, key);\n        var outcome = annotation.extend_(this, key, descriptor, proxyTrap);\n        if (outcome) {\n            recordAnnotationApplied(this, annotation, key);\n        }\n        return outcome;\n    };\n    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: descriptor.value\n                });\n                if (!change) {\n                    return null;\n                }\n                var newValue = change.newValue;\n                if (descriptor.value !== newValue) {\n                    descriptor = _extends({}, descriptor, {\n                        value: newValue\n                    });\n                }\n            }\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            }\n            else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            // Notify\n            this.notifyPropertyAddition_(key, descriptor.value);\n        }\n        finally {\n            endBatch();\n        }\n        return true;\n    };\n    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: value\n                });\n                if (!change) {\n                    return null;\n                }\n                value = change.newValue;\n            }\n            var cachedDescriptor = getCachedObservablePropDescriptor(key);\n            var descriptor = {\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n                enumerable: true,\n                get: cachedDescriptor.get,\n                set: cachedDescriptor.set\n            };\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            }\n            else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            var observable = new ObservableValue(value, enhancer,  true ? this.name_ + \".\" + key.toString() : undefined, false);\n            this.values_.set(key, observable);\n            // Notify (value possibly changed by ObservableValue)\n            this.notifyPropertyAddition_(key, observable.value_);\n        }\n        finally {\n            endBatch();\n        }\n        return true;\n    };\n    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        try {\n            startBatch();\n            // Delete\n            var deleteOutcome = this.delete_(key);\n            if (!deleteOutcome) {\n                // Failure or intercepted\n                return deleteOutcome;\n            }\n            // ADD interceptor\n            if (hasInterceptors(this)) {\n                var change = interceptChange(this, {\n                    object: this.proxy_ || this.target_,\n                    name: key,\n                    type: ADD,\n                    newValue: undefined\n                });\n                if (!change) {\n                    return null;\n                }\n            }\n            options.name || (options.name =  true ? this.name_ + \".\" + key.toString() : undefined);\n            options.context = this.proxy_ || this.target_;\n            var cachedDescriptor = getCachedObservablePropDescriptor(key);\n            var descriptor = {\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n                enumerable: false,\n                get: cachedDescriptor.get,\n                set: cachedDescriptor.set\n            };\n            // Define\n            if (proxyTrap) {\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n                    return false;\n                }\n            }\n            else {\n                defineProperty(this.target_, key, descriptor);\n            }\n            this.values_.set(key, new ComputedValue(options));\n            // Notify\n            this.notifyPropertyAddition_(key, undefined);\n        }\n        finally {\n            endBatch();\n        }\n        return true;\n    };\n    _proto.delete_ = function delete_(key, proxyTrap) {\n        if (proxyTrap === void 0) {\n            proxyTrap = false;\n        }\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\n        // No such prop\n        if (!hasProp(this.target_, key)) {\n            return true;\n        }\n        // Intercept\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.proxy_ || this.target_,\n                name: key,\n                type: REMOVE\n            });\n            // Cancelled\n            if (!change) {\n                return null;\n            }\n        }\n        // Delete\n        try {\n            var _this$pendingKeys_, _this$pendingKeys_$ge;\n            startBatch();\n            var notify = hasListeners(this);\n            var notifySpy =  true && isSpyEnabled();\n            var observable = this.values_.get(key);\n            // Value needed for spies/listeners\n            var value = undefined;\n            // Optimization: don't pull the value unless we will need it\n            if (!observable && (notify || notifySpy)) {\n                var _getDescriptor;\n                value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;\n            }\n            // delete prop (do first, may fail)\n            if (proxyTrap) {\n                if (!Reflect.deleteProperty(this.target_, key)) {\n                    return false;\n                }\n            }\n            else {\n                delete this.target_[key];\n            }\n            // Allow re-annotating this field\n            if (true) {\n                delete this.appliedAnnotations_[key];\n            }\n            // Clear observable\n            if (observable) {\n                this.values_[\"delete\"](key);\n                // for computed, value is undefined\n                if (observable instanceof ObservableValue) {\n                    value = observable.value_;\n                }\n                // Notify: autorun(() => obj[key]), see #1796\n                propagateChanged(observable);\n            }\n            // Notify \"keys/entries/values\" observers\n            this.keysAtom_.reportChanged();\n            // Notify \"has\" observers\n            // \"in\" as it may still exist in proto\n            (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);\n            // Notify spies/listeners\n            if (notify || notifySpy) {\n                var _change2 = {\n                    type: REMOVE,\n                    observableKind: \"object\",\n                    object: this.proxy_ || this.target_,\n                    debugObjectName: this.name_,\n                    oldValue: value,\n                    name: key\n                };\n                if ( true && notifySpy) {\n                    spyReportStart(_change2);\n                }\n                if (notify) {\n                    notifyListeners(this, _change2);\n                }\n                if ( true && notifySpy) {\n                    spyReportEnd();\n                }\n            }\n        }\n        finally {\n            endBatch();\n        }\n        return true;\n    };\n    _proto.observe_ = function observe_(callback, fireImmediately) {\n        if ( true && fireImmediately === true) {\n            die(\"`observe` doesn't support the fire immediately property for observable objects.\");\n        }\n        return registerListener(this, callback);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n        return registerInterceptor(this, handler);\n    };\n    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {\n        var _this$pendingKeys_2, _this$pendingKeys_2$g;\n        var notify = hasListeners(this);\n        var notifySpy =  true && isSpyEnabled();\n        if (notify || notifySpy) {\n            var change = notify || notifySpy ? {\n                type: ADD,\n                observableKind: \"object\",\n                debugObjectName: this.name_,\n                object: this.proxy_ || this.target_,\n                name: key,\n                newValue: value\n            } : null;\n            if ( true && notifySpy) {\n                spyReportStart(change);\n            }\n            if (notify) {\n                notifyListeners(this, change);\n            }\n            if ( true && notifySpy) {\n                spyReportEnd();\n            }\n        }\n        (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);\n        // Notify \"keys/entries/values\" observers\n        this.keysAtom_.reportChanged();\n    };\n    _proto.ownKeys_ = function ownKeys_() {\n        this.keysAtom_.reportObserved();\n        return ownKeys(this.target_);\n    };\n    _proto.keys_ = function keys_() {\n        // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.\n        // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.\n        // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)\n        // We choose to over-report in Object.keys(object), because:\n        // - typically it's used with simple data objects\n        // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected\n        this.keysAtom_.reportObserved();\n        return Object.keys(this.target_);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, options) {\n    var _options$name;\n    if ( true && options && isObservableObject(target)) {\n        die(\"Options can't be provided for already observable objects.\");\n    }\n    if (hasProp(target, $mobx)) {\n        if ( true && !(getAdministration(target) instanceof ObservableObjectAdministration)) {\n            die(\"Cannot convert '\" + getDebugName(target) + \"' into observable object:\" + \"\\nThe target is already observable of different type.\" + \"\\nExtending builtins is not supported.\");\n        }\n        return target;\n    }\n    if ( true && !Object.isExtensible(target)) {\n        die(\"Cannot make the designated object observable; it is not extensible\");\n    }\n    var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  true ? (isPlainObject(target) ? \"ObservableObject\" : target.constructor.name) + \"@\" + getNextId() : undefined;\n    var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));\n    addHiddenProp(target, $mobx, adm);\n    return target;\n}\nvar isObservableObjectAdministration = /*#__PURE__*/ createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction getCachedObservablePropDescriptor(key) {\n    return descriptorCache[key] || (descriptorCache[key] = {\n        get: function get() {\n            return this[$mobx].getObservablePropValue_(key);\n        },\n        set: function set(value) {\n            return this[$mobx].setObservablePropValue_(key, value);\n        }\n    });\n}\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        return isObservableObjectAdministration(thing[$mobx]);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nfunction recordAnnotationApplied(adm, annotation, key) {\n    var _adm$target_$storedAn;\n    if (true) {\n        adm.appliedAnnotations_[key] = annotation;\n    }\n    // Remove applied decorator annotation so we don't try to apply it again in subclass constructor\n    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];\n}\nfunction assertAnnotable(adm, annotation, key) {\n    // Valid annotation\n    if ( true && !isAnnotation(annotation)) {\n        die(\"Cannot annotate '\" + adm.name_ + \".\" + key.toString() + \"': Invalid annotation.\");\n    }\n    /*\n    // Configurable, not sealed, not frozen\n    // Possibly not needed, just a little better error then the one thrown by engine.\n    // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.\n    if (__DEV__) {\n        const configurable = getDescriptor(adm.target_, key)?.configurable\n        const frozen = Object.isFrozen(adm.target_)\n        const sealed = Object.isSealed(adm.target_)\n        if (!configurable || frozen || sealed) {\n            const fieldName = `${adm.name_}.${key.toString()}`\n            const requestedAnnotationType = annotation.annotationType_\n            let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`\n            if (frozen) {\n                error += `\\nObject is frozen.`\n            }\n            if (sealed) {\n                error += `\\nObject is sealed.`\n            }\n            if (!configurable) {\n                error += `\\nproperty is not configurable.`\n                // Mention only if caused by us to avoid confusion\n                if (hasProp(adm.appliedAnnotations!, key)) {\n                    error += `\\nTo prevent accidental re-definition of a field by a subclass, `\n                    error += `all annotated fields of non-plain objects (classes) are not configurable.`\n                }\n            }\n            die(error)\n        }\n    }\n    */\n    // Not annotated\n    if ( true && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {\n        var fieldName = adm.name_ + \".\" + key.toString();\n        var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;\n        var requestedAnnotationType = annotation.annotationType_;\n        die(\"Cannot apply '\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already annotated with '\" + currentAnnotationType + \"'.\") + \"\\nRe-annotating fields is not allowed.\" + \"\\nUse 'override' annotation for methods overridden by subclass.\");\n    }\n}\n// Bug in safari 9.* (or iOS 9 safari mobile). See #364\nvar ENTRY_0 = /*#__PURE__*/ createArrayEntryDescriptor(0);\nvar safariPrototypeSetterInheritanceBug = /*#__PURE__*/ function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", {\n        set: function set() {\n            v = true;\n        }\n    });\n    /*#__PURE__*/ Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\n/**\n * This array buffer contains two lists of properties, so that all arrays\n * can recycle their property definitions, which significantly improves performance of creating\n * properties on the fly.\n */\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\n// Typescript workaround to make sure ObservableArray extends Array\nvar StubArray = function StubArray() { };\nfunction inherit(ctor, proto) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(ctor.prototype, proto);\n    }\n    else if (ctor.prototype.__proto__ !== undefined) {\n        ctor.prototype.__proto__ = proto;\n    }\n    else {\n        ctor.prototype = proto;\n    }\n}\ninherit(StubArray, Array.prototype);\n// Weex proto freeze protection was here,\n// but it is unclear why the hack is need as MobX never changed the prototype\n// anyway, so removed it in V6\nvar LegacyObservableArray = /*#__PURE__*/ function (_StubArray, _Symbol$toStringTag, _Symbol$iterator) {\n    _inheritsLoose(LegacyObservableArray, _StubArray);\n    function LegacyObservableArray(initialValues, enhancer, name, owned) {\n        var _this;\n        if (name === void 0) {\n            name =  true ? \"ObservableArray@\" + getNextId() : undefined;\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        _this = _StubArray.call(this) || this;\n        initObservable(function () {\n            var adm = new ObservableArrayAdministration(name, enhancer, owned, true);\n            adm.proxy_ = _assertThisInitialized(_this);\n            addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);\n            if (initialValues && initialValues.length) {\n                // @ts-ignore\n                _this.spliceWithArray(0, 0, initialValues);\n            }\n            if (safariPrototypeSetterInheritanceBug) {\n                // Seems that Safari won't use numeric prototype setter untill any * numeric property is\n                // defined on the instance. After that it works fine, even if this property is deleted.\n                Object.defineProperty(_assertThisInitialized(_this), \"0\", ENTRY_0);\n            }\n        });\n        return _this;\n    }\n    var _proto = LegacyObservableArray.prototype;\n    _proto.concat = function concat() {\n        this[$mobx].atom_.reportObserved();\n        for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n            arrays[_key] = arguments[_key];\n        }\n        return Array.prototype.concat.apply(this.slice(), \n        //@ts-ignore\n        arrays.map(function (a) {\n            return isObservableArray(a) ? a.slice() : a;\n        }));\n    };\n    _proto[_Symbol$iterator] = function () {\n        var self = this;\n        var nextIndex = 0;\n        return makeIterable({\n            next: function next() {\n                return nextIndex < self.length ? {\n                    value: self[nextIndex++],\n                    done: false\n                } : {\n                    done: true,\n                    value: undefined\n                };\n            }\n        });\n    };\n    _createClass(LegacyObservableArray, [{\n            key: \"length\",\n            get: function get() {\n                return this[$mobx].getArrayLength_();\n            },\n            set: function set(newLength) {\n                this[$mobx].setArrayLength_(newLength);\n            }\n        }, {\n            key: _Symbol$toStringTag,\n            get: function get() {\n                return \"Array\";\n            }\n        }]);\n    return LegacyObservableArray;\n}(StubArray, Symbol.toStringTag, Symbol.iterator);\nObject.entries(arrayExtensions).forEach(function (_ref) {\n    var prop = _ref[0], fn = _ref[1];\n    if (prop !== \"concat\") {\n        addHiddenProp(LegacyObservableArray.prototype, prop, fn);\n    }\n});\nfunction createArrayEntryDescriptor(index) {\n    return {\n        enumerable: false,\n        configurable: true,\n        get: function get() {\n            return this[$mobx].get_(index);\n        },\n        set: function set(value) {\n            this[$mobx].set_(index, value);\n        }\n    };\n}\nfunction createArrayBufferItem(index) {\n    defineProperty(LegacyObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index));\n}\nfunction reserveArrayBuffer(max) {\n    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {\n        for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {\n            createArrayBufferItem(index);\n        }\n        OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n    }\n}\nreserveArrayBuffer(1000);\nfunction createLegacyArray(initialValues, enhancer, name) {\n    return new LegacyObservableArray(initialValues, enhancer, name);\n}\nfunction getAtom(thing, property) {\n    if (typeof thing === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            if (property !== undefined) {\n                die(23);\n            }\n            return thing[$mobx].atom_;\n        }\n        if (isObservableSet(thing)) {\n            return thing.atom_;\n        }\n        if (isObservableMap(thing)) {\n            if (property === undefined) {\n                return thing.keysAtom_;\n            }\n            var observable = thing.data_.get(property) || thing.hasMap_.get(property);\n            if (!observable) {\n                die(25, property, getDebugName(thing));\n            }\n            return observable;\n        }\n        if (isObservableObject(thing)) {\n            if (!property) {\n                return die(26);\n            }\n            var _observable = thing[$mobx].values_.get(property);\n            if (!_observable) {\n                die(27, property, getDebugName(thing));\n            }\n            return _observable;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    }\n    else if (isFunction(thing)) {\n        if (isReaction(thing[$mobx])) {\n            // disposer function\n            return thing[$mobx];\n        }\n    }\n    die(28);\n}\nexports.getAtom = getAtom;\nfunction getAdministration(thing, property) {\n    if (!thing) {\n        die(29);\n    }\n    if (property !== undefined) {\n        return getAdministration(getAtom(thing, property));\n    }\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n        return thing;\n    }\n    if (isObservableMap(thing) || isObservableSet(thing)) {\n        return thing;\n    }\n    if (thing[$mobx]) {\n        return thing[$mobx];\n    }\n    die(24, thing);\n}\nexports._getAdministration = getAdministration;\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) {\n        named = getAtom(thing, property);\n    }\n    else if (isAction(thing)) {\n        return thing.name;\n    }\n    else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {\n        named = getAdministration(thing);\n    }\n    else {\n        // valid for arrays as well\n        named = getAtom(thing);\n    }\n    return named.name_;\n}\nexports.getDebugName = getDebugName;\n/**\n * Helper function for initializing observable structures, it applies:\n * 1. allowStateChanges so we don't violate enforceActions.\n * 2. untracked so we don't accidentaly subscribe to anything observable accessed during init in case the observable is created inside derivation.\n * 3. batch to avoid state version updates\n */\nfunction initObservable(cb) {\n    var derivation = untrackedStart();\n    var allowStateChanges = allowStateChangesStart(true);\n    startBatch();\n    try {\n        return cb();\n    }\n    finally {\n        endBatch();\n        allowStateChangesEnd(allowStateChanges);\n        untrackedEnd(derivation);\n    }\n}\nvar toString = objectPrototype.toString;\nfunction deepEqual(a, b, depth) {\n    if (depth === void 0) {\n        depth = -1;\n    }\n    return eq(a, b, depth);\n}\n// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289\n// Internal recursive comparison function for `isEqual`.\nfunction eq(a, b, depth, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) {\n        return a !== 0 || 1 / a === 1 / b;\n    }\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) {\n        return false;\n    }\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) {\n        return b !== b;\n    }\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== \"function\" && type !== \"object\" && typeof b != \"object\") {\n        return false;\n    }\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) {\n        return false;\n    }\n    switch (className) {\n        // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n        case \"[object RegExp]\":\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n        case \"[object String]\":\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return \"\" + a === \"\" + b;\n        case \"[object Number]\":\n            // `NaN`s are equivalent, but non-reflexive.\n            // Object(NaN) is equivalent to NaN.\n            if (+a !== +a) {\n                return +b !== +b;\n            }\n            // An `egal` comparison is performed for other numeric values.\n            return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n        case \"[object Date]\":\n        case \"[object Boolean]\":\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a === +b;\n        case \"[object Symbol]\":\n            return typeof Symbol !== \"undefined\" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);\n        case \"[object Map]\":\n        case \"[object Set]\":\n            // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.\n            // Hide this extra level by increasing the depth.\n            if (depth >= 0) {\n                depth++;\n            }\n            break;\n    }\n    // Unwrap any wrapped objects.\n    a = unwrap(a);\n    b = unwrap(b);\n    var areArrays = className === \"[object Array]\";\n    if (!areArrays) {\n        if (typeof a != \"object\" || typeof b != \"object\") {\n            return false;\n        }\n        // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && \"constructor\" in a && \"constructor\" in b) {\n            return false;\n        }\n    }\n    if (depth === 0) {\n        return false;\n    }\n    else if (depth < 0) {\n        depth = -1;\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] === a) {\n            return bStack[length] === b;\n        }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (length--) {\n            if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {\n                return false;\n            }\n        }\n    }\n    else {\n        // Deep compare objects.\n        var keys = Object.keys(a);\n        var key;\n        length = keys.length;\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\n        if (Object.keys(b).length !== length) {\n            return false;\n        }\n        while (length--) {\n            // Deep compare each member\n            key = keys[length];\n            if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {\n                return false;\n            }\n        }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n}\nfunction unwrap(a) {\n    if (isObservableArray(a)) {\n        return a.slice();\n    }\n    if (isES6Map(a) || isObservableMap(a)) {\n        return Array.from(a.entries());\n    }\n    if (isES6Set(a) || isObservableSet(a)) {\n        return Array.from(a.entries());\n    }\n    return a;\n}\nfunction makeIterable(iterator) {\n    iterator[Symbol.iterator] = getSelf;\n    return iterator;\n}\nfunction getSelf() {\n    return this;\n}\nfunction isAnnotation(thing) {\n    return (\n    // Can be function\n    thing instanceof Object && typeof thing.annotationType_ === \"string\" && isFunction(thing.make_) && isFunction(thing.extend_));\n}\n/**\n * (c) Michel Weststrate 2015 - 2020\n * MIT Licensed\n *\n * Welcome to the mobx sources! To get a global overview of how MobX internally works,\n * this is a good place to start:\n * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74\n *\n * Source folders:\n * ===============\n *\n * - api/     Most of the public static methods exposed by the module can be found here.\n * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.\n * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.\n * - utils/   Utility stuff.\n *\n */\n[\"Symbol\", \"Map\", \"Set\"].forEach(function (m) {\n    var g = getGlobal();\n    if (typeof g[m] === \"undefined\") {\n        die(\"MobX requires global '\" + m + \"' to be available or polyfilled\");\n    }\n});\nif (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"object\") {\n    // See: https://github.com/andykog/mobx-devtools/\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({\n        spy: spy,\n        extras: {\n            getDebugName: getDebugName\n        },\n        $mobx: $mobx\n    });\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mobx/dist/mobx.esm.js?");

/***/ }),

/***/ "./node_modules/react-chartjs-2/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-chartjs-2/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getElementsAtEvent = exports.getElementAtEvent = exports.getDatasetAtEvent = exports.Scatter = exports.Radar = exports.PolarArea = exports.Pie = exports.Line = exports.Doughnut = exports.Chart = exports.Bubble = exports.Bar = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar chart_js_1 = __webpack_require__(/*! chart.js */ \"./node_modules/chart.js/dist/chart.mjs\");\nvar defaultDatasetIdKey = 'label';\nfunction reforwardRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref) {\n        ref.current = value;\n    }\n}\nfunction setOptions(chart, nextOptions) {\n    Object.assign(chart.options, nextOptions);\n}\nfunction setLabels(currentData, nextLabels) {\n    currentData.labels = nextLabels;\n}\nfunction setDatasets(currentData, nextDatasets) {\n    var datasetIdKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultDatasetIdKey;\n    var addedDatasets = [];\n    currentData.datasets = nextDatasets.map(function (nextDataset) {\n        // given the new set, find it's current match\n        var currentDataset = currentData.datasets.find(function (dataset) { return dataset[datasetIdKey] === nextDataset[datasetIdKey]; });\n        // There is no original to update, so simply add new one\n        if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {\n            return __assign({}, nextDataset);\n        }\n        addedDatasets.push(currentDataset);\n        Object.assign(currentDataset, nextDataset);\n        return currentDataset;\n    });\n}\nfunction cloneData(data) {\n    var datasetIdKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultDatasetIdKey;\n    var nextData = {\n        labels: [],\n        datasets: []\n    };\n    setLabels(nextData, data.labels);\n    setDatasets(nextData, data.datasets, datasetIdKey);\n    return nextData;\n}\n/**\n * Get dataset from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */ function getDatasetAtEvent(chart, event) {\n    return chart.getElementsAtEventForMode(event.nativeEvent, 'dataset', {\n        intersect: true\n    }, false);\n}\nexports.getDatasetAtEvent = getDatasetAtEvent;\n/**\n * Get single dataset element from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */ function getElementAtEvent(chart, event) {\n    return chart.getElementsAtEventForMode(event.nativeEvent, 'nearest', {\n        intersect: true\n    }, false);\n}\nexports.getElementAtEvent = getElementAtEvent;\n/**\n * Get all dataset elements from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */ function getElementsAtEvent(chart, event) {\n    return chart.getElementsAtEventForMode(event.nativeEvent, 'index', {\n        intersect: true\n    }, false);\n}\nexports.getElementsAtEvent = getElementsAtEvent;\nfunction ChartComponent(param, ref) {\n    var _a = param.height, height = _a === void 0 ? 150 : _a, _b = param.width, width = _b === void 0 ? 300 : _b, _c = param.redraw, redraw = _c === void 0 ? false : _c, datasetIdKey = param.datasetIdKey, type = param.type, data = param.data, options = param.options, _d = param.plugins, plugins = _d === void 0 ? [] : _d, fallbackContent = param.fallbackContent, updateMode = param.updateMode, props = __rest(param, [\"height\", \"width\", \"redraw\", \"datasetIdKey\", \"type\", \"data\", \"options\", \"plugins\", \"fallbackContent\", \"updateMode\"]);\n    var canvasRef = (0, react_1.useRef)(null);\n    var chartRef = (0, react_1.useRef)();\n    var renderChart = function () {\n        if (!canvasRef.current)\n            return;\n        chartRef.current = new chart_js_1.Chart(canvasRef.current, {\n            type: type,\n            data: cloneData(data, datasetIdKey),\n            options: options && __assign({}, options),\n            plugins: plugins\n        });\n        reforwardRef(ref, chartRef.current);\n    };\n    var destroyChart = function () {\n        reforwardRef(ref, null);\n        if (chartRef.current) {\n            chartRef.current.destroy();\n            chartRef.current = null;\n        }\n    };\n    (0, react_1.useEffect)(function () {\n        if (!redraw && chartRef.current && options) {\n            setOptions(chartRef.current, options);\n        }\n    }, [\n        redraw,\n        options\n    ]);\n    (0, react_1.useEffect)(function () {\n        if (!redraw && chartRef.current) {\n            setLabels(chartRef.current.config.data, data.labels);\n        }\n    }, [\n        redraw,\n        data.labels\n    ]);\n    (0, react_1.useEffect)(function () {\n        if (!redraw && chartRef.current && data.datasets) {\n            setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);\n        }\n    }, [\n        redraw,\n        data.datasets\n    ]);\n    (0, react_1.useEffect)(function () {\n        if (!chartRef.current)\n            return;\n        if (redraw) {\n            destroyChart();\n            setTimeout(renderChart);\n        }\n        else {\n            chartRef.current.update(updateMode);\n        }\n    }, [\n        redraw,\n        options,\n        data.labels,\n        data.datasets,\n        updateMode\n    ]);\n    (0, react_1.useEffect)(function () {\n        if (!chartRef.current)\n            return;\n        destroyChart();\n        setTimeout(renderChart);\n    }, [\n        type\n    ]);\n    (0, react_1.useEffect)(function () {\n        renderChart();\n        return function () { return destroyChart(); };\n    }, []);\n    return ( /*#__PURE__*/react_1.default.createElement(\"canvas\", Object.assign({\n        ref: canvasRef,\n        role: \"img\",\n        height: height,\n        width: width\n    }, props), fallbackContent));\n}\nvar Chart = /*#__PURE__*/ (0, react_1.forwardRef)(ChartComponent);\nexports.Chart = Chart;\nfunction createTypedChart(type, registerables) {\n    chart_js_1.Chart.register(registerables);\n    return ( /*#__PURE__*/(0, react_1.forwardRef)(function (props, ref) { /*#__PURE__*/ return react_1.default.createElement(Chart, Object.assign({}, props, {\n        ref: ref,\n        type: type\n    })); }));\n}\nvar Line = /* #__PURE__ */ createTypedChart('line', chart_js_1.LineController);\nexports.Line = Line;\nvar Bar = /* #__PURE__ */ createTypedChart('bar', chart_js_1.BarController);\nexports.Bar = Bar;\nvar Radar = /* #__PURE__ */ createTypedChart('radar', chart_js_1.RadarController);\nexports.Radar = Radar;\nvar Doughnut = /* #__PURE__ */ createTypedChart('doughnut', chart_js_1.DoughnutController);\nexports.Doughnut = Doughnut;\nvar PolarArea = /* #__PURE__ */ createTypedChart('polarArea', chart_js_1.PolarAreaController);\nexports.PolarArea = PolarArea;\nvar Bubble = /* #__PURE__ */ createTypedChart('bubble', chart_js_1.BubbleController);\nexports.Bubble = Bubble;\nvar Pie = /* #__PURE__ */ createTypedChart('pie', chart_js_1.PieController);\nexports.Pie = Pie;\nvar Scatter = /* #__PURE__ */ createTypedChart('scatter', chart_js_1.ScatterController);\nexports.Scatter = Scatter;\n\n\n\n//# sourceURL=webpack:///./node_modules/react-chartjs-2/dist/index.js?");

/***/ }),

/***/ "./node_modules/react-fast-compare/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-fast-compare/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\nvar hasElementType = typeof Element !== 'undefined';\nfunction equal(a, b) {\n    // fast-deep-equal index.js 2.0.1\n    if (a === b)\n        return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        var arrA = isArray(a), arrB = isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!equal(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var dateA = a instanceof Date, dateB = b instanceof Date;\n        if (dateA != dateB)\n            return false;\n        if (dateA && dateB)\n            return a.getTime() == b.getTime();\n        var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;\n        if (regexpA != regexpB)\n            return false;\n        if (regexpA && regexpB)\n            return a.toString() == b.toString();\n        var keys = keyList(a);\n        length = keys.length;\n        if (length !== keyList(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!hasProp.call(b, keys[i]))\n                return false;\n        // end fast-deep-equal\n        // start react-fast-compare\n        // custom handling for DOM elements\n        if (hasElementType && a instanceof Element && b instanceof Element)\n            return a === b;\n        // custom handling for React\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (key === '_owner' && a.$$typeof) {\n                // React-specific: avoid traversing React elements' _owner.\n                //  _owner contains circular references\n                // and is not needed when comparing the actual elements (and not their owners)\n                // .$$typeof and ._store on just reasonable markers of a react element\n                continue;\n            }\n            else {\n                // all other properties should be traversed as usual\n                if (!equal(a[key], b[key]))\n                    return false;\n            }\n        }\n        // end react-fast-compare\n        // fast-deep-equal index.js 2.0.1\n        return true;\n    }\n    return a !== a && b !== b;\n}\n// end fast-deep-equal\nmodule.exports = function exportedEqual(a, b) {\n    try {\n        return equal(a, b);\n    }\n    catch (error) {\n        if ((error.message && error.message.match(/stack|recursion/i)) || (error.number === -2146828260)) {\n            // warn on circular references, don't crash\n            // browsers give this different errors name and messages:\n            // chrome/safari: \"RangeError\", \"Maximum call stack size exceeded\"\n            // firefox: \"InternalError\", too much recursion\"\n            // edge: \"Error\", \"Out of stack space\"\n            console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);\n            return false;\n        }\n        // some other error. we should definitely know about these\n        throw error;\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/react-fast-compare/index.js?");

/***/ }),

/***/ "./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useRouteLoaderData = exports.useRouteError = exports.useRevalidator = exports.useResolvedPath = exports.useParams = exports.useOutletContext = exports.useOutlet = exports.useNavigationType = exports.useNavigation = exports.useNavigate = exports.useMatches = exports.useMatch = exports.useLocation = exports.useLoaderData = exports.useInRouterContext = exports.useHref = exports.useBlocker = exports.useAsyncValue = exports.useAsyncError = exports.useActionData = exports.resolvePath = exports.renderMatches = exports.redirectDocument = exports.redirect = exports.parsePath = exports.matchRoutes = exports.matchPath = exports.json = exports.isRouteErrorResponse = exports.generatePath = exports.defer = exports.createRoutesFromElements = exports.createRoutesFromChildren = exports.createPath = exports.createMemoryRouter = exports.UNSAFE_useRouteId = exports.UNSAFE_RouteContext = exports.UNSAFE_NavigationContext = exports.UNSAFE_LocationContext = exports.UNSAFE_DataRouterStateContext = exports.UNSAFE_DataRouterContext = exports.Routes = exports.Router = exports.Route = exports.Outlet = exports.NavigationType = exports.Navigate = exports.MemoryRouter = exports.Await = exports.AbortedDeferredError = void 0;\nexports.useSubmit = exports.useSearchParams = exports.useLinkClickHandler = exports.useFormAction = exports.useFetchers = exports.useFetcher = exports.useBeforeUnload = exports.unstable_useViewTransitionState = exports.unstable_usePrompt = exports.unstable_HistoryRouter = exports.createSearchParams = exports.createHashRouter = exports.createBrowserRouter = exports.UNSAFE_useScrollRestoration = exports.UNSAFE_ViewTransitionContext = exports.UNSAFE_FetchersContext = exports.ScrollRestoration = exports.RouterProvider = exports.NavLink = exports.Link = exports.HashRouter = exports.Form = exports.BrowserRouter = exports.useRoutes = void 0;\n/**\n * React Router DOM v6.21.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar ReactDOM = __importStar(__webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\"));\nvar react_router_1 = __webpack_require__(/*! react-router */ \"./node_modules/react-router/dist/index.js\");\nvar react_router_2 = __webpack_require__(/*! react-router */ \"./node_modules/react-router/dist/index.js\");\nObject.defineProperty(exports, \"AbortedDeferredError\", { enumerable: true, get: function () { return react_router_2.AbortedDeferredError; } });\nObject.defineProperty(exports, \"Await\", { enumerable: true, get: function () { return react_router_2.Await; } });\nObject.defineProperty(exports, \"MemoryRouter\", { enumerable: true, get: function () { return react_router_2.MemoryRouter; } });\nObject.defineProperty(exports, \"Navigate\", { enumerable: true, get: function () { return react_router_2.Navigate; } });\nObject.defineProperty(exports, \"NavigationType\", { enumerable: true, get: function () { return react_router_2.NavigationType; } });\nObject.defineProperty(exports, \"Outlet\", { enumerable: true, get: function () { return react_router_2.Outlet; } });\nObject.defineProperty(exports, \"Route\", { enumerable: true, get: function () { return react_router_2.Route; } });\nObject.defineProperty(exports, \"Router\", { enumerable: true, get: function () { return react_router_2.Router; } });\nObject.defineProperty(exports, \"Routes\", { enumerable: true, get: function () { return react_router_2.Routes; } });\nObject.defineProperty(exports, \"UNSAFE_DataRouterContext\", { enumerable: true, get: function () { return react_router_2.UNSAFE_DataRouterContext; } });\nObject.defineProperty(exports, \"UNSAFE_DataRouterStateContext\", { enumerable: true, get: function () { return react_router_2.UNSAFE_DataRouterStateContext; } });\nObject.defineProperty(exports, \"UNSAFE_LocationContext\", { enumerable: true, get: function () { return react_router_2.UNSAFE_LocationContext; } });\nObject.defineProperty(exports, \"UNSAFE_NavigationContext\", { enumerable: true, get: function () { return react_router_2.UNSAFE_NavigationContext; } });\nObject.defineProperty(exports, \"UNSAFE_RouteContext\", { enumerable: true, get: function () { return react_router_2.UNSAFE_RouteContext; } });\nObject.defineProperty(exports, \"UNSAFE_useRouteId\", { enumerable: true, get: function () { return react_router_2.UNSAFE_useRouteId; } });\nObject.defineProperty(exports, \"createMemoryRouter\", { enumerable: true, get: function () { return react_router_2.createMemoryRouter; } });\nObject.defineProperty(exports, \"createPath\", { enumerable: true, get: function () { return react_router_2.createPath; } });\nObject.defineProperty(exports, \"createRoutesFromChildren\", { enumerable: true, get: function () { return react_router_2.createRoutesFromChildren; } });\nObject.defineProperty(exports, \"createRoutesFromElements\", { enumerable: true, get: function () { return react_router_2.createRoutesFromElements; } });\nObject.defineProperty(exports, \"defer\", { enumerable: true, get: function () { return react_router_2.defer; } });\nObject.defineProperty(exports, \"generatePath\", { enumerable: true, get: function () { return react_router_2.generatePath; } });\nObject.defineProperty(exports, \"isRouteErrorResponse\", { enumerable: true, get: function () { return react_router_2.isRouteErrorResponse; } });\nObject.defineProperty(exports, \"json\", { enumerable: true, get: function () { return react_router_2.json; } });\nObject.defineProperty(exports, \"matchPath\", { enumerable: true, get: function () { return react_router_2.matchPath; } });\nObject.defineProperty(exports, \"matchRoutes\", { enumerable: true, get: function () { return react_router_2.matchRoutes; } });\nObject.defineProperty(exports, \"parsePath\", { enumerable: true, get: function () { return react_router_2.parsePath; } });\nObject.defineProperty(exports, \"redirect\", { enumerable: true, get: function () { return react_router_2.redirect; } });\nObject.defineProperty(exports, \"redirectDocument\", { enumerable: true, get: function () { return react_router_2.redirectDocument; } });\nObject.defineProperty(exports, \"renderMatches\", { enumerable: true, get: function () { return react_router_2.renderMatches; } });\nObject.defineProperty(exports, \"resolvePath\", { enumerable: true, get: function () { return react_router_2.resolvePath; } });\nObject.defineProperty(exports, \"useActionData\", { enumerable: true, get: function () { return react_router_2.useActionData; } });\nObject.defineProperty(exports, \"useAsyncError\", { enumerable: true, get: function () { return react_router_2.useAsyncError; } });\nObject.defineProperty(exports, \"useAsyncValue\", { enumerable: true, get: function () { return react_router_2.useAsyncValue; } });\nObject.defineProperty(exports, \"useBlocker\", { enumerable: true, get: function () { return react_router_2.useBlocker; } });\nObject.defineProperty(exports, \"useHref\", { enumerable: true, get: function () { return react_router_2.useHref; } });\nObject.defineProperty(exports, \"useInRouterContext\", { enumerable: true, get: function () { return react_router_2.useInRouterContext; } });\nObject.defineProperty(exports, \"useLoaderData\", { enumerable: true, get: function () { return react_router_2.useLoaderData; } });\nObject.defineProperty(exports, \"useLocation\", { enumerable: true, get: function () { return react_router_2.useLocation; } });\nObject.defineProperty(exports, \"useMatch\", { enumerable: true, get: function () { return react_router_2.useMatch; } });\nObject.defineProperty(exports, \"useMatches\", { enumerable: true, get: function () { return react_router_2.useMatches; } });\nObject.defineProperty(exports, \"useNavigate\", { enumerable: true, get: function () { return react_router_2.useNavigate; } });\nObject.defineProperty(exports, \"useNavigation\", { enumerable: true, get: function () { return react_router_2.useNavigation; } });\nObject.defineProperty(exports, \"useNavigationType\", { enumerable: true, get: function () { return react_router_2.useNavigationType; } });\nObject.defineProperty(exports, \"useOutlet\", { enumerable: true, get: function () { return react_router_2.useOutlet; } });\nObject.defineProperty(exports, \"useOutletContext\", { enumerable: true, get: function () { return react_router_2.useOutletContext; } });\nObject.defineProperty(exports, \"useParams\", { enumerable: true, get: function () { return react_router_2.useParams; } });\nObject.defineProperty(exports, \"useResolvedPath\", { enumerable: true, get: function () { return react_router_2.useResolvedPath; } });\nObject.defineProperty(exports, \"useRevalidator\", { enumerable: true, get: function () { return react_router_2.useRevalidator; } });\nObject.defineProperty(exports, \"useRouteError\", { enumerable: true, get: function () { return react_router_2.useRouteError; } });\nObject.defineProperty(exports, \"useRouteLoaderData\", { enumerable: true, get: function () { return react_router_2.useRouteLoaderData; } });\nObject.defineProperty(exports, \"useRoutes\", { enumerable: true, get: function () { return react_router_2.useRoutes; } });\nvar router_1 = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null)\n        return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n            continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && (\n    // Ignore everything but left clicks\n    !target || target === \"_self\") &&\n        // Let browser handle \"target=_blank\" etc.\n        !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce(function (memo, key) {\n        var value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map(function (v) { return [key, v]; }) : [[key, value]]);\n    }, []));\n}\nexports.createSearchParams = createSearchParams;\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    var searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n        // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n        // web extensions. Relevant Bugzilla tickets:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n        defaultSearchParams.forEach(function (_, key) {\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach(function (value) {\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\n// One-time check for submitter support\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), \n            // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        }\n        catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n         true ? (0, router_1.UNSAFE_warning)(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : undefined;\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    var method;\n    var action;\n    var encType;\n    var formData;\n    var body;\n    if (isFormElement(target)) {\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        var attr = target.getAttribute(\"action\");\n        action = attr ? (0, router_1.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    }\n    else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        var form = target.form;\n        if (form == null) {\n            throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n        }\n        // <button>/<input type=\"submit\"> may override attributes of <form>\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        var attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? (0, router_1.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        // Build a FormData object populated from a form and submitter\n        formData = new FormData(form, target);\n        // If this browser doesn't support the `FormData(el, submitter)` format,\n        // then tack on the submitter value at the end.  This is a lightweight\n        // solution that is not 100% spec compliant.  For complete support in older\n        // browsers, consider using the `formdata-submitter-polyfill` package\n        if (!isFormDataSubmitterSupported()) {\n            var name_1 = target.name, type = target.type, value = target.value;\n            if (type === \"image\") {\n                var prefix = name_1 ? name_1 + \".\" : \"\";\n                formData.append(prefix + \"x\", \"0\");\n                formData.append(prefix + \"y\", \"0\");\n            }\n            else if (name_1) {\n                formData.append(name_1, value);\n            }\n        }\n    }\n    else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n    }\n    else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = undefined;\n    }\n    return {\n        action: action,\n        method: method.toLowerCase(),\n        encType: encType,\n        formData: formData,\n        body: body\n    };\n}\nvar _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"], _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"], _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\nfunction createBrowserRouter(routes, opts) {\n    return (0, router_1.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0, router_1.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes: routes,\n        mapRouteProperties: react_router_1.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nexports.createBrowserRouter = createBrowserRouter;\nfunction createHashRouter(routes, opts) {\n    return (0, router_1.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0, router_1.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes: routes,\n        mapRouteProperties: react_router_1.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nexports.createHashRouter = createHashRouter;\nfunction parseHydrationData() {\n    var _window;\n    var state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors)\n        return null;\n    var entries = Object.entries(errors);\n    var serialized = {};\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var _a = entries_1[_i], key = _a[0], val = _a[1];\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new router_1.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        }\n        else if (val && val.__type === \"Error\") {\n            // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n            if (val.__subType) {\n                var ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        // @ts-expect-error\n                        var error = new ErrorConstructor(val.message);\n                        // Wipe away the client-side stack trace.  Nothing to fill it in with\n                        // because we don't serialize SSR stack traces for security reasons\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    }\n                    catch (e) {\n                        // no-op - fall through and create a normal Error\n                    }\n                }\n            }\n            if (serialized[key] == null) {\n                var error = new Error(val.message);\n                // Wipe away the client-side stack trace.  Nothing to fill it in with\n                // because we don't serialize SSR stack traces for security reasons\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        }\n        else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nvar ViewTransitionContext = /*#__PURE__*/ React.createContext({\n    isTransitioning: false\n});\nexports.UNSAFE_ViewTransitionContext = ViewTransitionContext;\nif (true) {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n}\nvar FetchersContext = /*#__PURE__*/ React.createContext(new Map());\nexports.UNSAFE_FetchersContext = FetchersContext;\nif (true) {\n    FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nvar START_TRANSITION = \"startTransition\";\nvar startTransitionImpl = React[START_TRANSITION];\nvar FLUSH_SYNC = \"flushSync\";\nvar flushSyncImpl = ReactDOM[FLUSH_SYNC];\nvar USE_ID = \"useId\";\nvar useIdImpl = React[USE_ID];\nfunction startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n        startTransitionImpl(cb);\n    }\n    else {\n        cb();\n    }\n}\nfunction flushSyncSafe(cb) {\n    if (flushSyncImpl) {\n        flushSyncImpl(cb);\n    }\n    else {\n        cb();\n    }\n}\nvar Deferred = /** @class */ (function () {\n    function Deferred() {\n        var _this = this;\n        this.status = \"pending\";\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = function (value) {\n                if (_this.status === \"pending\") {\n                    _this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            _this.reject = function (reason) {\n                if (_this.status === \"pending\") {\n                    _this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n    return Deferred;\n}());\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n    var _this = this;\n    var fallbackElement = _ref.fallbackElement, router = _ref.router, future = _ref.future;\n    var _a = React.useState(router.state), state = _a[0], setStateImpl = _a[1];\n    var _b = React.useState(), pendingState = _b[0], setPendingState = _b[1];\n    var _c = React.useState({\n        isTransitioning: false\n    }), vtContext = _c[0], setVtContext = _c[1];\n    var _d = React.useState(), renderDfd = _d[0], setRenderDfd = _d[1];\n    var _e = React.useState(), transition = _e[0], setTransition = _e[1];\n    var _f = React.useState(), interruption = _f[0], setInterruption = _f[1];\n    var fetcherData = React.useRef(new Map());\n    var v7_startTransition = (future || {}).v7_startTransition;\n    var optInStartTransition = React.useCallback(function (cb) {\n        if (v7_startTransition) {\n            startTransitionSafe(cb);\n        }\n        else {\n            cb();\n        }\n    }, [v7_startTransition]);\n    var setState = React.useCallback(function (newState, _ref2) {\n        var deletedFetchers = _ref2.deletedFetchers, flushSync = _ref2.unstable_flushSync, viewTransitionOpts = _ref2.unstable_viewTransitionOpts;\n        deletedFetchers.forEach(function (key) { return fetcherData.current.delete(key); });\n        newState.fetchers.forEach(function (fetcher, key) {\n            if (fetcher.data !== undefined) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        var isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n        // If this isn't a view transition or it's not available in this browser,\n        // just update and be done with it\n        if (!viewTransitionOpts || isViewTransitionUnavailable) {\n            if (flushSync) {\n                flushSyncSafe(function () { return setStateImpl(newState); });\n            }\n            else {\n                optInStartTransition(function () { return setStateImpl(newState); });\n            }\n            return;\n        }\n        // flushSync + startViewTransition\n        if (flushSync) {\n            // Flush through the context to mark DOM elements as transition=ing\n            flushSyncSafe(function () {\n                // Cancel any pending transitions\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            // Update the DOM\n            var t_1 = router.window.document.startViewTransition(function () {\n                flushSyncSafe(function () { return setStateImpl(newState); });\n            });\n            // Clean up after the animation completes\n            t_1.finished.finally(function () {\n                flushSyncSafe(function () {\n                    setRenderDfd(undefined);\n                    setTransition(undefined);\n                    setPendingState(undefined);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            flushSyncSafe(function () { return setTransition(t_1); });\n            return;\n        }\n        // startTransition + startViewTransition\n        if (transition) {\n            // Interrupting an in-progress transition, cancel and let everything flush\n            // out, and then kick off a new transition from the interruption state\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n        else {\n            // Completed navigation update with opted-in view transitions, let 'er rip\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    React.useLayoutEffect(function () { return router.subscribe(setState); }, [router, setState]);\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    React.useEffect(function () {\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [vtContext]);\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    React.useEffect(function () {\n        if (renderDfd && pendingState && router.window) {\n            var newState_1 = pendingState;\n            var renderPromise_1 = renderDfd.promise;\n            var transition_1 = router.window.document.startViewTransition(function () { return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            optInStartTransition(function () { return setStateImpl(newState_1); });\n                            return [4 /*yield*/, renderPromise_1];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            }); });\n            transition_1.finished.finally(function () {\n                setRenderDfd(undefined);\n                setTransition(undefined);\n                setPendingState(undefined);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition_1);\n        }\n    }, [optInStartTransition, pendingState, renderDfd, router.window]);\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    React.useEffect(function () {\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [renderDfd, transition, state.location, pendingState]);\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    React.useEffect(function () {\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(undefined);\n        }\n    }, [vtContext.isTransitioning, interruption]);\n    React.useEffect(function () {\n         true ? (0, router_1.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : undefined;\n        // Only log this once on initial mount\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    var navigator = React.useMemo(function () {\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: function (n) { return router.navigate(n); },\n            push: function (to, state, opts) { return router.navigate(to, {\n                state: state,\n                preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n            }); },\n            replace: function (to, state, opts) { return router.navigate(to, {\n                replace: true,\n                state: state,\n                preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n            }); }\n        };\n    }, [router]);\n    var basename = router.basename || \"/\";\n    var dataRouterContext = React.useMemo(function () { return ({\n        router: router,\n        navigator: navigator,\n        static: false,\n        basename: basename\n    }); }, [router, navigator, basename]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(react_router_1.UNSAFE_DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ React.createElement(react_router_1.UNSAFE_DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ React.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /*#__PURE__*/ React.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /*#__PURE__*/ React.createElement(react_router_1.Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ React.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))))), null);\n}\nexports.RouterProvider = RouterProvider;\nfunction DataRoutes(_ref3) {\n    var routes = _ref3.routes, future = _ref3.future, state = _ref3.state;\n    return (0, react_router_1.UNSAFE_useRoutesImpl)(routes, undefined, state, future);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n    var basename = _ref4.basename, children = _ref4.children, future = _ref4.future, window = _ref4.window;\n    var historyRef = React.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0, router_1.createBrowserHistory)({\n            window: window,\n            v5Compat: true\n        });\n    }\n    var history = historyRef.current;\n    var _a = React.useState({\n        action: history.action,\n        location: history.location\n    }), state = _a[0], setStateImpl = _a[1];\n    var v7_startTransition = (future || {}).v7_startTransition;\n    var setState = React.useCallback(function (newState) {\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(function () { return setStateImpl(newState); }) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React.useLayoutEffect(function () { return history.listen(setState); }, [history, setState]);\n    return /*#__PURE__*/ React.createElement(react_router_1.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\nexports.BrowserRouter = BrowserRouter;\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n    var basename = _ref5.basename, children = _ref5.children, future = _ref5.future, window = _ref5.window;\n    var historyRef = React.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0, router_1.createHashHistory)({\n            window: window,\n            v5Compat: true\n        });\n    }\n    var history = historyRef.current;\n    var _a = React.useState({\n        action: history.action,\n        location: history.location\n    }), state = _a[0], setStateImpl = _a[1];\n    var v7_startTransition = (future || {}).v7_startTransition;\n    var setState = React.useCallback(function (newState) {\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(function () { return setStateImpl(newState); }) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React.useLayoutEffect(function () { return history.listen(setState); }, [history, setState]);\n    return /*#__PURE__*/ React.createElement(react_router_1.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\nexports.HashRouter = HashRouter;\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n    var basename = _ref6.basename, children = _ref6.children, future = _ref6.future, history = _ref6.history;\n    var _a = React.useState({\n        action: history.action,\n        location: history.location\n    }), state = _a[0], setStateImpl = _a[1];\n    var v7_startTransition = (future || {}).v7_startTransition;\n    var setState = React.useCallback(function (newState) {\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(function () { return setStateImpl(newState); }) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React.useLayoutEffect(function () { return history.listen(setState); }, [history, setState]);\n    return /*#__PURE__*/ React.createElement(react_router_1.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\nexports.unstable_HistoryRouter = HistoryRouter;\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nvar Link = /*#__PURE__*/ React.forwardRef(function LinkWithRef(_ref7, ref) {\n    var onClick = _ref7.onClick, relative = _ref7.relative, reloadDocument = _ref7.reloadDocument, replace = _ref7.replace, state = _ref7.state, target = _ref7.target, to = _ref7.to, preventScrollReset = _ref7.preventScrollReset, unstable_viewTransition = _ref7.unstable_viewTransition, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    var basename = React.useContext(react_router_1.UNSAFE_NavigationContext).basename;\n    // Rendered into <a href> for absolute URLs\n    var absoluteHref;\n    var isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to;\n        // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                var currentUrl = new URL(window.location.href);\n                var targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                var path = (0, router_1.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                }\n                else {\n                    isExternal = true;\n                }\n            }\n            catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0, router_1.UNSAFE_warning)(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : undefined;\n            }\n        }\n    }\n    // Rendered into <a href> for relative URLs\n    var href = (0, react_router_1.useHref)(to, {\n        relative: relative\n    });\n    var internalOnClick = useLinkClickHandler(to, {\n        replace: replace,\n        state: state,\n        target: target,\n        preventScrollReset: preventScrollReset,\n        relative: relative,\n        unstable_viewTransition: unstable_viewTransition\n    });\n    function handleClick(event) {\n        if (onClick)\n            onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nexports.Link = Link;\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */\nvar NavLink = /*#__PURE__*/ React.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    var _a = _ref8[\"aria-current\"], ariaCurrentProp = _a === void 0 ? \"page\" : _a, _b = _ref8.caseSensitive, caseSensitive = _b === void 0 ? false : _b, _c = _ref8.className, classNameProp = _c === void 0 ? \"\" : _c, _d = _ref8.end, end = _d === void 0 ? false : _d, styleProp = _ref8.style, to = _ref8.to, unstable_viewTransition = _ref8.unstable_viewTransition, children = _ref8.children, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    var path = (0, react_router_1.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    var location = (0, react_router_1.useLocation)();\n    var routerState = React.useContext(react_router_1.UNSAFE_DataRouterStateContext);\n    var navigator = React.useContext(react_router_1.UNSAFE_NavigationContext).navigator;\n    var isTransitioning = routerState != null &&\n        // Conditional usage is OK here because the usage of a data router is static\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useViewTransitionState(path) && unstable_viewTransition === true;\n    var toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    var locationPathname = location.pathname;\n    var nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n    // we're looking for a slash _after_ what's in `to`.  For example:\n    //\n    // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n    // both want to look for a / at index 6 to match URL `/users/matt`\n    var endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    var isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    var isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    var renderProps = {\n        isActive: isActive,\n        isPending: isPending,\n        isTransitioning: isTransitioning\n    };\n    var ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    var className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    }\n    else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n    }\n    var style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/ React.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to,\n        unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n});\nexports.NavLink = NavLink;\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nvar Form = /*#__PURE__*/ React.forwardRef(function (_ref9, forwardedRef) {\n    var fetcherKey = _ref9.fetcherKey, navigate = _ref9.navigate, reloadDocument = _ref9.reloadDocument, replace = _ref9.replace, state = _ref9.state, _a = _ref9.method, method = _a === void 0 ? defaultMethod : _a, action = _ref9.action, onSubmit = _ref9.onSubmit, relative = _ref9.relative, preventScrollReset = _ref9.preventScrollReset, unstable_viewTransition = _ref9.unstable_viewTransition, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    var submit = useSubmit();\n    var formAction = useFormAction(action, {\n        relative: relative\n    });\n    var formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    var submitHandler = function (event) {\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented)\n            return;\n        event.preventDefault();\n        var submitter = event.nativeEvent.submitter;\n        var submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey: fetcherKey,\n            method: submitMethod,\n            navigate: navigate,\n            replace: replace,\n            state: state,\n            relative: relative,\n            preventScrollReset: preventScrollReset,\n            unstable_viewTransition: unstable_viewTransition\n        });\n    };\n    return /*#__PURE__*/ React.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nexports.Form = Form;\nif (true) {\n    Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n    var getKey = _ref10.getKey, storageKey = _ref10.storageKey;\n    useScrollRestoration({\n        getKey: getKey,\n        storageKey: storageKey\n    });\n    return null;\n}\nexports.ScrollRestoration = ScrollRestoration;\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    var ctx = React.useContext(react_router_1.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0, router_1.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : undefined : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    var state = React.useContext(react_router_1.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0, router_1.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : undefined : void 0;\n    return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n    var _a = _temp === void 0 ? {} : _temp, target = _a.target, replaceProp = _a.replace, state = _a.state, preventScrollReset = _a.preventScrollReset, relative = _a.relative, unstable_viewTransition = _a.unstable_viewTransition;\n    var navigate = (0, react_router_1.useNavigate)();\n    var location = (0, react_router_1.useLocation)();\n    var path = (0, react_router_1.useResolvedPath)(to, {\n        relative: relative\n    });\n    return React.useCallback(function (event) {\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            var replace = replaceProp !== undefined ? replaceProp : (0, react_router_1.createPath)(location) === (0, react_router_1.createPath)(path);\n            navigate(to, {\n                replace: replace,\n                state: state,\n                preventScrollReset: preventScrollReset,\n                relative: relative,\n                unstable_viewTransition: unstable_viewTransition\n            });\n        }\n    }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\nexports.useLinkClickHandler = useLinkClickHandler;\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n     true ? (0, router_1.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : undefined;\n    var defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n    var hasSetSearchParamsRef = React.useRef(false);\n    var location = (0, react_router_1.useLocation)();\n    var searchParams = React.useMemo(function () {\n        // Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        return getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current);\n    }, [location.search]);\n    var navigate = (0, react_router_1.useNavigate)();\n    var setSearchParams = React.useCallback(function (nextInit, navigateOptions) {\n        var newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [navigate, searchParams]);\n    return [searchParams, setSearchParams];\n}\nexports.useSearchParams = useSearchParams;\nfunction validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n        throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = function () { return \"__\" + String(++fetcherId) + \"__\"; };\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n    var router = useDataRouterContext(DataRouterHook.UseSubmit).router;\n    var basename = React.useContext(react_router_1.UNSAFE_NavigationContext).basename;\n    var currentRouteId = (0, react_router_1.UNSAFE_useRouteId)();\n    return React.useCallback(function (target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        validateClientSideSubmission();\n        var _a = getFormSubmissionInfo(target, basename), action = _a.action, method = _a.method, encType = _a.encType, formData = _a.formData, body = _a.body;\n        if (options.navigate === false) {\n            var key = options.fetcherKey || getUniqueFetcherId();\n            router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData: formData,\n                body: body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                unstable_flushSync: options.unstable_flushSync\n            });\n        }\n        else {\n            router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData: formData,\n                body: body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                unstable_flushSync: options.unstable_flushSync,\n                unstable_viewTransition: options.unstable_viewTransition\n            });\n        }\n    }, [router, basename, currentRouteId]);\n}\nexports.useSubmit = useSubmit;\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    var relative = (_temp2 === void 0 ? {} : _temp2).relative;\n    var basename = React.useContext(react_router_1.UNSAFE_NavigationContext).basename;\n    var routeContext = React.useContext(react_router_1.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0, router_1.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : undefined : void 0;\n    var match = routeContext.matches.slice(-1)[0];\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    var path = _extends({}, (0, react_router_1.useResolvedPath)(action ? action : \".\", {\n        relative: relative\n    }));\n    // If no action was specified, browsers will persist current search params\n    // when determining the path, so match that behavior\n    // https://github.com/remix-run/remix/issues/927\n    var location = (0, react_router_1.useLocation)();\n    if (action == null) {\n        // Safe to write to this directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        path.search = location.search;\n        // When grabbing search params from the URL, remove any included ?index param\n        // since it might not apply to our contextual route.  We add it back based\n        // on match.route.index below\n        var params = new URLSearchParams(path.search);\n        if (params.has(\"index\") && params.get(\"index\") === \"\") {\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0, router_1.joinPaths)([basename, path.pathname]);\n    }\n    return (0, react_router_1.createPath)(path);\n}\nexports.useFormAction = useFormAction;\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n    var _route$matches;\n    var key = (_temp3 === void 0 ? {} : _temp3).key;\n    var router = useDataRouterContext(DataRouterHook.UseFetcher).router;\n    var state = useDataRouterState(DataRouterStateHook.UseFetcher);\n    var fetcherData = React.useContext(FetchersContext);\n    var route = React.useContext(react_router_1.UNSAFE_RouteContext);\n    var routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !fetcherData ?  true ? (0, router_1.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : undefined : void 0;\n    !route ?  true ? (0, router_1.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : undefined : void 0;\n    !(routeId != null) ?  true ? (0, router_1.UNSAFE_invariant)(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : undefined : void 0;\n    // Fetcher key handling\n    // OK to call conditionally to feature detect `useId`\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    var defaultKey = useIdImpl ? useIdImpl() : \"\";\n    var _a = React.useState(key || defaultKey), fetcherKey = _a[0], setFetcherKey = _a[1];\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    }\n    else if (!fetcherKey) {\n        // We will only fall through here when `useId` is not available\n        setFetcherKey(getUniqueFetcherId());\n    }\n    // Registration/cleanup\n    React.useEffect(function () {\n        router.getFetcher(fetcherKey);\n        return function () {\n            // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n            // will not delete immediately but instead queue up a delete after the\n            // fetcher returns to an `idle` state\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [router, fetcherKey]);\n    // Fetcher additions\n    var load = React.useCallback(function (href, opts) {\n        !routeId ?  true ? (0, router_1.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : undefined : void 0;\n        router.fetch(fetcherKey, routeId, href, opts);\n    }, [fetcherKey, routeId, router]);\n    var submitImpl = useSubmit();\n    var submit = React.useCallback(function (target, opts) {\n        submitImpl(target, _extends({}, opts, {\n            navigate: false,\n            fetcherKey: fetcherKey\n        }));\n    }, [fetcherKey, submitImpl]);\n    var FetcherForm = React.useMemo(function () {\n        var FetcherForm = /*#__PURE__*/ React.forwardRef(function (props, ref) {\n            return /*#__PURE__*/ React.createElement(Form, _extends({}, props, {\n                navigate: false,\n                fetcherKey: fetcherKey,\n                ref: ref\n            }));\n        });\n        if (true) {\n            FetcherForm.displayName = \"fetcher.Form\";\n        }\n        return FetcherForm;\n    }, [fetcherKey]);\n    // Exposed FetcherWithComponents\n    var fetcher = state.fetchers.get(fetcherKey) || router_1.IDLE_FETCHER;\n    var data = fetcherData.get(fetcherKey);\n    var fetcherWithComponents = React.useMemo(function () { return _extends({\n        Form: FetcherForm,\n        submit: submit,\n        load: load\n    }, fetcher, {\n        data: data\n    }); }, [FetcherForm, submit, load, fetcher, data]);\n    return fetcherWithComponents;\n}\nexports.useFetcher = useFetcher;\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n    var state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return Array.from(state.fetchers.entries()).map(function (_ref11) {\n        var key = _ref11[0], fetcher = _ref11[1];\n        return _extends({}, fetcher, {\n            key: key\n        });\n    });\n}\nexports.useFetchers = useFetchers;\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n    var _a = _temp4 === void 0 ? {} : _temp4, getKey = _a.getKey, storageKey = _a.storageKey;\n    var router = useDataRouterContext(DataRouterHook.UseScrollRestoration).router;\n    var _b = useDataRouterState(DataRouterStateHook.UseScrollRestoration), restoreScrollPosition = _b.restoreScrollPosition, preventScrollReset = _b.preventScrollReset;\n    var basename = React.useContext(react_router_1.UNSAFE_NavigationContext).basename;\n    var location = (0, react_router_1.useLocation)();\n    var matches = (0, react_router_1.useMatches)();\n    var navigation = (0, react_router_1.useNavigation)();\n    // Trigger manual scroll restoration while we're active\n    React.useEffect(function () {\n        window.history.scrollRestoration = \"manual\";\n        return function () {\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    // Save positions on pagehide\n    usePageHide(React.useCallback(function () {\n        if (navigation.state === \"idle\") {\n            var key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        }\n        catch (error) {\n             true ? (0, router_1.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : undefined;\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [storageKey, getKey, navigation.state, location, matches]));\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useLayoutEffect(function () {\n            try {\n                var sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            }\n            catch (e) {\n                // no-op, use default empty object\n            }\n        }, [storageKey]);\n        // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useLayoutEffect(function () {\n            var getKeyWithoutBasename = getKey && basename !== \"/\" ? function (location, matches) { return getKey(// Strip the basename to match useLocation()\n            _extends({}, location, {\n                pathname: (0, router_1.stripBasename)(location.pathname, basename) || location.pathname\n            }), matches); } : getKey;\n            var disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, function () { return window.scrollY; }, getKeyWithoutBasename);\n            return function () { return disableScrollRestoration && disableScrollRestoration(); };\n        }, [router, basename, getKey]);\n        // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useLayoutEffect(function () {\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            // try to scroll to the hash\n            if (location.hash) {\n                var el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            }\n            // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [location, restoreScrollPosition, preventScrollReset]);\n    }\n}\nexports.UNSAFE_useScrollRestoration = useScrollRestoration;\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n    var capture = (options || {}).capture;\n    React.useEffect(function () {\n        var opts = capture != null ? {\n            capture: capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return function () {\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [callback, capture]);\n}\nexports.useBeforeUnload = useBeforeUnload;\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n    var capture = (options || {}).capture;\n    React.useEffect(function () {\n        var opts = capture != null ? {\n            capture: capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return function () {\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n    var when = _ref12.when, message = _ref12.message;\n    var blocker = (0, react_router_1.useBlocker)(when);\n    React.useEffect(function () {\n        if (blocker.state === \"blocked\") {\n            var proceed = window.confirm(message);\n            if (proceed) {\n                // This timeout is needed to avoid a weird \"race\" on POP navigations\n                // between the `window.history` revert navigation and the result of\n                // `window.confirm`\n                setTimeout(blocker.proceed, 0);\n            }\n            else {\n                blocker.reset();\n            }\n        }\n    }, [blocker, message]);\n    React.useEffect(function () {\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [blocker, when]);\n}\nexports.unstable_usePrompt = usePrompt;\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */\nfunction useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    var vtContext = React.useContext(ViewTransitionContext);\n    !(vtContext != null) ?  true ? (0, router_1.UNSAFE_invariant)(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : undefined : void 0;\n    var basename = useDataRouterContext(DataRouterHook.useViewTransitionState).basename;\n    var path = (0, react_router_1.useResolvedPath)(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    var currentPath = (0, router_1.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    var nextPath = (0, router_1.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return (0, router_1.matchPath)(path.pathname, nextPath) != null || (0, router_1.matchPath)(path.pathname, currentPath) != null;\n}\nexports.unstable_useViewTransitionState = useViewTransitionState;\n\n\n\n//# sourceURL=webpack:///./node_modules/react-router-dom/dist/index.js?");

/***/ }),

/***/ "./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useResolvedPath = exports.useParams = exports.useOutletContext = exports.useOutlet = exports.useNavigationType = exports.useNavigation = exports.useNavigate = exports.useMatches = exports.useMatch = exports.useLocation = exports.useLoaderData = exports.useInRouterContext = exports.useHref = exports.useBlocker = exports.useAsyncValue = exports.useAsyncError = exports.useActionData = exports.renderMatches = exports.createRoutesFromElements = exports.createRoutesFromChildren = exports.createMemoryRouter = exports.UNSAFE_useRoutesImpl = exports.UNSAFE_useRouteId = exports.UNSAFE_mapRouteProperties = exports.UNSAFE_RouteContext = exports.UNSAFE_NavigationContext = exports.UNSAFE_LocationContext = exports.UNSAFE_DataRouterStateContext = exports.UNSAFE_DataRouterContext = exports.Routes = exports.RouterProvider = exports.Router = exports.Route = exports.Outlet = exports.Navigate = exports.MemoryRouter = exports.Await = exports.resolvePath = exports.redirectDocument = exports.redirect = exports.parsePath = exports.matchRoutes = exports.matchPath = exports.json = exports.isRouteErrorResponse = exports.generatePath = exports.defer = exports.createPath = exports.NavigationType = exports.AbortedDeferredError = void 0;\nexports.useRoutes = exports.useRouteLoaderData = exports.useRouteError = exports.useRevalidator = void 0;\n/**\n * React Router v6.21.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar router_1 = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\nvar router_2 = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\nObject.defineProperty(exports, \"AbortedDeferredError\", { enumerable: true, get: function () { return router_2.AbortedDeferredError; } });\nObject.defineProperty(exports, \"NavigationType\", { enumerable: true, get: function () { return router_2.Action; } });\nObject.defineProperty(exports, \"createPath\", { enumerable: true, get: function () { return router_2.createPath; } });\nObject.defineProperty(exports, \"defer\", { enumerable: true, get: function () { return router_2.defer; } });\nObject.defineProperty(exports, \"generatePath\", { enumerable: true, get: function () { return router_2.generatePath; } });\nObject.defineProperty(exports, \"isRouteErrorResponse\", { enumerable: true, get: function () { return router_2.isRouteErrorResponse; } });\nObject.defineProperty(exports, \"json\", { enumerable: true, get: function () { return router_2.json; } });\nObject.defineProperty(exports, \"matchPath\", { enumerable: true, get: function () { return router_2.matchPath; } });\nObject.defineProperty(exports, \"matchRoutes\", { enumerable: true, get: function () { return router_2.matchRoutes; } });\nObject.defineProperty(exports, \"parsePath\", { enumerable: true, get: function () { return router_2.parsePath; } });\nObject.defineProperty(exports, \"redirect\", { enumerable: true, get: function () { return router_2.redirect; } });\nObject.defineProperty(exports, \"redirectDocument\", { enumerable: true, get: function () { return router_2.redirectDocument; } });\nObject.defineProperty(exports, \"resolvePath\", { enumerable: true, get: function () { return router_2.resolvePath; } });\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nvar DataRouterContext = /*#__PURE__*/ React.createContext(null);\nexports.UNSAFE_DataRouterContext = DataRouterContext;\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nvar DataRouterStateContext = /*#__PURE__*/ React.createContext(null);\nexports.UNSAFE_DataRouterStateContext = DataRouterStateContext;\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nvar AwaitContext = /*#__PURE__*/ React.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nvar NavigationContext = /*#__PURE__*/ React.createContext(null);\nexports.UNSAFE_NavigationContext = NavigationContext;\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nvar LocationContext = /*#__PURE__*/ React.createContext(null);\nexports.UNSAFE_LocationContext = LocationContext;\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nvar RouteContext = /*#__PURE__*/ React.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nexports.UNSAFE_RouteContext = RouteContext;\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nvar RouteErrorContext = /*#__PURE__*/ React.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n    var relative = (_temp === void 0 ? {} : _temp).relative;\n    !useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : undefined : void 0;\n    var _a = React.useContext(NavigationContext), basename = _a.basename, navigator = _a.navigator;\n    var _b = useResolvedPath(to, {\n        relative: relative\n    }), hash = _b.hash, pathname = _b.pathname, search = _b.search;\n    var joinedPathname = pathname;\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0, router_1.joinPaths)([basename, pathname]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search: search,\n        hash: hash\n    });\n}\nexports.useHref = useHref;\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n    return React.useContext(LocationContext) != null;\n}\nexports.useInRouterContext = useInRouterContext;\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n    !useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : undefined : void 0;\n    return React.useContext(LocationContext).location;\n}\nexports.useLocation = useLocation;\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n    return React.useContext(LocationContext).navigationType;\n}\nexports.useNavigationType = useNavigationType;\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n    !useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : undefined : void 0;\n    var pathname = useLocation().pathname;\n    return React.useMemo(function () { return (0, router_1.matchPath)(pattern, pathname); }, [pathname, pattern]);\n}\nexports.useMatch = useMatch;\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nvar navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n    var isStatic = React.useContext(NavigationContext).static;\n    if (!isStatic) {\n        // We should be able to get rid of this once react 18.3 is released\n        // See: https://github.com/facebook/react/pull/26395\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useLayoutEffect(cb);\n    }\n}\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n    var isDataRoute = React.useContext(RouteContext).isDataRoute;\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nexports.useNavigate = useNavigate;\nfunction useNavigateUnstable() {\n    !useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : undefined : void 0;\n    var dataRouterContext = React.useContext(DataRouterContext);\n    var _a = React.useContext(NavigationContext), basename = _a.basename, future = _a.future, navigator = _a.navigator;\n    var matches = React.useContext(RouteContext).matches;\n    var locationPathname = useLocation().pathname;\n    var routePathnamesJson = JSON.stringify((0, router_1.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    var activeRef = React.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        activeRef.current = true;\n    });\n    var navigate = React.useCallback(function (to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0, router_1.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : undefined;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current)\n            return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        var path = (0, router_1.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0, router_1.joinPaths)([basename, path.pathname]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n    return navigate;\n}\nvar OutletContext = /*#__PURE__*/ React.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n    return React.useContext(OutletContext);\n}\nexports.useOutletContext = useOutletContext;\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n    var outlet = React.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ React.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\nexports.useOutlet = useOutlet;\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n    var matches = React.useContext(RouteContext).matches;\n    var routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\nexports.useParams = useParams;\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n    var relative = (_temp2 === void 0 ? {} : _temp2).relative;\n    var future = React.useContext(NavigationContext).future;\n    var matches = React.useContext(RouteContext).matches;\n    var locationPathname = useLocation().pathname;\n    var routePathnamesJson = JSON.stringify((0, router_1.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    return React.useMemo(function () { return (0, router_1.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"); }, [to, routePathnamesJson, locationPathname, relative]);\n}\nexports.useResolvedPath = useResolvedPath;\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\nexports.useRoutes = useRoutes;\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    !useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : undefined : void 0;\n    var navigator = React.useContext(NavigationContext).navigator;\n    var parentMatches = React.useContext(RouteContext).matches;\n    var routeMatch = parentMatches[parentMatches.length - 1];\n    var parentParams = routeMatch ? routeMatch.params : {};\n    var parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    var parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    var parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        var parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n    }\n    var locationFromContext = useLocation();\n    var location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        var parsedLocationArg = typeof locationArg === \"string\" ? (0, router_1.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0, router_1.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : undefined : void 0;\n        location = parsedLocationArg;\n    }\n    else {\n        location = locationFromContext;\n    }\n    var pathname = location.pathname || \"/\";\n    var remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    var matches = (0, router_1.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0, router_1.UNSAFE_warning)(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : undefined;\n         true ? (0, router_1.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : undefined;\n    }\n    var renderedMatches = _renderMatches(matches && matches.map(function (match) { return Object.assign({}, match, {\n        params: Object.assign({}, parentParams, match.params),\n        pathname: (0, router_1.joinPaths)([parentPathnameBase,\n            // Re-encode pathnames that were decoded inside matchRoutes\n            navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n        pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0, router_1.joinPaths)([parentPathnameBase,\n            // Re-encode pathnames that were decoded inside matchRoutes\n            navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n    }); }), parentMatches, dataRouterState, future);\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n        return /*#__PURE__*/ React.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: router_1.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nexports.UNSAFE_useRoutesImpl = useRoutesImpl;\nfunction DefaultErrorComponent() {\n    var error = useRouteError();\n    var message = (0, router_1.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    var stack = error instanceof Error ? error.stack : null;\n    var lightgrey = \"rgba(200,200,200, 0.5)\";\n    var preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    var codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    var devInfo = null;\n    if (true) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/ React.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/ React.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ React.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ React.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /*#__PURE__*/ React.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = /** @class */ (function (_super) {\n    __extends(RenderErrorBoundary, _super);\n    function RenderErrorBoundary(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n        return _this;\n    }\n    RenderErrorBoundary.getDerivedStateFromError = function (error) {\n        return {\n            error: error\n        };\n    };\n    RenderErrorBoundary.getDerivedStateFromProps = function (props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error !== undefined ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    };\n    RenderErrorBoundary.prototype.componentDidCatch = function (error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    };\n    RenderErrorBoundary.prototype.render = function () {\n        return this.state.error !== undefined ? /*#__PURE__*/ React.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ React.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    };\n    return RenderErrorBoundary;\n}(React.Component));\nfunction RenderedRoute(_ref) {\n    var routeContext = _ref.routeContext, match = _ref.match, children = _ref.children;\n    var dataRouterContext = React.useContext(DataRouterContext);\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ React.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n        dataRouterState = null;\n    }\n    if (future === void 0) {\n        future = null;\n    }\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        }\n        else {\n            return null;\n        }\n    }\n    var renderedMatches = matches;\n    // If we have data errors, trim matches to the highest error boundary\n    var errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        var errorIndex = renderedMatches.findIndex(function (m) { return m.route.id && (errors == null ? void 0 : errors[m.route.id]); });\n        !(errorIndex >= 0) ?  true ? (0, router_1.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : undefined : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    // If we're in a partial hydration mode, detect if we need to render down to\n    // a given HydrateFallback while we load the rest of the hydration data\n    var renderFallback = false;\n    var fallbackIndex = -1;\n    if (dataRouterState && future && future.v7_partialHydration) {\n        for (var i = 0; i < renderedMatches.length; i++) {\n            var match = renderedMatches[i];\n            // Track the deepest fallback up until the first route without data\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                var loaderData = dataRouterState.loaderData, errors_1 = dataRouterState.errors;\n                var needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors_1 || errors_1[match.route.id] === undefined);\n                if (match.route.lazy || needsToRunLoader) {\n                    // We found the first route that's not ready to render (waiting on\n                    // lazy, or has a loader that hasn't run yet).  Flag that we need to\n                    // render a fallback and render up until the appropriate fallback\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    }\n                    else {\n                        renderedMatches = [renderedMatches[0]];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight(function (outlet, match, index) {\n        // Only data routers handle errors/fallbacks\n        var error;\n        var shouldRenderHydrateFallback = false;\n        var errorElement = null;\n        var hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : undefined;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                }\n                else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        var matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        var getChildren = function () {\n            var children;\n            if (error) {\n                children = errorElement;\n            }\n            else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            }\n            else if (match.route.Component) {\n                // Note: This is a de-optimized path since React won't re-use the\n                // ReactElement since it's identity changes with each new\n                // React.createElement call.  We keep this so folks can use\n                // `<Route Component={...}>` in `<Routes>` but generally `Component`\n                // usage is only advised in `RouterProvider` when we can convert it to\n                // `element` ahead of time.\n                children = /*#__PURE__*/ React.createElement(match.route.Component, null);\n            }\n            else if (match.route.element) {\n                children = match.route.element;\n            }\n            else {\n                children = outlet;\n            }\n            return /*#__PURE__*/ React.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet: outlet,\n                    matches: matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        };\n        // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ React.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches: matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook = /*#__PURE__*/ function (DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/ function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    var ctx = React.useContext(DataRouterContext);\n    !ctx ?  true ? (0, router_1.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : undefined : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    var state = React.useContext(DataRouterStateContext);\n    !state ?  true ? (0, router_1.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : undefined : void 0;\n    return state;\n}\nfunction useRouteContext(hookName) {\n    var route = React.useContext(RouteContext);\n    !route ?  true ? (0, router_1.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : undefined : void 0;\n    return route;\n}\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n    var route = useRouteContext(hookName);\n    var thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0, router_1.UNSAFE_invariant)(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : undefined : void 0;\n    return thisRoute.route.id;\n}\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\nexports.UNSAFE_useRouteId = useRouteId;\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n    var state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\nexports.useNavigation = useNavigation;\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n    var dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    var state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return React.useMemo(function () { return ({\n        revalidate: dataRouterContext.router.revalidate,\n        state: state.revalidation\n    }); }, [dataRouterContext.router.revalidate, state.revalidation]);\n}\nexports.useRevalidator = useRevalidator;\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n    var _a = useDataRouterState(DataRouterStateHook.UseMatches), matches = _a.matches, loaderData = _a.loaderData;\n    return React.useMemo(function () { return matches.map(function (m) { return (0, router_1.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData); }); }, [matches, loaderData]);\n}\nexports.useMatches = useMatches;\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n    var state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    var routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\nexports.useLoaderData = useLoaderData;\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n    var state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\nexports.useRouteLoaderData = useRouteLoaderData;\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n    var state = useDataRouterState(DataRouterStateHook.UseActionData);\n    var routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n}\nexports.useActionData = useActionData;\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n    var _state$errors;\n    var error = React.useContext(RouteErrorContext);\n    var state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    var routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error !== undefined) {\n        return error;\n    }\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\nexports.useRouteError = useRouteError;\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */\nfunction useAsyncValue() {\n    var value = React.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\nexports.useAsyncValue = useAsyncValue;\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */\nfunction useAsyncError() {\n    var value = React.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nexports.useAsyncError = useAsyncError;\nvar blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n    var _a = useDataRouterContext(DataRouterHook.UseBlocker), router = _a.router, basename = _a.basename;\n    var state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    var _b = React.useState(\"\"), blockerKey = _b[0], setBlockerKey = _b[1];\n    var blockerFunction = React.useCallback(function (arg) {\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        // If they provided us a function and we've got an active basename, strip\n        // it from the locations we expose to the user to match the behavior of\n        // useLocation\n        var currentLocation = arg.currentLocation, nextLocation = arg.nextLocation, historyAction = arg.historyAction;\n        return shouldBlock({\n            currentLocation: _extends({}, currentLocation, {\n                pathname: (0, router_1.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n            }),\n            nextLocation: _extends({}, nextLocation, {\n                pathname: (0, router_1.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n            }),\n            historyAction: historyAction\n        });\n    }, [basename, shouldBlock]);\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    React.useEffect(function () {\n        var key = String(++blockerId);\n        setBlockerKey(key);\n        return function () { return router.deleteBlocker(key); };\n    }, [router]);\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    React.useEffect(function () {\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [router, blockerKey, blockerFunction]);\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : router_1.IDLE_BLOCKER;\n}\nexports.useBlocker = useBlocker;\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n    var router = useDataRouterContext(DataRouterHook.UseNavigateStable).router;\n    var id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    var activeRef = React.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        activeRef.current = true;\n    });\n    var navigate = React.useCallback(function (to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0, router_1.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : undefined;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current)\n            return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        }\n        else {\n            router.navigate(to, _extends({\n                fromRouteId: id\n            }, options));\n        }\n    }, [router, id]);\n    return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0, router_1.UNSAFE_warning)(false, message) : undefined;\n    }\n}\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nvar START_TRANSITION = \"startTransition\";\nvar startTransitionImpl = React[START_TRANSITION];\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n    var fallbackElement = _ref.fallbackElement, router = _ref.router, future = _ref.future;\n    var _a = React.useState(router.state), state = _a[0], setStateImpl = _a[1];\n    var v7_startTransition = (future || {}).v7_startTransition;\n    var setState = React.useCallback(function (newState) {\n        if (v7_startTransition && startTransitionImpl) {\n            startTransitionImpl(function () { return setStateImpl(newState); });\n        }\n        else {\n            setStateImpl(newState);\n        }\n    }, [setStateImpl, v7_startTransition]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    React.useLayoutEffect(function () { return router.subscribe(setState); }, [router, setState]);\n    React.useEffect(function () {\n         true ? (0, router_1.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : undefined;\n        // Only log this once on initial mount\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    var navigator = React.useMemo(function () {\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: function (n) { return router.navigate(n); },\n            push: function (to, state, opts) { return router.navigate(to, {\n                state: state,\n                preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n            }); },\n            replace: function (to, state, opts) { return router.navigate(to, {\n                replace: true,\n                state: state,\n                preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n            }); }\n        };\n    }, [router]);\n    var basename = router.basename || \"/\";\n    var dataRouterContext = React.useMemo(function () { return ({\n        router: router,\n        navigator: navigator,\n        static: false,\n        basename: basename\n    }); }, [router, navigator, basename]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ React.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ React.createElement(Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ React.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))), null);\n}\nexports.RouterProvider = RouterProvider;\nfunction DataRoutes(_ref2) {\n    var routes = _ref2.routes, future = _ref2.future, state = _ref2.state;\n    return useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n    var basename = _ref3.basename, children = _ref3.children, initialEntries = _ref3.initialEntries, initialIndex = _ref3.initialIndex, future = _ref3.future;\n    var historyRef = React.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0, router_1.createMemoryHistory)({\n            initialEntries: initialEntries,\n            initialIndex: initialIndex,\n            v5Compat: true\n        });\n    }\n    var history = historyRef.current;\n    var _a = React.useState({\n        action: history.action,\n        location: history.location\n    }), state = _a[0], setStateImpl = _a[1];\n    var v7_startTransition = (future || {}).v7_startTransition;\n    var setState = React.useCallback(function (newState) {\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(function () { return setStateImpl(newState); }) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React.useLayoutEffect(function () { return history.listen(setState); }, [history, setState]);\n    return /*#__PURE__*/ React.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\nexports.MemoryRouter = MemoryRouter;\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n    var to = _ref4.to, replace = _ref4.replace, state = _ref4.state, relative = _ref4.relative;\n    !useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : undefined : void 0;\n    var _a = React.useContext(NavigationContext), future = _a.future, isStatic = _a.static;\n     true ? (0, router_1.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : undefined;\n    var matches = React.useContext(RouteContext).matches;\n    var locationPathname = useLocation().pathname;\n    var navigate = useNavigate();\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    var path = (0, router_1.resolveTo)(to, (0, router_1.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n    var jsonPath = JSON.stringify(path);\n    React.useEffect(function () { return navigate(JSON.parse(jsonPath), {\n        replace: replace,\n        state: state,\n        relative: relative\n    }); }, [navigate, jsonPath, relative, replace, state]);\n    return null;\n}\nexports.Navigate = Navigate;\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n    return useOutlet(props.context);\n}\nexports.Outlet = Outlet;\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n     true ? (0, router_1.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : undefined;\n}\nexports.Route = Route;\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n    var _a = _ref5.basename, basenameProp = _a === void 0 ? \"/\" : _a, _b = _ref5.children, children = _b === void 0 ? null : _b, locationProp = _ref5.location, _c = _ref5.navigationType, navigationType = _c === void 0 ? router_1.Action.Pop : _c, navigator = _ref5.navigator, _d = _ref5.static, staticProp = _d === void 0 ? false : _d, future = _ref5.future;\n    !!useInRouterContext() ?  true ? (0, router_1.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : undefined : void 0;\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    var basename = basenameProp.replace(/^\\/*/, \"/\");\n    var navigationContext = React.useMemo(function () { return ({\n        basename: basename,\n        navigator: navigator,\n        static: staticProp,\n        future: _extends({\n            v7_relativeSplatPath: false\n        }, future)\n    }); }, [basename, future, navigator, staticProp]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0, router_1.parsePath)(locationProp);\n    }\n    var _e = locationProp.pathname, pathname = _e === void 0 ? \"/\" : _e, _f = locationProp.search, search = _f === void 0 ? \"\" : _f, _g = locationProp.hash, hash = _g === void 0 ? \"\" : _g, _h = locationProp.state, state = _h === void 0 ? null : _h, _j = locationProp.key, key = _j === void 0 ? \"default\" : _j;\n    var locationContext = React.useMemo(function () {\n        var trailingPathname = (0, router_1.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search: search,\n                hash: hash,\n                state: state,\n                key: key\n            },\n            navigationType: navigationType\n        };\n    }, [basename, pathname, search, hash, state, key, navigationType]);\n     true ? (0, router_1.UNSAFE_warning)(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : undefined;\n    if (locationContext == null) {\n        return null;\n    }\n    return /*#__PURE__*/ React.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ React.createElement(LocationContext.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\nexports.Router = Router;\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n    var children = _ref6.children, location = _ref6.location;\n    return useRoutes(createRoutesFromChildren(children), location);\n}\nexports.Routes = Routes;\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n    var children = _ref7.children, errorElement = _ref7.errorElement, resolve = _ref7.resolve;\n    return /*#__PURE__*/ React.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ React.createElement(ResolveAwait, null, children));\n}\nexports.Await = Await;\nvar AwaitRenderStatus = /*#__PURE__*/ function (AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nvar neverSettledPromise = new Promise(function () { });\nvar AwaitErrorBoundary = /** @class */ (function (_super) {\n    __extends(AwaitErrorBoundary, _super);\n    function AwaitErrorBoundary(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            error: null\n        };\n        return _this;\n    }\n    AwaitErrorBoundary.getDerivedStateFromError = function (error) {\n        return {\n            error: error\n        };\n    };\n    AwaitErrorBoundary.prototype.componentDidCatch = function (error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    };\n    AwaitErrorBoundary.prototype.render = function () {\n        var _a = this.props, children = _a.children, errorElement = _a.errorElement, resolve = _a.resolve;\n        var promise = null;\n        var status = AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: function () { return true; }\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: function () { return resolve; }\n            });\n        }\n        else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = AwaitRenderStatus.error;\n            var renderError_1 = this.state.error;\n            promise = Promise.reject().catch(function () { }); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: function () { return true; }\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: function () { return renderError_1; }\n            });\n        }\n        else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n        }\n        else {\n            // Raw (untracked) promise - track it\n            status = AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: function () { return true; }\n            });\n            promise = resolve.then(function (data) { return Object.defineProperty(resolve, \"_data\", {\n                get: function () { return data; }\n            }); }, function (error) { return Object.defineProperty(resolve, \"_error\", {\n                get: function () { return error; }\n            }); });\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof router_1.AbortedDeferredError) {\n            // Freeze the UI by throwing a never resolved promise\n            throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n            // No errorElement, throw to the nearest route-level error boundary\n            throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n            // Render via our errorElement\n            return /*#__PURE__*/ React.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === AwaitRenderStatus.success) {\n            // Render children with resolved value\n            return /*#__PURE__*/ React.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: children\n            });\n        }\n        // Throw to the suspense boundary\n        throw promise;\n    };\n    return AwaitErrorBoundary;\n}(React.Component));\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */\nfunction ResolveAwait(_ref8) {\n    var children = _ref8.children;\n    var data = useAsyncValue();\n    var toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ React.createElement(React.Fragment, null, toRender);\n}\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    var routes = [];\n    React.Children.forEach(children, function (element, index) {\n        if (!React.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        var treePath = __spreadArray(__spreadArray([], parentPath, true), [index], false);\n        if (element.type === React.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0, router_1.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : undefined : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0, router_1.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : undefined : void 0;\n        var route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\nexports.createRoutesFromChildren = createRoutesFromChildren;\nexports.createRoutesFromElements = createRoutesFromChildren;\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n    return _renderMatches(matches);\n}\nexports.renderMatches = renderMatches;\nfunction mapRouteProperties(route) {\n    var updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (true) {\n            if (route.element) {\n                 true ? (0, router_1.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : undefined;\n            }\n        }\n        Object.assign(updates, {\n            element: /*#__PURE__*/ React.createElement(route.Component),\n            Component: undefined\n        });\n    }\n    if (route.HydrateFallback) {\n        if (true) {\n            if (route.hydrateFallbackElement) {\n                 true ? (0, router_1.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : undefined;\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: /*#__PURE__*/ React.createElement(route.HydrateFallback),\n            HydrateFallback: undefined\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (true) {\n            if (route.errorElement) {\n                 true ? (0, router_1.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : undefined;\n            }\n        }\n        Object.assign(updates, {\n            errorElement: /*#__PURE__*/ React.createElement(route.ErrorBoundary),\n            ErrorBoundary: undefined\n        });\n    }\n    return updates;\n}\nexports.UNSAFE_mapRouteProperties = mapRouteProperties;\nfunction createMemoryRouter(routes, opts) {\n    return (0, router_1.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0, router_1.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes: routes,\n        mapRouteProperties: mapRouteProperties\n    }).initialize();\n}\nexports.createMemoryRouter = createMemoryRouter;\n\n\n\n//# sourceURL=webpack:///./node_modules/react-router/dist/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isProduction = \"development\" === 'production';\nfunction warning(condition, message) {\n    if (!isProduction) {\n        if (condition) {\n            return;\n        }\n        var text = \"Warning: \" + message;\n        if (typeof console !== 'undefined') {\n            console.warn(text);\n        }\n        try {\n            throw Error(text);\n        }\n        catch (x) { }\n    }\n}\nexports.default = warning;\n\n\n//# sourceURL=webpack:///./node_modules/tiny-warning/dist/tiny-warning.esm.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar g;\n// This works in non-strict mode\ng = (function () {\n    return this;\n})();\ntry {\n    // This works if eval is allowed (see CSP)\n    g = g || new Function(\"return this\")();\n}\ncatch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\")\n        g = window;\n}\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/Data.js":
/*!*********************!*\
  !*** ./src/Data.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserData = void 0;\nexports.UserData = [\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 25,\n        day: 'Mon',\n    },\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 480,\n        day: 'Tue',\n    },\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 56,\n        day: 'Wed',\n    },\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 12,\n        day: 'Thr',\n    },\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 90,\n        day: 'Fri',\n    },\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 60,\n        day: 'Sat',\n    },\n    {\n        id: Math.floor(Math.random() * 900000) + 100000,\n        time: 0,\n        day: 'Sun',\n    },\n];\n\n\n//# sourceURL=webpack:///./src/Data.js?");

/***/ }),

/***/ "./src/actions/file.js":
/*!*****************************!*\
  !*** ./src/actions/file.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createFiles = exports.getFiles = void 0;\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"./node_modules/axios/index.js\"));\nvar fileReducer_1 = __webpack_require__(/*! ../reducers/fileReducer */ \"./src/reducers/fileReducer.js\");\nfunction getFiles(dirId) {\n    var _this = this;\n    return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {\n        var response, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, axios_1.default.get(\"http://localhost:5000/api/files\".concat(dirId ? '?parent=' + dirId : ''), {\n                            headers: { Authorization: \"Bearer \".concat(localStorage.getItem('token')) }\n                        })];\n                case 1:\n                    response = _a.sent();\n                    dispatch((0, fileReducer_1.setFiles)(response.data));\n                    return [3 /*break*/, 3];\n                case 2:\n                    e_1 = _a.sent();\n                    console.error(e_1);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n}\nexports.getFiles = getFiles;\nfunction createFiles(dirId, name) {\n    var _this = this;\n    return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {\n        var response, e_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, axios_1.default.post(\"http://localhost:5000/api/files\", {\n                            name: name,\n                            parent: dirId,\n                            type: 'file'\n                        }, {\n                            headers: { Authorization: \"Bearer \".concat(localStorage.getItem('token')) }\n                        })];\n                case 1:\n                    response = _a.sent();\n                    dispatch(addFiles(response.data));\n                    return [3 /*break*/, 3];\n                case 2:\n                    e_2 = _a.sent();\n                    console.error(e_2);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n}\nexports.createFiles = createFiles;\n\n\n//# sourceURL=webpack:///./src/actions/file.js?");

/***/ }),

/***/ "./src/actions/user.js":
/*!*****************************!*\
  !*** ./src/actions/user.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.auth = exports.login = exports.registration = void 0;\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"./node_modules/axios/index.js\"));\nvar userReducer_1 = __webpack_require__(/*! ../reducers/userReducer */ \"./src/reducers/userReducer.js\");\nvar registration = function (name, surname, email, password) {\n    return function (dispatch) { return __awaiter(void 0, void 0, void 0, function () {\n        var response, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, axios_1.default.post(\"http://localhost:5000/api/auth/registration\", {\n                            name: name,\n                            surname: surname,\n                            email: email,\n                            password: password\n                        })];\n                case 1:\n                    response = _a.sent();\n                    dispatch((0, userReducer_1.signUp)(true));\n                    return [2 /*return*/, { success: true, message: response.data.message }];\n                case 2:\n                    e_1 = _a.sent();\n                    return [2 /*return*/, { success: false, message: e_1.response.data.message }];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\nexports.registration = registration;\nvar login = function (email, password) {\n    return function (dispatch) { return __awaiter(void 0, void 0, void 0, function () {\n        var response, error, e_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, axios_1.default.post(\"http://localhost:5000/api/auth/login\", {\n                            email: email,\n                            password: password\n                        })];\n                case 1:\n                    response = _a.sent();\n                    if (response.status === 200) {\n                        dispatch((0, userReducer_1.setUser)(response.data.user));\n                        localStorage.setItem('token', response.data.token);\n                        return [2 /*return*/, { success: true, message: 'Вход выполнен успешно' }];\n                    }\n                    else {\n                        error = response.statusText;\n                        return [2 /*return*/, { success: false, message: error }];\n                    }\n                    return [3 /*break*/, 3];\n                case 2:\n                    e_2 = _a.sent();\n                    return [2 /*return*/, { success: false, message: e_2.response.data.message }];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\nexports.login = login;\nvar auth = function () {\n    return function (dispatch) { return __awaiter(void 0, void 0, void 0, function () {\n        var response, e_3;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, axios_1.default.get(\"http://localhost:5000/api/auth/auth\", { headers: { Authorization: \"Bearer \".concat(localStorage.getItem('token')) } })];\n                case 1:\n                    response = _a.sent();\n                    dispatch((0, userReducer_1.setUser)(response.data.user));\n                    localStorage.setItem('token', response.data.token);\n                    return [3 /*break*/, 3];\n                case 2:\n                    e_3 = _a.sent();\n                    localStorage.removeItem('token');\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\nexports.auth = auth;\n\n\n//# sourceURL=webpack:///./src/actions/user.js?");

/***/ }),

/***/ "./src/client/index.jsx":
/*!******************************!*\
  !*** ./src/client/index.jsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar ReactDom = __importStar(__webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\"));\nvar App_1 = __webpack_require__(/*! ../shared/App */ \"./src/shared/App.tsx\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar reducers_1 = __webpack_require__(/*! ../reducers */ \"./src/reducers/index.js\");\nvar reportWebVitals_1 = __importDefault(__webpack_require__(/*! ../reportWebVitals */ \"./src/reportWebVitals.js\"));\nwindow.addEventListener('load', function () {\n    ReactDom.hydrate(React.createElement(react_redux_1.Provider, { store: reducers_1.store },\n        React.createElement(App_1.App, null)), document.getElementById(\"react_root\"));\n});\n(0, reportWebVitals_1.default)();\n\n\n//# sourceURL=webpack:///./src/client/index.jsx?");

/***/ }),

/***/ "./src/context/dataContext.js":
/*!************************************!*\
  !*** ./src/context/dataContext.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useData = exports.DataProvider = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar Data_1 = __webpack_require__(/*! ../Data */ \"./src/Data.js\");\nvar DataContext = (0, react_1.createContext)();\nfunction DataProvider(_a) {\n    var children = _a.children;\n    var _b = (0, react_1.useState)(Data_1.UserData), userData = _b[0], setUserData = _b[1];\n    return (react_1.default.createElement(DataContext.Provider, { value: { userData: userData } }, children));\n}\nexports.DataProvider = DataProvider;\nfunction useData() {\n    var context = (0, react_1.useContext)(DataContext);\n    if (!context) {\n        throw new Error('useData must be used within a DataProvider');\n    }\n    return context;\n}\nexports.useData = useData;\n\n\n//# sourceURL=webpack:///./src/context/dataContext.js?");

/***/ }),

/***/ "./src/main.global.css":
/*!*****************************!*\
  !*** ./src/main.global.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./main.global.css */ \"./node_modules/css-loader/dist/cjs.js!./src/main.global.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../node_modules/css-loader/dist/cjs.js!./main.global.css */ \"./node_modules/css-loader/dist/cjs.js!./src/main.global.css\",\n      function () {\n        content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./main.global.css */ \"./node_modules/css-loader/dist/cjs.js!./src/main.global.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/main.global.css?");

/***/ }),

/***/ "./src/shared sync recursive":
false,

/***/ "./src/shared/App.tsx":
/*!****************************!*\
  !*** ./src/shared/App.tsx ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.App = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar styles = __importStar(__webpack_require__(/*! ../main.global.css */ \"./src/main.global.css\"));\nvar react_router_dom_1 = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/dist/index.js\");\nvar Header_1 = __webpack_require__(/*! ./Header */ \"./src/shared/Header/index.ts\");\nvar root_1 = __webpack_require__(/*! react-hot-loader/root */ \"./node_modules/react-hot-loader/root.js\");\nvar Content_1 = __webpack_require__(/*! ./Content */ \"./src/shared/Content/index.ts\");\nvar Registration_1 = __webpack_require__(/*! ./Registration */ \"./src/shared/Registration/index.ts\");\nvar Login_1 = __webpack_require__(/*! ./Login */ \"./src/shared/Login/index.ts\");\nvar Statistics_1 = __webpack_require__(/*! ./Statistics */ \"./src/shared/Statistics/index.ts\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar index_1 = __webpack_require__(/*! ../reducers/index */ \"./src/reducers/index.js\");\nvar user_1 = __webpack_require__(/*! ../actions/user */ \"./src/actions/user.js\");\nvar Placeholder_1 = __webpack_require__(/*! ./Placeholder */ \"./src/shared/Placeholder/index.ts\");\nvar dataContext_1 = __webpack_require__(/*! ../context/dataContext */ \"./src/context/dataContext.js\");\nvar errorBoundary_1 = __importDefault(__webpack_require__(/*! ./errorBoundary */ \"./src/shared/errorBoundary.js\"));\nfunction AppComponent() {\n    var isAuth = (0, react_redux_1.useSelector)(function (state) { return state.user.isAuth; });\n    var signedUp = (0, react_redux_1.useSelector)(function (state) { return state.user.signedUp; });\n    var dispatch = (0, react_redux_1.useDispatch)();\n    var _a = (0, react_1.useState)(false), mounted = _a[0], setMounted = _a[1];\n    (0, react_1.useEffect)(function () {\n        dispatch((0, user_1.auth)());\n        dispatch((0, user_1.registration)());\n        setMounted(true);\n    }, []);\n    return (react_1.default.createElement(react_redux_1.Provider, { store: index_1.store }, mounted && (react_1.default.createElement(react_router_dom_1.MemoryRouter, null,\n        react_1.default.createElement(\"div\", { className: styles.App },\n            react_1.default.createElement(Header_1.Header, { ContainerStyle: styles.MainContainer }),\n            !isAuth &&\n                react_1.default.createElement(react_router_dom_1.Routes, null,\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/main\", element: react_1.default.createElement(Placeholder_1.Placeholder, null) }),\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/registration\", element: react_1.default.createElement(Registration_1.Registration, null) }),\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/login\", element: react_1.default.createElement(Login_1.Login, null) }),\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/*\", element: react_1.default.createElement(Placeholder_1.Placeholder, null) })),\n            isAuth &&\n                react_1.default.createElement(react_router_dom_1.Routes, null,\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/main\", element: react_1.default.createElement(Content_1.Content, null) }),\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/statistics\", element: react_1.default.createElement(dataContext_1.DataProvider, null,\n                            react_1.default.createElement(Statistics_1.Statistics, null)) }),\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/*\", element: react_1.default.createElement(Content_1.Content, null) })),\n            signedUp &&\n                react_1.default.createElement(react_router_dom_1.Routes, null,\n                    react_1.default.createElement(react_router_dom_1.Route, { path: \"/registration\", element: react_1.default.createElement(react_router_dom_1.Navigate, { to: \"/login\" }) })))))));\n}\nexports.App = (0, root_1.hot)(function () {\n    return react_1.default.createElement(errorBoundary_1.default, null,\n        react_1.default.createElement(react_redux_1.Provider, { store: index_1.store },\n            react_1.default.createElement(AppComponent, null)));\n});\n\n\n//# sourceURL=webpack:///./src/shared/App.tsx?");

/***/ }),

/***/ "./src/shared/Content/Content.tsx":
/*!****************************************!*\
  !*** ./src/shared/Content/Content.tsx ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Content = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar content_css_1 = __importDefault(__webpack_require__(/*! ./content.css */ \"./src/shared/Content/content.css\"));\nvar InfoList_1 = __webpack_require__(/*! ./leftSide/InfoList */ \"./src/shared/Content/leftSide/InfoList/index.ts\");\nvar ToDoForm_1 = __webpack_require__(/*! ./leftSide/ToDoForm */ \"./src/shared/Content/leftSide/ToDoForm/index.ts\");\nvar ToDoList_1 = __webpack_require__(/*! ./leftSide/ToDoList */ \"./src/shared/Content/leftSide/ToDoList/index.ts\");\nvar Timer_1 = __webpack_require__(/*! ./rightSide/Timer */ \"./src/shared/Content/rightSide/Timer/index.ts\");\nvar ToDoContainer_1 = __webpack_require__(/*! ./rightSide/ToDoContainer */ \"./src/shared/Content/rightSide/ToDoContainer/index.ts\");\nfunction Content() {\n    return (react_1.default.createElement(\"div\", { className: content_css_1.default.MainContainer },\n        react_1.default.createElement(\"div\", { className: content_css_1.default.ContentContainer },\n            react_1.default.createElement(\"div\", { className: content_css_1.default.LeftContainer },\n                react_1.default.createElement(InfoList_1.InfoList, null),\n                react_1.default.createElement(ToDoForm_1.ToDoForm, null),\n                react_1.default.createElement(ToDoList_1.ToDoList, null)),\n            react_1.default.createElement(\"div\", { className: content_css_1.default.RightContainer },\n                react_1.default.createElement(ToDoContainer_1.ToDoContainer, null),\n                react_1.default.createElement(Timer_1.Timer, null)))));\n}\nexports.Content = Content;\n\n\n//# sourceURL=webpack:///./src/shared/Content/Content.tsx?");

/***/ }),

/***/ "./src/shared/Content/content.css":
/*!****************************************!*\
  !*** ./src/shared/Content/content.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./content.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/content.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./content.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/content.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./content.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/content.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/content.css?");

/***/ }),

/***/ "./src/shared/Content/index.ts":
/*!*************************************!*\
  !*** ./src/shared/Content/index.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Content */ \"./src/shared/Content/Content.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/index.ts?");

/***/ }),

/***/ "./src/shared/Content/leftSide/InfoList/InfoList.tsx":
/*!***********************************************************!*\
  !*** ./src/shared/Content/leftSide/InfoList/InfoList.tsx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InfoList = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar infolist_css_1 = __importDefault(__webpack_require__(/*! ./infolist.css */ \"./src/shared/Content/leftSide/InfoList/infolist.css\"));\nfunction InfoList() {\n    return (react_1.default.createElement(\"div\", { className: infolist_css_1.default.ToDoList },\n        react_1.default.createElement(\"h2\", { className: infolist_css_1.default.ContentTitle }, \"\\u0423\\u0440\\u0430! \\u0422\\u0435\\u043F\\u0435\\u0440\\u044C \\u043C\\u043E\\u0436\\u043D\\u043E \\u043D\\u0430\\u0447\\u0430\\u0442\\u044C \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C:\"),\n        react_1.default.createElement(\"ul\", { className: infolist_css_1.default.ContentList },\n            react_1.default.createElement(\"li\", { className: infolist_css_1.default.ContentListItem },\n                react_1.default.createElement(\"div\", { className: infolist_css_1.default.ListItemDist }),\n                \"\\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u043A\\u0430\\u0442\\u0435\\u0433\\u043E\\u0440\\u0438\\u044E \\u0438 \\u043D\\u0430\\u043F\\u0438\\u0448\\u0438\\u0442\\u0435 \\u043D\\u0430\\u0437\\u0432\\u0430\\u043D\\u0438\\u0435 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0439 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438\"),\n            react_1.default.createElement(\"li\", { className: infolist_css_1.default.ContentListItem },\n                react_1.default.createElement(\"div\", { className: infolist_css_1.default.ListItemDist }),\n                \"\\u0417\\u0430\\u043F\\u0443\\u0441\\u0442\\u0438\\u0442\\u0435 \\u0442\\u0430\\u0439\\u043C\\u0435\\u0440 (\\u00AB\\u043F\\u043E\\u043C\\u0438\\u0434\\u043E\\u0440\\u00BB)\"),\n            react_1.default.createElement(\"li\", { className: infolist_css_1.default.ContentListItem },\n                react_1.default.createElement(\"div\", { className: infolist_css_1.default.ListItemDist }),\n                \"\\u0420\\u0430\\u0431\\u043E\\u0442\\u0430\\u0439\\u0442\\u0435 \\u043F\\u043E\\u043A\\u0430 \\u00AB\\u043F\\u043E\\u043C\\u0438\\u0434\\u043E\\u0440\\u00BB \\u043D\\u0435 \\u043F\\u0440\\u043E\\u0437\\u0432\\u043E\\u043D\\u0438\\u0442\"),\n            react_1.default.createElement(\"li\", { className: infolist_css_1.default.ContentListItem },\n                react_1.default.createElement(\"div\", { className: infolist_css_1.default.ListItemDist }),\n                \"\\u0421\\u0434\\u0435\\u043B\\u0430\\u0439\\u0442\\u0435 \\u043A\\u043E\\u0440\\u043E\\u0442\\u043A\\u0438\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0440\\u044B\\u0432 (3-5 \\u043C\\u0438\\u043D\\u0443\\u0442)\"),\n            react_1.default.createElement(\"li\", { className: infolist_css_1.default.ContentListItem },\n                react_1.default.createElement(\"div\", { className: infolist_css_1.default.ListItemDist }),\n                \"\\u041F\\u0440\\u043E\\u0434\\u043E\\u043B\\u0436\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u00AB\\u043F\\u043E\\u043C\\u0438\\u0434\\u043E\\u0440\\u00BB \\u0437\\u0430 \\u00AB\\u043F\\u043E\\u043C\\u0438\\u0434\\u043E\\u0440\\u043E\\u043C\\u00BB, \\u043F\\u043E\\u043A\\u0430 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0430 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0443\\u0442 \\u0432\\u044B\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u0430. \\u041A\\u0430\\u0436\\u0434\\u044B\\u0435 4 \\u00AB\\u043F\\u043E\\u043C\\u0438\\u0434\\u043E\\u0440\\u0430\\u00BB \\u0434\\u0435\\u043B\\u0430\\u0439\\u0442\\u0435 \\u0434\\u043B\\u0438\\u043D\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0440\\u044B\\u0432 (15-30 \\u043C\\u0438\\u043D\\u0443\\u0442).\"))));\n}\nexports.InfoList = InfoList;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/InfoList/InfoList.tsx?");

/***/ }),

/***/ "./src/shared/Content/leftSide/InfoList/index.ts":
/*!*******************************************************!*\
  !*** ./src/shared/Content/leftSide/InfoList/index.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./InfoList */ \"./src/shared/Content/leftSide/InfoList/InfoList.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/InfoList/index.ts?");

/***/ }),

/***/ "./src/shared/Content/leftSide/InfoList/infolist.css":
/*!***********************************************************!*\
  !*** ./src/shared/Content/leftSide/InfoList/infolist.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./infolist.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/InfoList/infolist.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./infolist.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/InfoList/infolist.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./infolist.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/InfoList/infolist.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/InfoList/infolist.css?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoForm/ToDoForm.tsx":
/*!***********************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoForm/ToDoForm.tsx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToDoForm = exports.myStore = exports.form = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar formik_1 = __webpack_require__(/*! formik */ \"./node_modules/formik/dist/formik.esm.js\");\nvar todoform_css_1 = __importDefault(__webpack_require__(/*! ./todoform.css */ \"./src/shared/Content/leftSide/ToDoForm/todoform.css\"));\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar mobx_react_lite_1 = __webpack_require__(/*! mobx-react-lite */ \"./node_modules/mobx-react-lite/es/index.js\");\nvar file_1 = __webpack_require__(/*! ../../../../actions/file */ \"./src/actions/file.js\");\nvar form = /** @class */ (function () {\n    function form() {\n        this.value = '';\n        (0, mobx_1.makeAutoObservable)(this);\n    }\n    form.prototype.updateValue = function (newValue) {\n        this.value = newValue;\n    };\n    return form;\n}());\nexports.form = form;\nvar store = /** @class */ (function () {\n    function store() {\n        this.item = {\n            value: String\n        };\n    }\n    return store;\n}());\nexports.myStore = new form;\nexports.ToDoForm = (0, mobx_react_lite_1.observer)(function () {\n    var dispatch = (0, react_redux_1.useDispatch)();\n    var ref = (0, react_1.useRef)(null);\n    var currentDir = (0, react_redux_1.useSelector)(function (state) { return state.files.currentDir; });\n    function createHandler(dir, name) {\n        dispatch((0, file_1.createFiles)(dir, name));\n    }\n    return (react_1.default.createElement(\"div\", { ref: ref },\n        react_1.default.createElement(formik_1.Formik, { initialValues: {\n                text: exports.myStore.value\n            }, onSubmit: function (values) { return __awaiter(void 0, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    exports.myStore.updateValue(values.text);\n                    createHandler(currentDir, exports.myStore.value);\n                    return [2 /*return*/];\n                });\n            }); } },\n            react_1.default.createElement(formik_1.Form, { className: todoform_css_1.default.Form },\n                react_1.default.createElement(formik_1.Field, { as: 'textarea', name: 'text', className: todoform_css_1.default.FormInput, placeholder: \"Название задачи\" }),\n                react_1.default.createElement(\"button\", { type: \"submit\", className: todoform_css_1.default.FormSubmit }, \"\\u0414\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C\")))));\n});\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoForm/ToDoForm.tsx?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoForm/index.ts":
/*!*******************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoForm/index.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ToDoForm */ \"./src/shared/Content/leftSide/ToDoForm/ToDoForm.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoForm/index.ts?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoForm/todoform.css":
/*!***********************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoForm/todoform.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todoform.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoForm/todoform.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todoform.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoForm/todoform.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todoform.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoForm/todoform.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoForm/todoform.css?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoList/ToDoList.tsx":
/*!***********************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoList/ToDoList.tsx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToDoList = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar todolist_css_1 = __importDefault(__webpack_require__(/*! ./todolist.css */ \"./src/shared/Content/leftSide/ToDoList/todolist.css\"));\nvar ToDoTitle_1 = __webpack_require__(/*! ./ToDoTitle */ \"./src/shared/Content/leftSide/ToDoList/ToDoTitle/index.ts\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar file_1 = __webpack_require__(/*! ../../../../actions/file */ \"./src/actions/file.js\");\nfunction ToDoList() {\n    var dispatch = (0, react_redux_1.useDispatch)();\n    var currentDir = (0, react_redux_1.useSelector)(function (state) { return state.files.currentDir; });\n    (0, react_1.useEffect)(function () {\n        dispatch((0, file_1.getFiles)(currentDir));\n    }, [currentDir]);\n    var item = (0, react_redux_1.useSelector)(function (state) { return state.files.files; });\n    return (react_1.default.createElement(\"div\", { className: todolist_css_1.default.ToDoListContainer },\n        react_1.default.createElement(\"ul\", { className: todolist_css_1.default.ToDoList }, item.map(function (a, index) { return (react_1.default.createElement(ToDoTitle_1.ToDoTitle, { key: index, title: a.name })); })),\n        react_1.default.createElement(\"div\", { className: todolist_css_1.default.TimeSummary }, \"1 \\u0447\\u0430\\u0441 15 \\u043C\\u0438\\u043D\\u0443\\u0442\")));\n}\nexports.ToDoList = ToDoList;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/ToDoList.tsx?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoList/ToDoTitle/ToDoTitle.tsx":
/*!**********************************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoList/ToDoTitle/ToDoTitle.tsx ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToDoTitle = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar todotitle_css_1 = __importDefault(__webpack_require__(/*! ./todotitle.css */ \"./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css\"));\nfunction ToDoTitle(_a) {\n    var title = _a.title;\n    return (react_1.default.createElement(\"li\", { className: todotitle_css_1.default.TitleContainer },\n        react_1.default.createElement(\"h2\", { className: todotitle_css_1.default.Title }, title)));\n}\nexports.ToDoTitle = ToDoTitle;\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/ToDoTitle/ToDoTitle.tsx?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoList/ToDoTitle/index.ts":
/*!*****************************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoList/ToDoTitle/index.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ToDoTitle */ \"./src/shared/Content/leftSide/ToDoList/ToDoTitle/ToDoTitle.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/ToDoTitle/index.ts?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css":
/*!**********************************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotitle.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotitle.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotitle.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/ToDoTitle/todotitle.css?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoList/index.ts":
/*!*******************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoList/index.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ToDoList */ \"./src/shared/Content/leftSide/ToDoList/ToDoList.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/index.ts?");

/***/ }),

/***/ "./src/shared/Content/leftSide/ToDoList/todolist.css":
/*!***********************************************************!*\
  !*** ./src/shared/Content/leftSide/ToDoList/todolist.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todolist.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/todolist.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todolist.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/todolist.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todolist.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/leftSide/ToDoList/todolist.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/leftSide/ToDoList/todolist.css?");

/***/ }),

/***/ "./src/shared/Content/rightSide/Timer/Timer.tsx":
/*!******************************************************!*\
  !*** ./src/shared/Content/rightSide/Timer/Timer.tsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Timer = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar timer_css_1 = __importDefault(__webpack_require__(/*! ./timer.css */ \"./src/shared/Content/rightSide/Timer/timer.css\"));\nvar ToDoTask_1 = __webpack_require__(/*! ../ToDoContainer/ToDoTask */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts\");\nfunction Timer() {\n    var _a = (0, react_1.useState)(0.25), initialMinutes = _a[0], setInitialMinutes = _a[1];\n    var _b = (0, react_1.useState)(initialMinutes * 60), initialWorkTime = _b[0], setInitialWorkTime = _b[1];\n    var _c = (0, react_1.useState)(0.25 * 60), initialPauseTime = _c[0], setInitialPauseTime = _c[1];\n    var _d = (0, react_1.useState)(initialWorkTime), seconds = _d[0], setSeconds = _d[1];\n    var _e = (0, react_1.useState)(false), isActive = _e[0], setIsActive = _e[1];\n    var _f = (0, react_1.useState)(false), isCompleted = _f[0], setIsCompleted = _f[1];\n    var _g = (0, react_1.useState)('work'), timerToggle = _g[0], setTimerToggle = _g[1];\n    (0, react_1.useEffect)(function () {\n        setInitialWorkTime(initialMinutes * 60);\n        setSeconds(initialMinutes * 60);\n    }, [initialMinutes]);\n    (0, react_1.useEffect)(function () {\n        if (isActive) {\n            var intervalId_1 = setInterval(function () {\n                setSeconds(function (prevSeconds) { return prevSeconds - 1; });\n            }, 1000);\n            return function () { return clearInterval(intervalId_1); };\n        }\n    }, [isActive]);\n    (0, react_1.useEffect)(function () {\n        if (seconds === 0 && timerToggle === 'work') {\n            setIsActive(false);\n            setIsCompleted(true);\n            setTimeout(function () {\n                setTimerToggle('pause');\n                setSeconds(initialPauseTime);\n                setIsCompleted(false);\n                setIsActive(true);\n            }, 3000);\n        }\n        else if (seconds === 0 && timerToggle === 'pause') {\n            setIsActive(false);\n            setTimeout(function () {\n                setIsCompleted(true);\n                setTimeout(function () {\n                    setTimerToggle('work');\n                    setSeconds(initialWorkTime);\n                    setIsCompleted(false);\n                    setIsActive(true);\n                }, 3000);\n            }, 4000);\n        }\n    }, [seconds, timerToggle, initialPauseTime, initialWorkTime]);\n    function plusMinutes() {\n        requestAnimationFrame(function () {\n            setInitialMinutes(function (prevMinutes) { return prevMinutes + 1; });\n            var newInitialMinutes = initialMinutes + 1;\n            setInitialWorkTime(newInitialMinutes * 60);\n            setSeconds(newInitialMinutes * 60);\n        });\n    }\n    function handlePlusMinutesClick() {\n        plusMinutes();\n    }\n    var toggleTimer = function () {\n        setIsActive(!isActive);\n    };\n    var resetTimer = function () {\n        setIsActive(false);\n        setIsCompleted(false);\n        setSeconds(initialWorkTime);\n    };\n    var formatTime = function (time) {\n        var minutes = Math.floor(time / 60);\n        var remainingSeconds = time % 60;\n        return \"\".concat(minutes, \":\").concat(remainingSeconds < 10 ? '0' : '').concat(remainingSeconds);\n    };\n    return (react_1.default.createElement(\"div\", { className: timer_css_1.default.Timer },\n        react_1.default.createElement(\"div\", { className: timer_css_1.default.TimerCountContainer },\n            react_1.default.createElement(\"div\", { className: timer_css_1.default.TimerCount },\n                formatTime(seconds),\n                react_1.default.createElement(\"button\", { className: timer_css_1.default.TimerButton, onClick: handlePlusMinutesClick },\n                    react_1.default.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"50\", height: \"50\", viewBox: \"0 0 50 50\", fill: \"none\" },\n                        react_1.default.createElement(\"circle\", { cx: \"25\", cy: \"25\", r: \"25\", fill: \"#C4C4C4\" }),\n                        react_1.default.createElement(\"path\", { d: \"M26.2756 26.1321V33H23.7244V26.1321H17V23.7029H23.7244V17H26.2756V23.7029H33V26.1321H26.2756Z\", fill: \"white\" }))),\n                react_1.default.createElement(\"div\", { className: timer_css_1.default.TaskWrapper },\n                    react_1.default.createElement(\"span\", { className: timer_css_1.default.TaskNumber }, \"\\u0417\\u0430\\u0434\\u0430\\u0447\\u0430 1 -\"),\n                    react_1.default.createElement(ToDoTask_1.ToDoTask, null))),\n            react_1.default.createElement(\"div\", { className: timer_css_1.default.buttonWrapper },\n                react_1.default.createElement(\"button\", { className: timer_css_1.default.StartButton, onClick: toggleTimer }, isActive ? 'Пауза' : 'Старт'),\n                react_1.default.createElement(\"button\", { className: timer_css_1.default.StopButton, onClick: resetTimer }, \"\\u0421\\u0442\\u043E\\u043F\")))));\n}\nexports.Timer = Timer;\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/Timer/Timer.tsx?");

/***/ }),

/***/ "./src/shared/Content/rightSide/Timer/index.ts":
/*!*****************************************************!*\
  !*** ./src/shared/Content/rightSide/Timer/index.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Timer */ \"./src/shared/Content/rightSide/Timer/Timer.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/Timer/index.ts?");

/***/ }),

/***/ "./src/shared/Content/rightSide/Timer/timer.css":
/*!******************************************************!*\
  !*** ./src/shared/Content/rightSide/Timer/timer.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./timer.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/Timer/timer.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./timer.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/Timer/timer.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./timer.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/Timer/timer.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/Timer/timer.css?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoContainer.tsx":
/*!**********************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoContainer.tsx ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToDoContainer = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar todocontainer_css_1 = __importDefault(__webpack_require__(/*! ./todocontainer.css */ \"./src/shared/Content/rightSide/ToDoContainer/todocontainer.css\"));\nvar ToDoTask_1 = __webpack_require__(/*! ./ToDoTask */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts\");\nfunction ToDoContainer() {\n    return (react_1.default.createElement(\"div\", { className: todocontainer_css_1.default.ToDoContainer },\n        react_1.default.createElement(\"div\", { className: todocontainer_css_1.default.ToDoTaskWrapper },\n            react_1.default.createElement(ToDoTask_1.ToDoTask, null),\n            react_1.default.createElement(\"span\", { className: todocontainer_css_1.default.PomodoroNumber }, \"\\u041F\\u043E\\u043C\\u0438\\u0434\\u043E\\u0440 1\"))));\n}\nexports.ToDoContainer = ToDoContainer;\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoContainer.tsx?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx":
/*!**************************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToDoTask = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar mobx_react_1 = __webpack_require__(/*! mobx-react */ \"./node_modules/mobx-react/dist/mobxreact.esm.js\");\nvar todotask_css_1 = __importDefault(__webpack_require__(/*! ./todotask.css */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\"));\nvar ToDoForm_1 = __webpack_require__(/*! ../../../leftSide/ToDoForm */ \"./src/shared/Content/leftSide/ToDoForm/index.ts\");\nexports.ToDoTask = (0, mobx_react_1.observer)(function () {\n    return (react_1.default.createElement(\"div\", { className: todotask_css_1.default.ToDoTask }, ToDoForm_1.myStore.value));\n});\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts":
/*!**********************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ToDoTask */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css":
/*!**************************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotask.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotask.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotask.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/index.ts":
/*!*************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/index.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ToDoContainer */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoContainer.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/index.ts?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/todocontainer.css":
/*!**********************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/todocontainer.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todocontainer.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/todocontainer.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todocontainer.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/todocontainer.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todocontainer.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/todocontainer.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/todocontainer.css?");

/***/ }),

/***/ "./src/shared/Header/Header.tsx":
/*!**************************************!*\
  !*** ./src/shared/Header/Header.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Header = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar header_css_1 = __importDefault(__webpack_require__(/*! ./header.css */ \"./src/shared/Header/header.css\"));\nvar react_router_dom_1 = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/dist/index.js\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar userReducer_1 = __webpack_require__(/*! ../../reducers/userReducer */ \"./src/reducers/userReducer.js\");\nfunction Header(_a) {\n    var ContainerStyle = _a.ContainerStyle;\n    var isAuth = (0, react_redux_1.useSelector)(function (state) { return state.user.isAuth; });\n    var userData = (0, react_redux_1.useSelector)(function (data) { return data.user.currentUser; });\n    var dispatch = (0, react_redux_1.useDispatch)();\n    var handleSignedUp = function () {\n        dispatch((0, userReducer_1.signUp)(false));\n    };\n    return (react_1.default.createElement(\"header\", { className: header_css_1.default.Header },\n        react_1.default.createElement(\"div\", { className: header_css_1.default.MainContainer },\n            react_1.default.createElement(\"div\", { className: header_css_1.default.HeaderContainer },\n                react_1.default.createElement(react_router_dom_1.NavLink, { to: '/main' },\n                    react_1.default.createElement(\"div\", { className: header_css_1.default.LogoContainer },\n                        react_1.default.createElement(\"span\", { className: header_css_1.default.LogoWrapper },\n                            react_1.default.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"40\", height: \"40\", viewBox: \"0 0 40 40\", fill: \"none\" },\n                                react_1.default.createElement(\"g\", { clipPath: \"url(#clip0_21502_116)\" },\n                                    react_1.default.createElement(\"path\", { d: \"M38.9151 23.2834C38.9151 33.7058 30.466 40 20.0437 40C9.62098 40 1.17188 31.5509 1.17188 21.1282C1.17188 10.7059 9.88496 4.2981 20.3073 4.2981C30.73 4.2981 38.9151 12.8607 38.9151 23.2834Z\", fill: \"#DC3E22\" }),\n                                    react_1.default.createElement(\"path\", { d: \"M28.238 12.6065C27.3211 11.6729 25.8377 10.8048 24.733 10.551C25.3401 10.0127 25.4623 9.99491 26.2227 9.61813C28.1713 8.65362 31.0576 8.56482 31.0576 8.56482C31.0576 8.56482 27.6509 6.80417 25.1601 6.91465C24.5259 6.94254 23.8571 7.16655 23.2118 7.484C23.5757 6.97051 23.9205 6.45995 24.1409 6.0764C24.8152 4.90365 25.524 3.42624 25.524 3.42624C25.524 3.42624 22.9122 3.5657 21.7008 5.01562C21.2407 5.56642 20.8934 6.26622 20.6392 6.92272C20.1878 6.40416 19.6896 5.94239 19.1913 5.58192C16.6999 3.77893 12.7192 4.169 12.7192 4.169C12.7192 4.169 15.7263 5.87482 17.0793 7.57653C17.6076 8.24107 18.1437 8.54839 18.4642 9.29349C17.3564 9.05364 14.8569 9.13562 13.63 9.59054C10.4771 10.7599 9.11852 15.4649 9.11852 15.4649C9.11852 15.4649 12.1952 13.3442 16.3813 11.8565C17.3017 11.5295 18.2748 11.4428 19.1229 11.4577C18.7379 12.0575 18.3173 12.8363 17.999 13.7546C17.2247 15.9904 18.2479 21.3113 18.2479 21.3113C18.2479 21.3113 20.4896 18.1646 21.403 15.6156C21.8718 14.3073 21.9879 12.9936 21.9904 12.0242C22.8217 12.3931 23.8009 12.9319 24.5326 13.398C28.2794 15.7852 30.072 20.1435 30.072 20.1435C30.072 20.1435 30.5941 15.0059 28.238 12.6065Z\", fill: \"#899441\" }),\n                                    react_1.default.createElement(\"path\", { d: \"M20.5008 10.3094C20.4889 10.3094 20.477 10.3091 20.4651 10.3088C19.7242 10.2896 19.1391 9.67376 19.1572 8.9334C19.1587 8.86931 19.2234 4.36125 16.7191 2.40111C16.135 1.94395 16.0318 1.09984 16.489 0.515424C16.9465 -0.0686834 17.7906 -0.171833 18.3747 0.285626C21.9559 3.08806 21.8491 8.76128 21.843 9.00145C21.8238 9.73083 21.2262 10.3094 20.5008 10.3094Z\", fill: \"#A8B64F\" })),\n                                react_1.default.createElement(\"defs\", null,\n                                    react_1.default.createElement(\"clipPath\", { id: \"clip0_21502_116\" },\n                                        react_1.default.createElement(\"rect\", { width: \"40\", height: \"40\", fill: \"white\" }))))),\n                        react_1.default.createElement(\"span\", { className: header_css_1.default.LogoText }, \"pomodoro_box\"))),\n                react_1.default.createElement(\"div\", { className: header_css_1.default.HeaderWrapper },\n                    isAuth &&\n                        react_1.default.createElement(\"div\", { className: header_css_1.default.UserName }, userData && \"\".concat(userData.name, \" \").concat(userData.surname)),\n                    isAuth &&\n                        react_1.default.createElement(react_router_dom_1.NavLink, { to: '/statistics' },\n                            react_1.default.createElement(\"div\", { className: header_css_1.default.HeaderButton },\n                                react_1.default.createElement(\"svg\", { className: header_css_1.default.HeaderButtonIcon, xmlns: \"http://www.w3.org/2000/svg\", width: \"24\", height: \"24\", viewBox: \"0 0 24 24\", fill: \"none\" },\n                                    react_1.default.createElement(\"g\", { clipPath: \"url(#clip0_21502_122)\" },\n                                        react_1.default.createElement(\"path\", { d: \"M10 20H14V4H10V20ZM4 20H8V12H4V20ZM16 9V20H20V9H16Z\" })),\n                                    react_1.default.createElement(\"defs\", null,\n                                        react_1.default.createElement(\"clipPath\", { id: \"clip0_21502_122\" },\n                                            react_1.default.createElement(\"rect\", { width: \"24\", height: \"24\", fill: \"white\" })))),\n                                \"\\u0421\\u0442\\u0430\\u0442\\u0438\\u0441\\u0442\\u0438\\u043A\\u0430\")),\n                    !isAuth &&\n                        react_1.default.createElement(react_router_dom_1.NavLink, { to: '/login' },\n                            react_1.default.createElement(\"div\", { className: header_css_1.default.HeaderLoginButton }, \"\\u0412\\u043E\\u0439\\u0442\\u0438\")),\n                    !isAuth &&\n                        react_1.default.createElement(react_router_dom_1.NavLink, { to: '/registration' },\n                            react_1.default.createElement(\"div\", { className: header_css_1.default.HeaderLoginButton, onClick: handleSignedUp }, \"\\u0417\\u0430\\u0440\\u0435\\u0433\\u0438\\u0441\\u0442\\u0440\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F\")),\n                    isAuth && react_1.default.createElement(\"div\", { className: header_css_1.default.HeaderLoginButton, onClick: function () { return dispatch((0, userReducer_1.logout)()); } }, \"\\u0412\\u044B\\u0445\\u043E\\u0434\"))))));\n}\nexports.Header = Header;\n\n\n//# sourceURL=webpack:///./src/shared/Header/Header.tsx?");

/***/ }),

/***/ "./src/shared/Header/header.css":
/*!**************************************!*\
  !*** ./src/shared/Header/header.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./header.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Header/header.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./header.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Header/header.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./header.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Header/header.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Header/header.css?");

/***/ }),

/***/ "./src/shared/Header/index.ts":
/*!************************************!*\
  !*** ./src/shared/Header/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Header */ \"./src/shared/Header/Header.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Header/index.ts?");

/***/ }),

/***/ "./src/shared/Input/Input.tsx":
/*!************************************!*\
  !*** ./src/shared/Input/Input.tsx ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Input = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar input_css_1 = __importDefault(__webpack_require__(/*! ./input.css */ \"./src/shared/Input/input.css\"));\nfunction Input(props) {\n    return (react_1.default.createElement(\"input\", { className: input_css_1.default.Input, onChange: function (e) { return props.setValue(e.target.value); }, type: props.type, placeholder: props.placeholder }));\n}\nexports.Input = Input;\n\n\n//# sourceURL=webpack:///./src/shared/Input/Input.tsx?");

/***/ }),

/***/ "./src/shared/Input/index.ts":
/*!***********************************!*\
  !*** ./src/shared/Input/index.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Input */ \"./src/shared/Input/Input.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Input/index.ts?");

/***/ }),

/***/ "./src/shared/Input/input.css":
/*!************************************!*\
  !*** ./src/shared/Input/input.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./input.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Input/input.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./input.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Input/input.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./input.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Input/input.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Input/input.css?");

/***/ }),

/***/ "./src/shared/Login/Login.tsx":
/*!************************************!*\
  !*** ./src/shared/Login/Login.tsx ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Login = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar login_css_1 = __importDefault(__webpack_require__(/*! ./login.css */ \"./src/shared/Login/login.css\"));\nvar Input_1 = __webpack_require__(/*! ../Input */ \"./src/shared/Input/index.ts\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar user_1 = __webpack_require__(/*! ../../actions/user */ \"./src/actions/user.js\");\nfunction Login() {\n    var _this = this;\n    var _a = (0, react_1.useState)(''), email = _a[0], setEmail = _a[1];\n    var _b = (0, react_1.useState)(''), password = _b[0], setPassword = _b[1];\n    var _c = (0, react_1.useState)(null), message = _c[0], setMessage = _c[1];\n    var _d = (0, react_1.useState)(''), error = _d[0], setError = _d[1];\n    var dispatch = (0, react_redux_1.useDispatch)();\n    var userData = (0, react_redux_1.useSelector)(function (state) { return state.user.currentUser; });\n    var errorTranslator = function (a) {\n        if (a === 'User not found') {\n            return a = 'Пользователь с таким email не найден';\n        }\n        else if (a === 'Invalid password') {\n            return a = 'Неверный пароль';\n        }\n        else {\n            return a = 'Неизвестная ошибка. Попробуйте еще раз';\n        }\n    };\n    (0, react_1.useEffect)(function () {\n        dispatch((0, user_1.login)(email, password));\n    }, []);\n    var handleLogin = function () { return __awaiter(_this, void 0, void 0, function () {\n        var data, error_2, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, dispatch((0, user_1.login)(email, password))];\n                case 1:\n                    data = _a.sent();\n                    if (data.success) {\n                        setError('');\n                        setMessage(data.message);\n                    }\n                    else {\n                        error_2 = errorTranslator(data.message);\n                        setError(error_2);\n                        setMessage(null);\n                    }\n                    return [3 /*break*/, 3];\n                case 2:\n                    error_1 = _a.sent();\n                    console.error('Произошла ошибка при входе в систему:', error_1);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n    return (react_1.default.createElement(\"div\", { className: login_css_1.default.Login },\n        react_1.default.createElement(\"div\", { className: login_css_1.default.LoginWrapper },\n            react_1.default.createElement(\"h2\", { className: login_css_1.default.LoginTitle }, \"\\u0412\\u0445\\u043E\\u0434\"),\n            react_1.default.createElement(Input_1.Input, { type: 'email', setValue: setEmail, placeholder: 'Email' }),\n            react_1.default.createElement(Input_1.Input, { type: 'password', setValue: setPassword, placeholder: 'Пароль' }),\n            error ? react_1.default.createElement(\"div\", { className: login_css_1.default.LoginError }, error) : react_1.default.createElement(\"div\", { className: login_css_1.default.LoginMessage }, message),\n            react_1.default.createElement(\"button\", { className: login_css_1.default.LoginBtn, onClick: function () { return handleLogin(); } }, \"\\u0412\\u043E\\u0439\\u0442\\u0438\"))));\n}\nexports.Login = Login;\n\n\n//# sourceURL=webpack:///./src/shared/Login/Login.tsx?");

/***/ }),

/***/ "./src/shared/Login/index.ts":
/*!***********************************!*\
  !*** ./src/shared/Login/index.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Login */ \"./src/shared/Login/Login.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Login/index.ts?");

/***/ }),

/***/ "./src/shared/Login/login.css":
/*!************************************!*\
  !*** ./src/shared/Login/login.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./login.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Login/login.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./login.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Login/login.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./login.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Login/login.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Login/login.css?");

/***/ }),

/***/ "./src/shared/Placeholder/Placeholder.tsx":
/*!************************************************!*\
  !*** ./src/shared/Placeholder/Placeholder.tsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Placeholder = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar placeholder_css_1 = __importDefault(__webpack_require__(/*! ./placeholder.css */ \"./src/shared/Placeholder/placeholder.css\"));\nfunction Placeholder() {\n    return (react_1.default.createElement(\"div\", { className: placeholder_css_1.default.Placeholder },\n        react_1.default.createElement(\"div\", { className: placeholder_css_1.default.MainContainer },\n            react_1.default.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"215\", height: \"215\", viewBox: \"0 0 115 115\", fill: \"none\" },\n                react_1.default.createElement(\"g\", { clipPath: \"url(#clip0_16_527)\" },\n                    react_1.default.createElement(\"path\", { d: \"M111.881 66.9398C111.881 96.9041 87.5898 115 57.6255 115C27.6603 115 3.36914 90.7089 3.36914 60.7437C3.36914 30.7794 28.4192 12.3571 58.3836 12.3571C88.3488 12.3571 111.881 36.9746 111.881 66.9398Z\", fill: \"#DC3E22\" }),\n                    react_1.default.createElement(\"path\", { d: \"M81.185 36.2439C78.5489 33.5598 74.284 31.0639 71.1081 30.3341C72.8534 28.7865 73.2046 28.7355 75.391 27.6522C80.9932 24.8793 89.2913 24.624 89.2913 24.624C89.2913 24.624 79.497 19.5621 72.3358 19.8797C70.5127 19.9599 68.5898 20.604 66.7346 21.5166C67.7807 20.0403 68.7719 18.5725 69.4056 17.4698C71.3442 14.0981 73.3822 9.85057 73.3822 9.85057C73.3822 9.85057 65.8733 10.2515 62.3903 14.42C61.0676 16.0036 60.0691 18.0155 59.3384 19.9029C58.0406 18.4121 56.6082 17.0845 55.1756 16.0481C48.0129 10.8645 36.5683 11.986 36.5683 11.986C36.5683 11.986 45.2138 16.8902 49.1036 21.7826C50.6224 23.6932 52.1638 24.5767 53.0852 26.7189C49.9003 26.0293 42.7142 26.265 39.1867 27.5729C30.1222 30.9348 26.2164 44.4617 26.2164 44.4617C26.2164 44.4617 35.0618 38.3648 47.0968 34.0876C49.743 33.1475 52.5406 32.8983 54.9789 32.9411C53.872 34.6654 52.6628 36.9045 51.7478 39.5446C49.5215 45.9724 52.4634 61.2701 52.4634 61.2701C52.4634 61.2701 58.9082 52.2234 61.5343 44.8951C62.8821 41.1335 63.2157 37.3568 63.2231 34.5698C65.6131 35.6302 68.4281 37.1793 70.5319 38.5193C81.3038 45.3826 86.4576 57.9127 86.4576 57.9127C86.4576 57.9127 87.9585 43.1422 81.185 36.2439Z\", fill: \"#899441\" }),\n                    react_1.default.createElement(\"path\", { d: \"M58.9395 29.6396C58.9053 29.6396 58.8711 29.6388 58.8368 29.6379C56.7066 29.5826 55.0246 27.8121 55.0764 25.6835C55.0808 25.4993 55.2668 12.5386 48.067 6.90318C46.3877 5.58886 46.0911 3.16203 47.4054 1.48184C48.7206 -0.197465 51.1475 -0.49402 52.8268 0.821175C63.1229 8.87817 62.8158 25.1887 62.7982 25.8792C62.7429 27.9761 61.025 29.6396 58.9395 29.6396Z\", fill: \"#A8B64F\" }),\n                    react_1.default.createElement(\"circle\", { cx: \"41.5\", cy: \"64.5\", r: \"2.5\", fill: \"black\" }),\n                    react_1.default.createElement(\"g\", { filter: \"url(#filter0_f_16_527)\" },\n                        react_1.default.createElement(\"circle\", { cx: \"29.5\", cy: \"75.5\", r: \"5.5\", fill: \"#EA8979\" })),\n                    react_1.default.createElement(\"g\", { filter: \"url(#filter1_f_16_527)\" },\n                        react_1.default.createElement(\"circle\", { cx: \"85.5\", cy: \"75.5\", r: \"5.5\", fill: \"#EA8979\" })),\n                    react_1.default.createElement(\"circle\", { cx: \"73.5\", cy: \"64.5\", r: \"2.5\", fill: \"black\" }),\n                    react_1.default.createElement(\"path\", { d: \"M46 78C50 82 64.5 83 68.5 78\", stroke: \"black\" })),\n                react_1.default.createElement(\"defs\", null,\n                    react_1.default.createElement(\"filter\", { id: \"filter0_f_16_527\", x: \"20\", y: \"66\", width: \"19\", height: \"19\", filterUnits: \"userSpaceOnUse\", colorInterpolationFilters: \"sRGB\" },\n                        react_1.default.createElement(\"feFlood\", { floodOpacity: \"0\", result: \"BackgroundImageFix\" }),\n                        react_1.default.createElement(\"feBlend\", { mode: \"normal\", in: \"SourceGraphic\", in2: \"BackgroundImageFix\", result: \"shape\" }),\n                        react_1.default.createElement(\"feGaussianBlur\", { stdDeviation: \"2\", result: \"effect1_foregroundBlur_16_527\" })),\n                    react_1.default.createElement(\"filter\", { id: \"filter1_f_16_527\", x: \"76\", y: \"66\", width: \"19\", height: \"19\", filterUnits: \"userSpaceOnUse\", colorInterpolationFilters: \"sRGB\" },\n                        react_1.default.createElement(\"feFlood\", { floodOpacity: \"0\", result: \"BackgroundImageFix\" }),\n                        react_1.default.createElement(\"feBlend\", { mode: \"normal\", in: \"SourceGraphic\", in2: \"BackgroundImageFix\", result: \"shape\" }),\n                        react_1.default.createElement(\"feGaussianBlur\", { stdDeviation: \"2\", result: \"effect1_foregroundBlur_16_527\" })),\n                    react_1.default.createElement(\"clipPath\", { id: \"clip0_16_527\" },\n                        react_1.default.createElement(\"rect\", { width: \"115\", height: \"115\", fill: \"white\" })))),\n            react_1.default.createElement(\"div\", { className: placeholder_css_1.default.Wrapper },\n                react_1.default.createElement(\"div\", { className: placeholder_css_1.default.PlaceholderPretitle }, \"\\u0412\\u044B \\u043F\\u043E\\u043A\\u0430 \\u043D\\u0435 \\u0430\\u0432\\u0442\\u043E\\u0440\\u0438\\u0437\\u043E\\u0432\\u0430\\u043D\\u044B\"),\n                react_1.default.createElement(\"div\", { className: placeholder_css_1.default.PlaceholderTitle }, \"\\u0412\\u043E\\u0439\\u0434\\u0438\\u0442\\u0435 \\u0438\\u043B\\u0438 \\u0437\\u0430\\u0440\\u0435\\u0433\\u0438\\u0441\\u0442\\u0440\\u0438\\u0440\\u0443\\u0439\\u0442\\u0435\\u0441\\u044C, \\u0447\\u0442\\u043E\\u0431\\u044B \\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F Pomodoro\")))));\n}\nexports.Placeholder = Placeholder;\n\n\n//# sourceURL=webpack:///./src/shared/Placeholder/Placeholder.tsx?");

/***/ }),

/***/ "./src/shared/Placeholder/index.ts":
/*!*****************************************!*\
  !*** ./src/shared/Placeholder/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Placeholder */ \"./src/shared/Placeholder/Placeholder.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Placeholder/index.ts?");

/***/ }),

/***/ "./src/shared/Placeholder/placeholder.css":
/*!************************************************!*\
  !*** ./src/shared/Placeholder/placeholder.css ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./placeholder.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Placeholder/placeholder.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./placeholder.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Placeholder/placeholder.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./placeholder.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Placeholder/placeholder.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Placeholder/placeholder.css?");

/***/ }),

/***/ "./src/shared/Registration/Registration.tsx":
/*!**************************************************!*\
  !*** ./src/shared/Registration/Registration.tsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Registration = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar registration_css_1 = __importDefault(__webpack_require__(/*! ./registration.css */ \"./src/shared/Registration/registration.css\"));\nvar Input_1 = __webpack_require__(/*! ../Input */ \"./src/shared/Input/index.ts\");\nvar user_1 = __webpack_require__(/*! ../../actions/user */ \"./src/actions/user.js\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nfunction Registration() {\n    var _this = this;\n    var _a = (0, react_1.useState)(''), email = _a[0], setEmail = _a[1];\n    var _b = (0, react_1.useState)(''), password = _b[0], setPassword = _b[1];\n    var _c = (0, react_1.useState)(''), name = _c[0], setName = _c[1];\n    var _d = (0, react_1.useState)(''), surname = _d[0], setSurname = _d[1];\n    var _e = (0, react_1.useState)(null), message = _e[0], setMessage = _e[1];\n    var _f = (0, react_1.useState)(null), error = _f[0], setError = _f[1];\n    var dispatch = (0, react_redux_1.useDispatch)();\n    (0, react_1.useEffect)(function () {\n        dispatch((0, user_1.registration)(name, surname, email, password));\n    }, []);\n    var handleRegistration = function (name, surname, email, password) { return __awaiter(_this, void 0, void 0, function () {\n        var res, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, dispatch((0, user_1.registration)(name, surname, email, password))];\n                case 1:\n                    res = _a.sent();\n                    if (res.success) {\n                        setError(null);\n                        setMessage(res.message);\n                    }\n                    else {\n                        setError(res.message);\n                        setMessage(null);\n                    }\n                    return [3 /*break*/, 3];\n                case 2:\n                    e_1 = _a.sent();\n                    console.log('Ошибка в обработке результата регистрации:', e_1);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n    return (react_1.default.createElement(\"div\", { className: registration_css_1.default.Registration },\n        react_1.default.createElement(\"div\", { className: registration_css_1.default.RegistrationWrapper },\n            react_1.default.createElement(\"h2\", { className: registration_css_1.default.RegistrationTitle }, \"\\u0420\\u0435\\u0433\\u0438\\u0441\\u0442\\u0440\\u0430\\u0446\\u0438\\u044F\"),\n            react_1.default.createElement(Input_1.Input, { type: 'test', setValue: setName, placeholder: 'Имя' }),\n            react_1.default.createElement(Input_1.Input, { type: 'test', setValue: setSurname, placeholder: 'Фамилия' }),\n            react_1.default.createElement(Input_1.Input, { type: 'email', setValue: setEmail, placeholder: 'Email' }),\n            react_1.default.createElement(Input_1.Input, { type: 'password', setValue: setPassword, placeholder: 'Пароль' }),\n            error ? react_1.default.createElement(\"div\", { className: registration_css_1.default.RegistrationError }, error) : react_1.default.createElement(\"div\", { className: registration_css_1.default.RegistrationMessage }, message),\n            react_1.default.createElement(\"button\", { onClick: function () { return handleRegistration(name, surname, email, password); }, className: registration_css_1.default.RegistrationBtn }, \"\\u0417\\u0430\\u0440\\u0435\\u0433\\u0438\\u0441\\u0442\\u0440\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F\"))));\n}\nexports.Registration = Registration;\n\n\n//# sourceURL=webpack:///./src/shared/Registration/Registration.tsx?");

/***/ }),

/***/ "./src/shared/Registration/index.ts":
/*!******************************************!*\
  !*** ./src/shared/Registration/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Registration */ \"./src/shared/Registration/Registration.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Registration/index.ts?");

/***/ }),

/***/ "./src/shared/Registration/registration.css":
/*!**************************************************!*\
  !*** ./src/shared/Registration/registration.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./registration.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Registration/registration.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./registration.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Registration/registration.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./registration.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Registration/registration.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Registration/registration.css?");

/***/ }),

/***/ "./src/shared/Statistics/Statistics.tsx":
/*!**********************************************!*\
  !*** ./src/shared/Statistics/Statistics.tsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Statistics = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar statistics_css_1 = __importDefault(__webpack_require__(/*! ./statistics.css */ \"./src/shared/Statistics/statistics.css\"));\nvar TestData_1 = __webpack_require__(/*! ./TestData */ \"./src/shared/Statistics/TestData.js\");\nvar Test_1 = __webpack_require__(/*! ./Test */ \"./src/shared/Statistics/Test/index.js\");\nfunction Statistics() {\n    // const { userData } = useData();\n    var _a = (0, react_1.useState)({\n        labels: TestData_1.TestData.map(function (data) { return data.year; }),\n        datasets: [\n            {\n                label: \"Users Gained\",\n                data: TestData_1.TestData.map(function (data) { return data.userGain; }),\n                backgroundColor: [\n                    \"rgba(75,192,192,1)\",\n                    \"#ecf0f1\",\n                    \"#50AF95\",\n                    \"#f3ba2f\",\n                    \"#2a71d0\",\n                ],\n                borderColor: \"black\",\n                borderWidth: 2,\n            },\n        ],\n    }), testData = _a[0], setTestData = _a[1];\n    return (react_1.default.createElement(\"div\", { className: statistics_css_1.default.Statistics },\n        react_1.default.createElement(\"div\", { className: statistics_css_1.default.StatisticsHeaderWrapper },\n            react_1.default.createElement(\"h3\", { className: statistics_css_1.default.StatisticsTitle }, \"\\u0412\\u0430\\u0448\\u0430 \\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u043E\\u0441\\u0442\\u044C\"),\n            react_1.default.createElement(\"div\", { className: statistics_css_1.default.StatisticsDropdown })),\n        react_1.default.createElement(\"div\", { className: statistics_css_1.default.StatisticsContainer },\n            react_1.default.createElement(\"div\", { className: statistics_css_1.default.col },\n                react_1.default.createElement(\"div\", { className: statistics_css_1.default.card1 }),\n                react_1.default.createElement(\"div\", { className: statistics_css_1.default.card2 },\n                    react_1.default.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: \"115\", height: \"115\", viewBox: \"0 0 115 115\", fill: \"none\" },\n                        react_1.default.createElement(\"g\", { clipPath: \"url(#clip0_16_527)\" },\n                            react_1.default.createElement(\"path\", { d: \"M111.881 66.9398C111.881 96.9041 87.5898 115 57.6255 115C27.6603 115 3.36914 90.7089 3.36914 60.7437C3.36914 30.7794 28.4192 12.3571 58.3836 12.3571C88.3488 12.3571 111.881 36.9746 111.881 66.9398Z\", fill: \"#DC3E22\" }),\n                            react_1.default.createElement(\"path\", { d: \"M81.185 36.2439C78.5489 33.5598 74.284 31.0639 71.1081 30.3341C72.8534 28.7865 73.2046 28.7355 75.391 27.6522C80.9932 24.8793 89.2913 24.624 89.2913 24.624C89.2913 24.624 79.497 19.5621 72.3358 19.8797C70.5127 19.9599 68.5898 20.604 66.7346 21.5166C67.7807 20.0403 68.7719 18.5725 69.4056 17.4698C71.3442 14.0981 73.3822 9.85057 73.3822 9.85057C73.3822 9.85057 65.8733 10.2515 62.3903 14.42C61.0676 16.0036 60.0691 18.0155 59.3384 19.9029C58.0406 18.4121 56.6082 17.0845 55.1756 16.0481C48.0129 10.8645 36.5683 11.986 36.5683 11.986C36.5683 11.986 45.2138 16.8902 49.1036 21.7826C50.6224 23.6932 52.1638 24.5767 53.0852 26.7189C49.9003 26.0293 42.7142 26.265 39.1867 27.5729C30.1222 30.9348 26.2164 44.4617 26.2164 44.4617C26.2164 44.4617 35.0618 38.3648 47.0968 34.0876C49.743 33.1475 52.5406 32.8983 54.9789 32.9411C53.872 34.6654 52.6628 36.9045 51.7478 39.5446C49.5215 45.9724 52.4634 61.2701 52.4634 61.2701C52.4634 61.2701 58.9082 52.2234 61.5343 44.8951C62.8821 41.1335 63.2157 37.3568 63.2231 34.5698C65.6131 35.6302 68.4281 37.1793 70.5319 38.5193C81.3038 45.3826 86.4576 57.9127 86.4576 57.9127C86.4576 57.9127 87.9585 43.1422 81.185 36.2439Z\", fill: \"#899441\" }),\n                            react_1.default.createElement(\"path\", { d: \"M58.9395 29.6396C58.9053 29.6396 58.8711 29.6388 58.8368 29.6379C56.7066 29.5826 55.0246 27.8121 55.0764 25.6835C55.0808 25.4993 55.2668 12.5386 48.067 6.90318C46.3877 5.58886 46.0911 3.16203 47.4054 1.48184C48.7206 -0.197465 51.1475 -0.49402 52.8268 0.821175C63.1229 8.87817 62.8158 25.1887 62.7982 25.8792C62.7429 27.9761 61.025 29.6396 58.9395 29.6396Z\", fill: \"#A8B64F\" }),\n                            react_1.default.createElement(\"circle\", { cx: \"41.5\", cy: \"64.5\", r: \"2.5\", fill: \"black\" }),\n                            react_1.default.createElement(\"g\", { filter: \"url(#filter0_f_16_527)\" },\n                                react_1.default.createElement(\"circle\", { cx: \"29.5\", cy: \"75.5\", r: \"5.5\", fill: \"#EA8979\" })),\n                            react_1.default.createElement(\"g\", { filter: \"url(#filter1_f_16_527)\" },\n                                react_1.default.createElement(\"circle\", { cx: \"85.5\", cy: \"75.5\", r: \"5.5\", fill: \"#EA8979\" })),\n                            react_1.default.createElement(\"circle\", { cx: \"73.5\", cy: \"64.5\", r: \"2.5\", fill: \"black\" }),\n                            react_1.default.createElement(\"path\", { d: \"M46 78C50 82 64.5 83 68.5 78\", stroke: \"black\" })),\n                        react_1.default.createElement(\"defs\", null,\n                            react_1.default.createElement(\"filter\", { id: \"filter0_f_16_527\", x: \"20\", y: \"66\", width: \"19\", height: \"19\", filterUnits: \"userSpaceOnUse\", colorInterpolationFilters: \"sRGB\" },\n                                react_1.default.createElement(\"feFlood\", { floodOpacity: \"0\", result: \"BackgroundImageFix\" }),\n                                react_1.default.createElement(\"feBlend\", { mode: \"normal\", in: \"SourceGraphic\", in2: \"BackgroundImageFix\", result: \"shape\" }),\n                                react_1.default.createElement(\"feGaussianBlur\", { stdDeviation: \"2\", result: \"effect1_foregroundBlur_16_527\" })),\n                            react_1.default.createElement(\"filter\", { id: \"filter1_f_16_527\", x: \"76\", y: \"66\", width: \"19\", height: \"19\", filterUnits: \"userSpaceOnUse\", colorInterpolationFilters: \"sRGB\" },\n                                react_1.default.createElement(\"feFlood\", { floodOpacity: \"0\", result: \"BackgroundImageFix\" }),\n                                react_1.default.createElement(\"feBlend\", { mode: \"normal\", in: \"SourceGraphic\", in2: \"BackgroundImageFix\", result: \"shape\" }),\n                                react_1.default.createElement(\"feGaussianBlur\", { stdDeviation: \"2\", result: \"effect1_foregroundBlur_16_527\" })),\n                            react_1.default.createElement(\"clipPath\", { id: \"clip0_16_527\" },\n                                react_1.default.createElement(\"rect\", { width: \"115\", height: \"115\", fill: \"white\" })))))),\n            react_1.default.createElement(\"div\", { className: statistics_css_1.default.StatisticsChart },\n                react_1.default.createElement(\"div\", { style: { width: 700 } },\n                    react_1.default.createElement(Test_1.BarChart, { chartData: testData })))),\n        react_1.default.createElement(\"div\", { className: statistics_css_1.default.StatisticsGrid },\n            react_1.default.createElement(\"div\", { className: statistics_css_1.default.GridItem }),\n            react_1.default.createElement(\"div\", { className: statistics_css_1.default.GridItem }),\n            react_1.default.createElement(\"div\", { className: statistics_css_1.default.GridItem }))));\n}\nexports.Statistics = Statistics;\n\n\n//# sourceURL=webpack:///./src/shared/Statistics/Statistics.tsx?");

/***/ }),

/***/ "./src/shared/Statistics/Test/BarChart.jsx":
/*!*************************************************!*\
  !*** ./src/shared/Statistics/Test/BarChart.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BarChart = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar react_chartjs_2_1 = __webpack_require__(/*! react-chartjs-2 */ \"./node_modules/react-chartjs-2/dist/index.js\");\nfunction BarChart(_a) {\n    var chartData = _a.chartData;\n    return react_1.default.createElement(react_chartjs_2_1.Bar, { data: chartData });\n}\nexports.BarChart = BarChart;\n\n\n//# sourceURL=webpack:///./src/shared/Statistics/Test/BarChart.jsx?");

/***/ }),

/***/ "./src/shared/Statistics/Test/index.js":
/*!*********************************************!*\
  !*** ./src/shared/Statistics/Test/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./BarChart */ \"./src/shared/Statistics/Test/BarChart.jsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Statistics/Test/index.js?");

/***/ }),

/***/ "./src/shared/Statistics/TestData.js":
/*!*******************************************!*\
  !*** ./src/shared/Statistics/TestData.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TestData = void 0;\nexports.TestData = [\n    {\n        id: 1,\n        year: 2016,\n        userGain: 80000,\n        userLost: 823,\n    },\n    {\n        id: 2,\n        year: 2017,\n        userGain: 45677,\n        userLost: 345,\n    },\n    {\n        id: 3,\n        year: 2018,\n        userGain: 78888,\n        userLost: 555,\n    },\n    {\n        id: 4,\n        year: 2019,\n        userGain: 90000,\n        userLost: 4555,\n    },\n    {\n        id: 5,\n        year: 2020,\n        userGain: 4300,\n        userLost: 234,\n    },\n];\n\n\n//# sourceURL=webpack:///./src/shared/Statistics/TestData.js?");

/***/ }),

/***/ "./src/shared/Statistics/index.ts":
/*!****************************************!*\
  !*** ./src/shared/Statistics/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Statistics */ \"./src/shared/Statistics/Statistics.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Statistics/index.ts?");

/***/ }),

/***/ "./src/shared/Statistics/statistics.css":
/*!**********************************************!*\
  !*** ./src/shared/Statistics/statistics.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./statistics.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Statistics/statistics.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./statistics.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Statistics/statistics.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./statistics.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Statistics/statistics.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Statistics/statistics.css?");

/***/ }),

/***/ "./src/shared/errorBoundary.js":
/*!*************************************!*\
  !*** ./src/shared/errorBoundary.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("throw new Error(\"Module build failed (from ./node_modules/ts-loader/index.js):\\nError: ENOENT: no such file or directory, open '/Users/nikitabatryncha/Desktop/pomtemp/frontend/src/shared/errorBoundary.js'\");\n\n//# sourceURL=webpack:///./src/shared/errorBoundary.js?");

/***/ })

})