webpackHotUpdate("main",{

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".todotask__ToDoTask--2smur {\\n  font-size: 16px;\\n  line-height: 17px;\\n}\\n\", \"\"]);\n// Exports\nexports.locals = {\n\t\"ToDoTask\": \"todotask__ToDoTask--2smur\"\n};\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/mobx-react/dist/mobxreact.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/mobx-react/dist/mobxreact.esm.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.observer = exports.inject = exports.disposeOnUnmount = exports.Provider = exports.PropTypes = exports.MobXProviderContext = exports.useStaticRendering = exports.useObserver = exports.useLocalStore = exports.useLocalObservable = exports.useAsObservableSource = exports.observerBatching = exports.isUsingStaticRendering = exports.enableStaticRendering = exports.Observer = void 0;\nvar mobx_1 = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar mobx_react_lite_1 = __webpack_require__(/*! mobx-react-lite */ \"./node_modules/mobx-react-lite/es/index.js\");\nvar mobx_react_lite_2 = __webpack_require__(/*! mobx-react-lite */ \"./node_modules/mobx-react-lite/es/index.js\");\nObject.defineProperty(exports, \"Observer\", { enumerable: true, get: function () { return mobx_react_lite_2.Observer; } });\nObject.defineProperty(exports, \"enableStaticRendering\", { enumerable: true, get: function () { return mobx_react_lite_2.enableStaticRendering; } });\nObject.defineProperty(exports, \"isUsingStaticRendering\", { enumerable: true, get: function () { return mobx_react_lite_2.isUsingStaticRendering; } });\nObject.defineProperty(exports, \"observerBatching\", { enumerable: true, get: function () { return mobx_react_lite_2.observerBatching; } });\nObject.defineProperty(exports, \"useAsObservableSource\", { enumerable: true, get: function () { return mobx_react_lite_2.useAsObservableSource; } });\nObject.defineProperty(exports, \"useLocalObservable\", { enumerable: true, get: function () { return mobx_react_lite_2.useLocalObservable; } });\nObject.defineProperty(exports, \"useLocalStore\", { enumerable: true, get: function () { return mobx_react_lite_2.useLocalStore; } });\nObject.defineProperty(exports, \"useObserver\", { enumerable: true, get: function () { return mobx_react_lite_2.useObserver; } });\nObject.defineProperty(exports, \"useStaticRendering\", { enumerable: true, get: function () { return mobx_react_lite_2.useStaticRendering; } });\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for (var i = 0; i < keysA.length; i++) {\n        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    displayName: 1,\n    propTypes: 1\n};\nfunction copyStaticProperties(base, target) {\n    var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));\n    Object.getOwnPropertyNames(base).forEach(function (key) {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nvar mobxMixins = /*#__PURE__*/ Symbol(\"patchMixins\");\nvar mobxPatchedDefinition = /*#__PURE__*/ Symbol(\"patchedDefinition\");\nfunction getMixins(target, methodName) {\n    var mixins = target[mobxMixins] = target[mobxMixins] || {};\n    var methodMixins = mixins[methodName] = mixins[methodName] || {};\n    methodMixins.locks = methodMixins.locks || 0;\n    methodMixins.methods = methodMixins.methods || [];\n    return methodMixins;\n}\nfunction wrapper(realMethod, mixins) {\n    var _this = this;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n    }\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++;\n    try {\n        var retVal;\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args);\n        }\n        return retVal;\n    }\n    finally {\n        mixins.locks--;\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(function (mx) {\n                mx.apply(_this, args);\n            });\n        }\n    }\n}\nfunction wrapFunction(realMethod, mixins) {\n    var fn = function fn() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n        wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));\n    };\n    return fn;\n}\nfunction patch(target, methodName, mixinMethod) {\n    var mixins = getMixins(target, methodName);\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod);\n    }\n    var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return;\n    }\n    var originalMethod = target[methodName];\n    var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);\n    Object.defineProperty(target, methodName, newDefinition);\n}\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n    var _ref;\n    var wrappedFunc = wrapFunction(originalMethod, mixins);\n    return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get() {\n        return wrappedFunc;\n    }, _ref.set = function set(value) {\n        if (this === target) {\n            wrappedFunc = wrapFunction(value, mixins);\n        }\n        else {\n            // when it is an instance of the prototype/a child prototype patch that particular case again separately\n            // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n            // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n            // as the method for the instance\n            var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);\n            Object.defineProperty(this, methodName, newDefinition);\n        }\n    }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;\n}\nvar administrationSymbol = /*#__PURE__*/ Symbol(\"ObserverAdministration\");\nvar isMobXReactObserverSymbol = /*#__PURE__*/ Symbol(\"isMobXReactObserver\");\nvar observablePropDescriptors;\nif (true) {\n    observablePropDescriptors = {\n        props: /*#__PURE__*/ createObservablePropDescriptor(\"props\"),\n        state: /*#__PURE__*/ createObservablePropDescriptor(\"state\"),\n        context: /*#__PURE__*/ createObservablePropDescriptor(\"context\")\n    };\n}\nfunction getAdministration(component) {\n    var _component$administra;\n    // We create administration lazily, because we can't patch constructor\n    // and the exact moment of initialization partially depends on React internals.\n    // At the time of writing this, the first thing invoked is one of the observable getter/setter (state/props/context).\n    return (_component$administra = component[administrationSymbol]) != null ? _component$administra : component[administrationSymbol] = {\n        reaction: null,\n        mounted: false,\n        reactionInvalidatedBeforeMount: false,\n        forceUpdate: null,\n        name: getDisplayName(component.constructor),\n        state: undefined,\n        props: undefined,\n        context: undefined\n    };\n}\nfunction makeClassComponentObserver(componentClass) {\n    var prototype = componentClass.prototype;\n    if (componentClass[isMobXReactObserverSymbol]) {\n        var displayName = getDisplayName(componentClass);\n        throw new Error(\"The provided component class (\" + displayName + \") has already been declared as an observer component.\");\n    }\n    else {\n        componentClass[isMobXReactObserverSymbol] = true;\n    }\n    if (prototype.componentWillReact) {\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n    }\n    if (componentClass[\"__proto__\"] !== react_1.PureComponent) {\n        if (!prototype.shouldComponentUpdate) {\n            prototype.shouldComponentUpdate = observerSCU;\n        }\n        else if (prototype.shouldComponentUpdate !== observerSCU) {\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n        }\n    }\n    if (true) {\n        Object.defineProperties(prototype, observablePropDescriptors);\n    }\n    var originalRender = prototype.render;\n    if (typeof originalRender !== \"function\") {\n        var _displayName = getDisplayName(componentClass);\n        throw new Error(\"[mobx-react] class component (\" + _displayName + \") is missing `render` method.\" + \"\\n`observer` requires `render` being a function defined on prototype.\" + \"\\n`render = () => {}` or `render = function() {}` is not supported.\");\n    }\n    prototype.render = function () {\n        Object.defineProperty(this, \"render\", {\n            // There is no safe way to replace render, therefore it's forbidden.\n            configurable: false,\n            writable: false,\n            value: (0, mobx_react_lite_1.isUsingStaticRendering)() ? originalRender : createReactiveRender.call(this, originalRender)\n        });\n        return this.render();\n    };\n    var originalComponentDidMount = prototype.componentDidMount;\n    prototype.componentDidMount = function () {\n        var _this = this;\n        if ( true && this.componentDidMount !== Object.getPrototypeOf(this).componentDidMount) {\n            var _displayName2 = getDisplayName(componentClass);\n            throw new Error(\"[mobx-react] `observer(\" + _displayName2 + \").componentDidMount` must be defined on prototype.\" + \"\\n`componentDidMount = () => {}` or `componentDidMount = function() {}` is not supported.\");\n        }\n        // `componentDidMount` may not be called at all. React can abandon the instance after `render`.\n        // That's why we use finalization registry to dispose reaction created during render.\n        // Happens with `<Suspend>` see #3492\n        //\n        // `componentDidMount` can be called immediately after `componentWillUnmount` without calling `render` in between.\n        // Happens with `<StrictMode>`see #3395.\n        //\n        // If `componentDidMount` is called, it's guaranteed to run synchronously with render (similary to `useLayoutEffect`).\n        // Therefore we don't have to worry about external (observable) state being updated before mount (no state version checking).\n        //\n        // Things may change: \"In the future, React will provide a feature that lets components preserve state between unmounts\"\n        var admin = getAdministration(this);\n        admin.mounted = true;\n        // Component instance committed, prevent reaction disposal.\n        mobx_react_lite_1._observerFinalizationRegistry.unregister(this);\n        // We don't set forceUpdate before mount because it requires a reference to `this`,\n        // therefore `this` could NOT be garbage collected before mount,\n        // preventing reaction disposal by FinalizationRegistry and leading to memory leak.\n        // As an alternative we could have `admin.instanceRef = new WeakRef(this)`, but lets avoid it if possible.\n        admin.forceUpdate = function () {\n            return _this.forceUpdate();\n        };\n        if (!admin.reaction || admin.reactionInvalidatedBeforeMount) {\n            // Missing reaction:\n            // 1. Instance was unmounted (reaction disposed) and immediately remounted without running render #3395.\n            // 2. Reaction was disposed by finalization registry before mount. Shouldn't ever happen for class components:\n            // `componentDidMount` runs synchronously after render, but our registry are deferred (can't run in between).\n            // In any case we lost subscriptions to observables, so we have to create new reaction and re-render to resubscribe.\n            // The reaction will be created lazily by following render.\n            // Reaction invalidated before mount:\n            // 1. A descendant's `componenDidMount` invalidated it's parent #3730\n            admin.forceUpdate();\n        }\n        return originalComponentDidMount == null ? void 0 : originalComponentDidMount.apply(this, arguments);\n    };\n    // TODO@major Overly complicated \"patch\" is only needed to support the deprecated @disposeOnUnmount\n    patch(prototype, \"componentWillUnmount\", function () {\n        var _admin$reaction;\n        if ((0, mobx_react_lite_1.isUsingStaticRendering)()) {\n            return;\n        }\n        var admin = getAdministration(this);\n        (_admin$reaction = admin.reaction) == null ? void 0 : _admin$reaction.dispose();\n        admin.reaction = null;\n        admin.forceUpdate = null;\n        admin.mounted = false;\n        admin.reactionInvalidatedBeforeMount = false;\n    });\n    return componentClass;\n}\n// Generates a friendly name for debugging\nfunction getDisplayName(componentClass) {\n    return componentClass.displayName || componentClass.name || \"<component>\";\n}\nfunction createReactiveRender(originalRender) {\n    var boundOriginalRender = originalRender.bind(this);\n    var admin = getAdministration(this);\n    function reactiveRender() {\n        if (!admin.reaction) {\n            // Create reaction lazily to support re-mounting #3395\n            admin.reaction = createReaction(admin);\n            if (!admin.mounted) {\n                // React can abandon this instance and never call `componentDidMount`/`componentWillUnmount`,\n                // we have to make sure reaction will be disposed.\n                mobx_react_lite_1._observerFinalizationRegistry.register(this, admin, this);\n            }\n        }\n        var error = undefined;\n        var renderResult = undefined;\n        admin.reaction.track(function () {\n            try {\n                // TODO@major\n                // Optimization: replace with _allowStateChangesStart/End (not available in mobx@6.0.0)\n                renderResult = (0, mobx_1._allowStateChanges)(false, boundOriginalRender);\n            }\n            catch (e) {\n                error = e;\n            }\n        });\n        if (error) {\n            throw error;\n        }\n        return renderResult;\n    }\n    return reactiveRender;\n}\nfunction createReaction(admin) {\n    return new mobx_1.Reaction(admin.name + \".render()\", function () {\n        if (!admin.mounted) {\n            // This is neccessary to avoid react warning about calling forceUpdate on component that isn't mounted yet.\n            // This happens when component is abandoned after render - our reaction is already created and reacts to changes.\n            // `componenDidMount` runs synchronously after `render`, so unlike functional component, there is no delay during which the reaction could be invalidated.\n            // However `componentDidMount` runs AFTER it's descendants' `componentDidMount`, which CAN invalidate the reaction, see #3730. Therefore remember and forceUpdate on mount.\n            admin.reactionInvalidatedBeforeMount = true;\n            return;\n        }\n        try {\n            admin.forceUpdate == null ? void 0 : admin.forceUpdate();\n        }\n        catch (error) {\n            var _admin$reaction2;\n            (_admin$reaction2 = admin.reaction) == null ? void 0 : _admin$reaction2.dispose();\n            admin.reaction = null;\n        }\n    });\n}\nfunction observerSCU(nextProps, nextState) {\n    if ((0, mobx_react_lite_1.isUsingStaticRendering)()) {\n        console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true;\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps);\n}\nfunction createObservablePropDescriptor(key) {\n    return {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            var admin = getAdministration(this);\n            var derivation = (0, mobx_1._getGlobalState)().trackingDerivation;\n            if (derivation && derivation !== admin.reaction) {\n                throw new Error(\"[mobx-react] Cannot read \\\"\" + admin.name + \".\" + key + \"\\\" in a reactive context, as it isn't observable.\\n                    Please use component lifecycle method to copy the value into a local observable first.\\n                    See https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations\");\n            }\n            return admin[key];\n        },\n        set: function set(value) {\n            getAdministration(this)[key] = value;\n        }\n    };\n}\nfunction observer(component, context) {\n    if (context && context.kind !== \"class\") {\n        throw new Error(\"The @observer decorator can be used on classes only\");\n    }\n    if (component[\"isMobxInjector\"] === true) {\n        console.warn(\"Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`\");\n    }\n    if (Object.prototype.isPrototypeOf.call(react_1.Component, component) || Object.prototype.isPrototypeOf.call(react_1.PureComponent, component)) {\n        // Class component\n        return makeClassComponentObserver(component);\n    }\n    else {\n        // Function component\n        return (0, mobx_react_lite_1.observer)(component);\n    }\n}\nexports.observer = observer;\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null)\n        return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n            continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar _excluded = [\"children\"];\nvar MobXProviderContext = /*#__PURE__*/ react_1.default.createContext({});\nexports.MobXProviderContext = MobXProviderContext;\nfunction Provider(props) {\n    var children = props.children, stores = _objectWithoutPropertiesLoose(props, _excluded);\n    var parentValue = react_1.default.useContext(MobXProviderContext);\n    var mutableProviderRef = react_1.default.useRef(_extends({}, parentValue, stores));\n    var value = mutableProviderRef.current;\n    if (true) {\n        var newValue = _extends({}, value, stores); // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) {\n            throw new Error(\"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\");\n        }\n    }\n    return react_1.default.createElement(MobXProviderContext.Provider, {\n        value: value\n    }, children);\n}\nexports.Provider = Provider;\nProvider.displayName = \"MobXProvider\";\n/**\n * Store Injection\n */\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n    // Support forward refs\n    var Injector = react_1.default.forwardRef(function (props, ref) {\n        var newProps = _extends({}, props);\n        var context = react_1.default.useContext(MobXProviderContext);\n        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});\n        if (ref) {\n            newProps.ref = ref;\n        }\n        return react_1.default.createElement(component, newProps);\n    });\n    if (makeReactive)\n        Injector = observer(Injector);\n    Injector[\"isMobxInjector\"] = true; // assigned late to suppress observer warning\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, Injector);\n    Injector[\"wrappedComponent\"] = component;\n    Injector.displayName = getInjectName(component, injectNames);\n    return Injector;\n}\nfunction getInjectName(component, injectNames) {\n    var displayName;\n    var componentName = component.displayName || component.name || component.constructor && component.constructor.name || \"Component\";\n    if (injectNames)\n        displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\";\n    else\n        displayName = \"inject(\" + componentName + \")\";\n    return displayName;\n}\nfunction grabStoresByName(storeNames) {\n    return function (baseStores, nextProps) {\n        storeNames.forEach(function (storeName) {\n            if (storeName in nextProps // prefer props over stores\n            )\n                return;\n            if (!(storeName in baseStores))\n                throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n            nextProps[storeName] = baseStores[storeName];\n        });\n        return nextProps;\n    };\n}\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nfunction inject() {\n    for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        storeNames[_key] = arguments[_key];\n    }\n    if (typeof arguments[0] === \"function\") {\n        var grabStoresFn = arguments[0];\n        return function (componentClass) {\n            return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);\n        };\n    }\n    else {\n        return function (componentClass) {\n            return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join(\"-\"), false);\n        };\n    }\n}\nexports.inject = inject;\nvar reactMajorVersion = /*#__PURE__*/ Number.parseInt(/*#__PURE__*/ react_1.default.version.split(\".\")[0]);\nvar warnedAboutDisposeOnUnmountDeprecated = false;\nvar protoStoreKey = /*#__PURE__*/ Symbol(\"disposeOnUnmountProto\");\nvar instStoreKey = /*#__PURE__*/ Symbol(\"disposeOnUnmountInst\");\nfunction runDisposersOnWillUnmount() {\n    var _this = this;\n    [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function (propKeyOrFunction) {\n        var prop = typeof propKeyOrFunction === \"string\" ? _this[propKeyOrFunction] : propKeyOrFunction;\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop))\n                prop.map(function (f) {\n                    return f();\n                });\n            else\n                prop();\n        }\n    });\n}\n/**\n * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.\n */\nfunction disposeOnUnmount(target, propertyKeyOrFunction) {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(function (fn) {\n            return disposeOnUnmount(target, fn);\n        });\n    }\n    if (!warnedAboutDisposeOnUnmountDeprecated) {\n        if (reactMajorVersion >= 18) {\n            console.error(\"[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.\");\n        }\n        else {\n            console.warn(\"[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher.\");\n        }\n        warnedAboutDisposeOnUnmountDeprecated = true;\n    }\n    var c = Object.getPrototypeOf(target).constructor;\n    var c2 = Object.getPrototypeOf(target.constructor);\n    // Special case for react-hot-loader\n    var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));\n    if (!(c === react_1.default.Component || c === react_1.default.PureComponent || c2 === react_1.default.Component || c2 === react_1.default.PureComponent || c3 === react_1.default.Component || c3 === react_1.default.PureComponent)) {\n        throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n    }\n    if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\" && !Array.isArray(propertyKeyOrFunction)) {\n        throw new Error(\"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\");\n    }\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    var isDecorator = typeof propertyKeyOrFunction === \"string\";\n    // add property key / function we want run (disposed) to the store\n    var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];\n    var store = isDecorator ?\n        // decorators are added to the prototype store\n        target[protoStoreKey] || (target[protoStoreKey] = []) :\n        // functions are added to the instance store\n        target[instStoreKey] || (target[instStoreKey] = []);\n    store.push(propertyKeyOrFunction);\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount);\n    }\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction;\n    }\n}\nexports.disposeOnUnmount = disposeOnUnmount;\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validator) {\n    function checkType(isRequired, props, propName, componentName, location, propFullName) {\n        for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n            rest[_key - 6] = arguments[_key];\n        }\n        return (0, mobx_1.untracked)(function () {\n            componentName = componentName || \"<<anonymous>>\";\n            propFullName = propFullName || propName;\n            if (props[propName] == null) {\n                if (isRequired) {\n                    var actual = props[propName] === null ? \"null\" : \"undefined\";\n                    return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n                }\n                return null;\n            }\n            else {\n                // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n                return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));\n            }\n        });\n    }\n    var chainedCheckType = checkType.bind(null, false);\n    // Add isRequired to satisfy Requirable\n    chainedCheckType.isRequired = checkType.bind(null, true);\n    return chainedCheckType;\n}\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true;\n    }\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true;\n    }\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true;\n    }\n    return false;\n}\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n        return \"array\";\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\";\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\";\n    }\n    return propType;\n}\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    var propType = getPropType(propValue);\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\";\n        }\n        else if (propValue instanceof RegExp) {\n            return \"regexp\";\n        }\n    }\n    return propType;\n}\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        return (0, mobx_1.untracked)(function () {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase())\n                    return null;\n            }\n            var mobxChecker;\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = mobx_1.isObservableArray;\n                    break;\n                case \"Object\":\n                    mobxChecker = mobx_1.isObservableObject;\n                    break;\n                case \"Map\":\n                    mobxChecker = mobx_1.isObservableMap;\n                    break;\n                default:\n                    throw new Error(\"Unexpected mobxType: \" + mobxType);\n            }\n            var propValue = props[propName];\n            if (!mobxChecker(propValue)) {\n                var preciseType = getPreciseType(propValue);\n                var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n                return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n            }\n            return null;\n        });\n    });\n}\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n            rest[_key2 - 5] = arguments[_key2];\n        }\n        return (0, mobx_1.untracked)(function () {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n            }\n            else {\n                var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName, location, propFullName);\n                if (error instanceof Error)\n                    return error;\n                var propValue = props[propName];\n                for (var i = 0; i < propValue.length; i++) {\n                    error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n                    if (error instanceof Error)\n                        return error;\n                }\n                return null;\n            }\n        });\n    });\n}\nvar observableArray = /*#__PURE__*/ createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = /*#__PURE__*/ createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = /*#__PURE__*/ createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = /*#__PURE__*/ createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = /*#__PURE__*/ createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = /*#__PURE__*/ createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = /*#__PURE__*/ createObservableTypeCheckerCreator(true, \"Object\");\nvar PropTypes = {\n    observableArray: observableArray,\n    observableArrayOf: observableArrayOf,\n    observableMap: observableMap,\n    observableObject: observableObject,\n    arrayOrObservableArray: arrayOrObservableArray,\n    arrayOrObservableArrayOf: arrayOrObservableArrayOf,\n    objectOrObservableObject: objectOrObservableObject\n};\nexports.PropTypes = PropTypes;\nif (!react_1.Component) {\n    throw new Error(\"mobx-react requires React to be available\");\n}\nif (!mobx_1.observable) {\n    throw new Error(\"mobx-react requires mobx to be available\");\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/mobx-react/dist/mobxreact.esm.js?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx":
/*!**************************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ToDoTask = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar mobx_react_1 = __webpack_require__(/*! mobx-react */ \"./node_modules/mobx-react/dist/mobxreact.esm.js\");\nvar todotask_css_1 = __importDefault(__webpack_require__(/*! ./todotask.css */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\"));\nvar ToDoForm_1 = __webpack_require__(/*! ../../../leftSide/ToDoForm */ \"./src/shared/Content/leftSide/ToDoForm/index.ts\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nexports.ToDoTask = (0, mobx_react_1.observer)(function () {\n    var _a = (0, react_1.useState)(''), title = _a[0], setTitle = _a[1];\n    var buttonValue = (0, react_redux_1.useSelector)(function (state) { return state.data.buttonValue; });\n    (0, react_1.useEffect)(function () {\n        гыу;\n        setTitle(buttonValue || ToDoForm_1.myStore.value);\n    }, [buttonValue, ToDoForm_1.myStore.value]);\n    return (react_1.default.createElement(\"div\", { className: todotask_css_1.default.ToDoTask }, title));\n});\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts":
/*!**********************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./ToDoTask */ \"./src/shared/Content/rightSide/ToDoContainer/ToDoTask/ToDoTask.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/index.ts?");

/***/ }),

/***/ "./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css":
/*!**************************************************************************!*\
  !*** ./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotask.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotask.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!./todotask.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/shared/Content/rightSide/ToDoContainer/ToDoTask/todotask.css?");

/***/ })

})